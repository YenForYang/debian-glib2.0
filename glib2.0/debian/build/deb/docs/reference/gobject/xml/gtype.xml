<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC '-//OASIS//DTD DocBook XML V4.5//EN'
                      'http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd' [

<!ENTITY % local.common.attrib "xmlns:xi  CDATA  #FIXED 'http://www.w3.org/2003/XInclude'">
<!ENTITY version SYSTEM "version.xml">
]>
<refentry id="gobject-Type-Information">
<refmeta>
<refentrytitle role="top_of_page" id="gobject-Type-Information.top_of_page">Type Information</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>GOBJECT Library</refmiscinfo>
</refmeta>
<refnamediv>
<refname>Type Information</refname>
<refpurpose>The GLib Runtime type identification and
    management system</refpurpose>
</refnamediv>

<refsect1 id="gobject-Type-Information.functions" role="functions_proto">
<title role="functions_proto.title">Functions</title>
<informaltable pgwide="1" frame="none">
<tgroup cols="2">
<colspec colname="functions_return" colwidth="150px"/>
<colspec colname="functions_name"/>
<tbody>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-FUNDAMENTAL:CAPS">G_TYPE_FUNDAMENTAL</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-MAKE-FUNDAMENTAL:CAPS">G_TYPE_MAKE_FUNDAMENTAL</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-IS-ABSTRACT:CAPS">G_TYPE_IS_ABSTRACT</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-IS-DERIVED:CAPS">G_TYPE_IS_DERIVED</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-IS-FUNDAMENTAL:CAPS">G_TYPE_IS_FUNDAMENTAL</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-IS-VALUE-TYPE:CAPS">G_TYPE_IS_VALUE_TYPE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-HAS-VALUE-TABLE:CAPS">G_TYPE_HAS_VALUE_TABLE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-IS-CLASSED:CAPS">G_TYPE_IS_CLASSED</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-IS-INSTANTIATABLE:CAPS">G_TYPE_IS_INSTANTIATABLE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-IS-DERIVABLE:CAPS">G_TYPE_IS_DERIVABLE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-IS-DEEP-DERIVABLE:CAPS">G_TYPE_IS_DEEP_DERIVABLE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-IS-INTERFACE:CAPS">G_TYPE_IS_INTERFACE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-FROM-INSTANCE:CAPS">G_TYPE_FROM_INSTANCE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-FROM-CLASS:CAPS">G_TYPE_FROM_CLASS</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-FROM-INTERFACE:CAPS">G_TYPE_FROM_INTERFACE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-INSTANCE-GET-CLASS:CAPS">G_TYPE_INSTANCE_GET_CLASS</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-INSTANCE-GET-INTERFACE:CAPS">G_TYPE_INSTANCE_GET_INTERFACE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-INSTANCE-GET-PRIVATE:CAPS">G_TYPE_INSTANCE_GET_PRIVATE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-CLASS-GET-PRIVATE:CAPS">G_TYPE_CLASS_GET_PRIVATE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-CHECK-INSTANCE:CAPS">G_TYPE_CHECK_INSTANCE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-CHECK-INSTANCE-CAST:CAPS">G_TYPE_CHECK_INSTANCE_CAST</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-CHECK-INSTANCE-TYPE:CAPS">G_TYPE_CHECK_INSTANCE_TYPE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-CHECK-INSTANCE-FUNDAMENTAL-TYPE:CAPS">G_TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-CHECK-CLASS-CAST:CAPS">G_TYPE_CHECK_CLASS_CAST</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-CHECK-CLASS-TYPE:CAPS">G_TYPE_CHECK_CLASS_TYPE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-CHECK-VALUE:CAPS">G_TYPE_CHECK_VALUE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-CHECK-VALUE-TYPE:CAPS">G_TYPE_CHECK_VALUE_TYPE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-init">g_type_init</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-init-with-debug-flags">g_type_init_with_debug_flags</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type">const <link linkend="gchar"><returnvalue>gchar</returnvalue></link>&#160;*
</entry><entry role="function_name"><link linkend="g-type-name">g_type_name</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GQuark"><returnvalue>GQuark</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-qname">g_type_qname</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GType"><returnvalue>GType</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-from-name">g_type_from_name</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GType"><returnvalue>GType</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-parent">g_type_parent</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="guint"><returnvalue>guint</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-depth">g_type_depth</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GType"><returnvalue>GType</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-next-base">g_type_next_base</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="gboolean"><returnvalue>gboolean</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-is-a">g_type_is_a</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-class-ref">g_type_class_ref</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-class-peek">g_type_class_peek</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-class-peek-static">g_type_class_peek_static</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-class-unref">g_type_class_unref</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-class-peek-parent">g_type_class_peek_parent</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-class-add-private">g_type_class_add_private</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-add-class-private">g_type_add_class_private</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-interface-peek">g_type_interface_peek</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-interface-peek-parent">g_type_interface_peek_parent</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-default-interface-ref">g_type_default_interface_ref</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-default-interface-peek">g_type_default_interface_peek</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-default-interface-unref">g_type_default_interface_unref</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GType"><returnvalue>GType</returnvalue></link>&#160;*
</entry><entry role="function_name"><link linkend="g-type-children">g_type_children</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GType"><returnvalue>GType</returnvalue></link>&#160;*
</entry><entry role="function_name"><link linkend="g-type-interfaces">g_type_interfaces</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GType"><returnvalue>GType</returnvalue></link>&#160;*
</entry><entry role="function_name"><link linkend="g-type-interface-prerequisites">g_type_interface_prerequisites</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-set-qdata">g_type_set_qdata</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-get-qdata">g_type_get_qdata</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-query">g_type_query</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><phrase role="c_punctuation">(</phrase><link linkend="GBaseInitFunc">*GBaseInitFunc</link><phrase role="c_punctuation">)</phrase>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><phrase role="c_punctuation">(</phrase><link linkend="GBaseFinalizeFunc">*GBaseFinalizeFunc</link><phrase role="c_punctuation">)</phrase>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><phrase role="c_punctuation">(</phrase><link linkend="GClassInitFunc">*GClassInitFunc</link><phrase role="c_punctuation">)</phrase>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><phrase role="c_punctuation">(</phrase><link linkend="GClassFinalizeFunc">*GClassFinalizeFunc</link><phrase role="c_punctuation">)</phrase>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><phrase role="c_punctuation">(</phrase><link linkend="GInstanceInitFunc">*GInstanceInitFunc</link><phrase role="c_punctuation">)</phrase>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><phrase role="c_punctuation">(</phrase><link linkend="GInterfaceInitFunc">*GInterfaceInitFunc</link><phrase role="c_punctuation">)</phrase>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><phrase role="c_punctuation">(</phrase><link linkend="GInterfaceFinalizeFunc">*GInterfaceFinalizeFunc</link><phrase role="c_punctuation">)</phrase>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="gboolean"><returnvalue>gboolean</returnvalue></link>
</entry><entry role="function_name"><phrase role="c_punctuation">(</phrase><link linkend="GTypeClassCacheFunc">*GTypeClassCacheFunc</link><phrase role="c_punctuation">)</phrase>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GType"><returnvalue>GType</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-register-static">g_type_register_static</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GType"><returnvalue>GType</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-register-static-simple">g_type_register_static_simple</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GType"><returnvalue>GType</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-register-dynamic">g_type_register_dynamic</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GType"><returnvalue>GType</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-register-fundamental">g_type_register_fundamental</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-add-interface-static">g_type_add_interface_static</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-add-interface-dynamic">g_type_add_interface_dynamic</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-interface-add-prerequisite">g_type_interface_add_prerequisite</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GTypePlugin"><returnvalue>GTypePlugin</returnvalue></link>&#160;*
</entry><entry role="function_name"><link linkend="g-type-get-plugin">g_type_get_plugin</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GTypePlugin"><returnvalue>GTypePlugin</returnvalue></link>&#160;*
</entry><entry role="function_name"><link linkend="g-type-interface-get-plugin">g_type_interface_get_plugin</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GType"><returnvalue>GType</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-fundamental-next">g_type_fundamental_next</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GType"><returnvalue>GType</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-fundamental">g_type_fundamental</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GTypeInstance"><returnvalue>GTypeInstance</returnvalue></link>&#160;*
</entry><entry role="function_name"><link linkend="g-type-create-instance">g_type_create_instance</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-free-instance">g_type_free_instance</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-add-class-cache-func">g_type_add_class_cache_func</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-remove-class-cache-func">g_type_remove_class_cache_func</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-class-unref-uncached">g_type_class_unref_uncached</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-add-interface-check">g_type_add_interface_check</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-remove-interface-check">g_type_remove_interface_check</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><phrase role="c_punctuation">(</phrase><link linkend="GTypeInterfaceCheckFunc">*GTypeInterfaceCheckFunc</link><phrase role="c_punctuation">)</phrase>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GTypeValueTable"><returnvalue>GTypeValueTable</returnvalue></link>&#160;*
</entry><entry role="function_name"><link linkend="g-type-value-table-peek">g_type_value_table_peek</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-ensure">g_type_ensure</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="guint"><returnvalue>guint</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-get-type-registration-serial">g_type_get_type_registration_serial</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="int"><returnvalue>int</returnvalue></link>
</entry><entry role="function_name"><link linkend="g-type-get-instance-count">g_type_get_instance_count</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-DECLARE-FINAL-TYPE:CAPS">G_DECLARE_FINAL_TYPE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-DECLARE-DERIVABLE-TYPE:CAPS">G_DECLARE_DERIVABLE_TYPE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-DECLARE-INTERFACE:CAPS">G_DECLARE_INTERFACE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-DEFINE-TYPE:CAPS">G_DEFINE_TYPE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-DEFINE-TYPE-WITH-PRIVATE:CAPS">G_DEFINE_TYPE_WITH_PRIVATE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-DEFINE-TYPE-WITH-CODE:CAPS">G_DEFINE_TYPE_WITH_CODE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-DEFINE-ABSTRACT-TYPE:CAPS">G_DEFINE_ABSTRACT_TYPE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-DEFINE-ABSTRACT-TYPE-WITH-PRIVATE:CAPS">G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-DEFINE-ABSTRACT-TYPE-WITH-CODE:CAPS">G_DEFINE_ABSTRACT_TYPE_WITH_CODE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-ADD-PRIVATE:CAPS">G_ADD_PRIVATE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-PRIVATE-OFFSET:CAPS">G_PRIVATE_OFFSET</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-PRIVATE-FIELD:CAPS">G_PRIVATE_FIELD</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-PRIVATE-FIELD-P:CAPS">G_PRIVATE_FIELD_P</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-DEFINE-INTERFACE:CAPS">G_DEFINE_INTERFACE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-DEFINE-INTERFACE-WITH-CODE:CAPS">G_DEFINE_INTERFACE_WITH_CODE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-IMPLEMENT-INTERFACE:CAPS">G_IMPLEMENT_INTERFACE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-DEFINE-TYPE-EXTENDED:CAPS">G_DEFINE_TYPE_EXTENDED</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-DEFINE-BOXED-TYPE:CAPS">G_DEFINE_BOXED_TYPE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-DEFINE-BOXED-TYPE-WITH-CODE:CAPS">G_DEFINE_BOXED_TYPE_WITH_CODE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-DEFINE-POINTER-TYPE:CAPS">G_DEFINE_POINTER_TYPE</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-DEFINE-POINTER-TYPE-WITH-CODE:CAPS">G_DEFINE_POINTER_TYPE_WITH_CODE</link><phrase role="c_punctuation">()</phrase></entry></row>

</tbody>
</tgroup>
</informaltable>
</refsect1>
<anchor id="GType"/><refsect1 id="gobject-Type-Information.other" role="other_proto">
<title role="other_proto.title">Types and Values</title>
<informaltable role="enum_members_table" pgwide="1" frame="none">
<tgroup cols="2">
<colspec colname="name" colwidth="150px"/>
<colspec colname="description"/>
<tbody>
<row><entry role="typedef_keyword">typedef</entry><entry role="function_name"><link linkend="GType">GType</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-FUNDAMENTAL-MAX:CAPS">G_TYPE_FUNDAMENTAL_MAX</link></entry></row>
<row><entry role="datatype_keyword">struct</entry><entry role="function_name"><link linkend="GTypeInterface">GTypeInterface</link></entry></row>
<row><entry role="datatype_keyword">struct</entry><entry role="function_name"><link linkend="GTypeInstance">GTypeInstance</link></entry></row>
<row><entry role="datatype_keyword">struct</entry><entry role="function_name"><link linkend="GTypeClass">GTypeClass</link></entry></row>
<row><entry role="datatype_keyword">struct</entry><entry role="function_name"><link linkend="GTypeInfo">GTypeInfo</link></entry></row>
<row><entry role="datatype_keyword">struct</entry><entry role="function_name"><link linkend="GTypeFundamentalInfo">GTypeFundamentalInfo</link></entry></row>
<row><entry role="datatype_keyword">struct</entry><entry role="function_name"><link linkend="GInterfaceInfo">GInterfaceInfo</link></entry></row>
<row><entry role="datatype_keyword">struct</entry><entry role="function_name"><link linkend="GTypeValueTable">GTypeValueTable</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-FLAG-RESERVED-ID-BIT:CAPS">G_TYPE_FLAG_RESERVED_ID_BIT</link></entry></row>
<row><entry role="datatype_keyword">enum</entry><entry role="function_name"><link linkend="GTypeDebugFlags">GTypeDebugFlags</link></entry></row>
<row><entry role="datatype_keyword">struct</entry><entry role="function_name"><link linkend="GTypeQuery">GTypeQuery</link></entry></row>
<row><entry role="datatype_keyword">enum</entry><entry role="function_name"><link linkend="GTypeFlags">GTypeFlags</link></entry></row>
<row><entry role="datatype_keyword">enum</entry><entry role="function_name"><link linkend="GTypeFundamentalFlags">GTypeFundamentalFlags</link></entry></row>


<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-INVALID:CAPS">G_TYPE_INVALID</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-NONE:CAPS">G_TYPE_NONE</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-INTERFACE:CAPS">G_TYPE_INTERFACE</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-CHAR:CAPS">G_TYPE_CHAR</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-UCHAR:CAPS">G_TYPE_UCHAR</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-BOOLEAN:CAPS">G_TYPE_BOOLEAN</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-INT:CAPS">G_TYPE_INT</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-UINT:CAPS">G_TYPE_UINT</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-LONG:CAPS">G_TYPE_LONG</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-ULONG:CAPS">G_TYPE_ULONG</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-INT64:CAPS">G_TYPE_INT64</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-UINT64:CAPS">G_TYPE_UINT64</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-ENUM:CAPS">G_TYPE_ENUM</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-FLAGS:CAPS">G_TYPE_FLAGS</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-FLOAT:CAPS">G_TYPE_FLOAT</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-DOUBLE:CAPS">G_TYPE_DOUBLE</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-STRING:CAPS">G_TYPE_STRING</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-POINTER:CAPS">G_TYPE_POINTER</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-BOXED:CAPS">G_TYPE_BOXED</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-PARAM:CAPS">G_TYPE_PARAM</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-OBJECT:CAPS">G_TYPE_OBJECT</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-GTYPE:CAPS">G_TYPE_GTYPE</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-VARIANT:CAPS">G_TYPE_VARIANT</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-CHECKSUM:CAPS">G_TYPE_CHECKSUM</link></entry></row>

<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-RESERVED-GLIB-FIRST:CAPS">G_TYPE_RESERVED_GLIB_FIRST</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-RESERVED-GLIB-LAST:CAPS">G_TYPE_RESERVED_GLIB_LAST</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-RESERVED-BSE-FIRST:CAPS">G_TYPE_RESERVED_BSE_FIRST</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-RESERVED-BSE-LAST:CAPS">G_TYPE_RESERVED_BSE_LAST</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="G-TYPE-RESERVED-USER-FIRST:CAPS">G_TYPE_RESERVED_USER_FIRST</link></entry></row>

</tbody>
</tgroup>
</informaltable>
</refsect1>
<refsect1 id="gobject-Type-Information.object-hierarchy" role="object_hierarchy">
<title role="object_hierarchy.title">Object Hierarchy</title>
<screen>    <link linkend="gpointer">gpointer</link>
    <phrase role="lineart">&#9584;&#9472;&#9472;</phrase> GType
</screen>
</refsect1>

<refsect1 id="gobject-Type-Information.includes"><title>Includes</title><synopsis>#include &lt;glib-object.h&gt;
</synopsis></refsect1>

<refsect1 id="gobject-Type-Information.description" role="desc">
<title role="desc.title">Description</title>
<para>The GType API is the foundation of the GObject system.  It provides the
facilities for registering and managing all fundamental data types,
user-defined object and interface types.</para>
<para>For type creation and registration purposes, all types fall into one of
two categories: static or dynamic.  Static types are never loaded or
unloaded at run-time as dynamic types may be.  Static types are created
with <link linkend="g-type-register-static"><function>g_type_register_static()</function></link> that gets type specific information passed
in via a <link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure.</para>
<para>Dynamic types are created with <link linkend="g-type-register-dynamic"><function>g_type_register_dynamic()</function></link> which takes a
<link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure instead. The remaining type information (the
<link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure) is retrieved during runtime through <link linkend="GTypePlugin"><type>GTypePlugin</type></link>
and the g_type_plugin_*() API.</para>
<para>These registration functions are usually called only once from a
function whose only purpose is to return the type identifier for a
specific class.  Once the type (or class or interface) is registered,
it may be instantiated, inherited, or implemented depending on exactly
what sort of type it is.</para>
<para>There is also a third registration function for registering fundamental
types called <link linkend="g-type-register-fundamental"><function>g_type_register_fundamental()</function></link> which requires both a <link linkend="GTypeInfo"><type>GTypeInfo</type></link>
structure and a <link linkend="GTypeFundamentalInfo"><type>GTypeFundamentalInfo</type></link> structure but it is seldom used
since most fundamental types are predefined rather than user-defined.</para>
<para>Type instance and class structs are limited to a total of 64 KiB,
including all parent types. Similarly, type instances' private data
(as created by <link linkend="G-ADD-PRIVATE:CAPS"><function>G_ADD_PRIVATE()</function></link>) are limited to a total of
64 KiB. If a type instance needs a large static buffer, allocate it
separately (typically by using <link linkend="GArray"><type>GArray</type></link> or <link linkend="GPtrArray"><type>GPtrArray</type></link>) and put a pointer
to the buffer in the structure.</para>
<para>As mentioned in the <link linkend="gtype-conventions">GType conventions</link>, type names must
be at least three characters long. There is no upper length limit. The first
character must be a letter (a–z or A–Z) or an underscore (‘_’). Subsequent
characters can be letters, numbers or any of ‘-_+’.</para>

</refsect1>
<refsect1 id="gobject-Type-Information.functions_details" role="details">
<title role="details.title">Functions</title>
<refsect2 id="G-TYPE-FUNDAMENTAL:CAPS" role="macro">
<title>G_TYPE_FUNDAMENTAL()</title>
<indexterm zone="G-TYPE-FUNDAMENTAL:CAPS"><primary sortas="TYPE_FUNDAMENTAL">G_TYPE_FUNDAMENTAL</primary></indexterm>
<programlisting language="C">#define G_TYPE_FUNDAMENTAL(type)&#160;(g_type_fundamental (type))
</programlisting>
<para>The fundamental type which is the ancestor of <parameter>type</parameter>
.
Fundamental types are types that serve as ultimate bases for the derived types, 
thus they are the roots of distinct inheritance hierarchies.</para>
<refsect3 id="G-TYPE-FUNDAMENTAL.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>A <link linkend="GType"><type>GType</type></link> value.</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="G-TYPE-MAKE-FUNDAMENTAL:CAPS" role="macro">
<title>G_TYPE_MAKE_FUNDAMENTAL()</title>
<indexterm zone="G-TYPE-MAKE-FUNDAMENTAL:CAPS"><primary sortas="TYPE_MAKE_FUNDAMENTAL">G_TYPE_MAKE_FUNDAMENTAL</primary></indexterm>
<programlisting language="C">#define&#160;G_TYPE_MAKE_FUNDAMENTAL(x)&#160;((GType) ((x) &lt;&lt; G_TYPE_FUNDAMENTAL_SHIFT))
</programlisting>
<para>Get the type ID for the fundamental type number <parameter>x</parameter>
.
Use <link linkend="g-type-fundamental-next"><function>g_type_fundamental_next()</function></link> instead of this macro to create new fundamental 
types.</para>
<refsect3 id="G-TYPE-MAKE-FUNDAMENTAL.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>x</para></entry>
<entry role="parameter_description"><para>the fundamental type number.</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-MAKE-FUNDAMENTAL.returns" role="returns">
<title>Returns</title>
<para> the GType</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-IS-ABSTRACT:CAPS" role="macro">
<title>G_TYPE_IS_ABSTRACT()</title>
<indexterm zone="G-TYPE-IS-ABSTRACT:CAPS"><primary sortas="TYPE_IS_ABSTRACT">G_TYPE_IS_ABSTRACT</primary></indexterm>
<programlisting language="C">#define G_TYPE_IS_ABSTRACT(type)                (g_type_test_flags ((type), G_TYPE_FLAG_ABSTRACT))
</programlisting>
<para>Checks if <parameter>type</parameter>
 is an abstract type.  An abstract type cannot be
instantiated and is normally used as an abstract base class for
derived classes.</para>
<refsect3 id="G-TYPE-IS-ABSTRACT.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>A <link linkend="GType"><type>GType</type></link> value</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-IS-ABSTRACT.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-IS-DERIVED:CAPS" role="macro">
<title>G_TYPE_IS_DERIVED()</title>
<indexterm zone="G-TYPE-IS-DERIVED:CAPS"><primary sortas="TYPE_IS_DERIVED">G_TYPE_IS_DERIVED</primary></indexterm>
<programlisting language="C">#define G_TYPE_IS_DERIVED(type)                 ((type) &gt; G_TYPE_FUNDAMENTAL_MAX)
</programlisting>
<para>Checks if <parameter>type</parameter>
 is derived (or in object-oriented terminology:
inherited) from another type (this holds true for all non-fundamental
types).</para>
<refsect3 id="G-TYPE-IS-DERIVED.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>A <link linkend="GType"><type>GType</type></link> value</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-IS-DERIVED.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-IS-FUNDAMENTAL:CAPS" role="macro">
<title>G_TYPE_IS_FUNDAMENTAL()</title>
<indexterm zone="G-TYPE-IS-FUNDAMENTAL:CAPS"><primary sortas="TYPE_IS_FUNDAMENTAL">G_TYPE_IS_FUNDAMENTAL</primary></indexterm>
<programlisting language="C">#define G_TYPE_IS_FUNDAMENTAL(type)             ((type) &lt;= G_TYPE_FUNDAMENTAL_MAX)
</programlisting>
<para>Checks if <parameter>type</parameter>
 is a fundamental type.</para>
<refsect3 id="G-TYPE-IS-FUNDAMENTAL.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>A <link linkend="GType"><type>GType</type></link> value</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-IS-FUNDAMENTAL.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-IS-VALUE-TYPE:CAPS" role="macro">
<title>G_TYPE_IS_VALUE_TYPE()</title>
<indexterm zone="G-TYPE-IS-VALUE-TYPE:CAPS"><primary sortas="TYPE_IS_VALUE_TYPE">G_TYPE_IS_VALUE_TYPE</primary></indexterm>
<programlisting language="C">#define G_TYPE_IS_VALUE_TYPE(type)              (g_type_check_is_value_type (type))
</programlisting>
<para>Checks if <parameter>type</parameter>
 is a value type and can be used with <link linkend="g-value-init"><function>g_value_init()</function></link>.</para>
<refsect3 id="G-TYPE-IS-VALUE-TYPE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>A <link linkend="GType"><type>GType</type></link> value</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-IS-VALUE-TYPE.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-HAS-VALUE-TABLE:CAPS" role="macro">
<title>G_TYPE_HAS_VALUE_TABLE()</title>
<indexterm zone="G-TYPE-HAS-VALUE-TABLE:CAPS"><primary sortas="TYPE_HAS_VALUE_TABLE">G_TYPE_HAS_VALUE_TABLE</primary></indexterm>
<programlisting language="C">#define G_TYPE_HAS_VALUE_TABLE(type)            (g_type_value_table_peek (type) != NULL)
</programlisting>
<para>Checks if <parameter>type</parameter>
 has a <link linkend="GTypeValueTable"><type>GTypeValueTable</type></link>.</para>
<refsect3 id="G-TYPE-HAS-VALUE-TABLE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>A <link linkend="GType"><type>GType</type></link> value</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-HAS-VALUE-TABLE.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-IS-CLASSED:CAPS" role="macro">
<title>G_TYPE_IS_CLASSED()</title>
<indexterm zone="G-TYPE-IS-CLASSED:CAPS"><primary sortas="TYPE_IS_CLASSED">G_TYPE_IS_CLASSED</primary></indexterm>
<programlisting language="C">#define G_TYPE_IS_CLASSED(type)                 (g_type_test_flags ((type), G_TYPE_FLAG_CLASSED))
</programlisting>
<para>Checks if <parameter>type</parameter>
 is a classed type.</para>
<refsect3 id="G-TYPE-IS-CLASSED.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>A <link linkend="GType"><type>GType</type></link> value</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-IS-CLASSED.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-IS-INSTANTIATABLE:CAPS" role="macro">
<title>G_TYPE_IS_INSTANTIATABLE()</title>
<indexterm zone="G-TYPE-IS-INSTANTIATABLE:CAPS"><primary sortas="TYPE_IS_INSTANTIATABLE">G_TYPE_IS_INSTANTIATABLE</primary></indexterm>
<programlisting language="C">#define G_TYPE_IS_INSTANTIATABLE(type)          (g_type_test_flags ((type), G_TYPE_FLAG_INSTANTIATABLE))
</programlisting>
<para>Checks if <parameter>type</parameter>
 can be instantiated.  Instantiation is the
process of creating an instance (object) of this type.</para>
<refsect3 id="G-TYPE-IS-INSTANTIATABLE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>A <link linkend="GType"><type>GType</type></link> value</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-IS-INSTANTIATABLE.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-IS-DERIVABLE:CAPS" role="macro">
<title>G_TYPE_IS_DERIVABLE()</title>
<indexterm zone="G-TYPE-IS-DERIVABLE:CAPS"><primary sortas="TYPE_IS_DERIVABLE">G_TYPE_IS_DERIVABLE</primary></indexterm>
<programlisting language="C">#define G_TYPE_IS_DERIVABLE(type)               (g_type_test_flags ((type), G_TYPE_FLAG_DERIVABLE))
</programlisting>
<para>Checks if <parameter>type</parameter>
 is a derivable type.  A derivable type can
be used as the base class of a flat (single-level) class hierarchy.</para>
<refsect3 id="G-TYPE-IS-DERIVABLE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>A <link linkend="GType"><type>GType</type></link> value</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-IS-DERIVABLE.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-IS-DEEP-DERIVABLE:CAPS" role="macro">
<title>G_TYPE_IS_DEEP_DERIVABLE()</title>
<indexterm zone="G-TYPE-IS-DEEP-DERIVABLE:CAPS"><primary sortas="TYPE_IS_DEEP_DERIVABLE">G_TYPE_IS_DEEP_DERIVABLE</primary></indexterm>
<programlisting language="C">#define G_TYPE_IS_DEEP_DERIVABLE(type)          (g_type_test_flags ((type), G_TYPE_FLAG_DEEP_DERIVABLE))
</programlisting>
<para>Checks if <parameter>type</parameter>
 is a deep derivable type.  A deep derivable type
can be used as the base class of a deep (multi-level) class hierarchy.</para>
<refsect3 id="G-TYPE-IS-DEEP-DERIVABLE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>A <link linkend="GType"><type>GType</type></link> value</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-IS-DEEP-DERIVABLE.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-IS-INTERFACE:CAPS" role="macro">
<title>G_TYPE_IS_INTERFACE()</title>
<indexterm zone="G-TYPE-IS-INTERFACE:CAPS"><primary sortas="TYPE_IS_INTERFACE">G_TYPE_IS_INTERFACE</primary></indexterm>
<programlisting language="C">#define G_TYPE_IS_INTERFACE(type)               (G_TYPE_FUNDAMENTAL (type) == G_TYPE_INTERFACE)
</programlisting>
<para>Checks if <parameter>type</parameter>
 is an interface type.
An interface type provides a pure API, the implementation
of which is provided by another type (which is then said to conform
to the interface).  GLib interfaces are somewhat analogous to Java
interfaces and C++ classes containing only pure virtual functions, 
with the difference that GType interfaces are not derivable (but see
<link linkend="g-type-interface-add-prerequisite"><function>g_type_interface_add_prerequisite()</function></link> for an alternative).</para>
<refsect3 id="G-TYPE-IS-INTERFACE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>A <link linkend="GType"><type>GType</type></link> value</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-IS-INTERFACE.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-FROM-INSTANCE:CAPS" role="macro">
<title>G_TYPE_FROM_INSTANCE()</title>
<indexterm zone="G-TYPE-FROM-INSTANCE:CAPS"><primary sortas="TYPE_FROM_INSTANCE">G_TYPE_FROM_INSTANCE</primary></indexterm>
<programlisting language="C">#define G_TYPE_FROM_INSTANCE(instance)                          (G_TYPE_FROM_CLASS (((GTypeInstance*) (instance))-&gt;g_class))
</programlisting>
<para>Get the type identifier from a given <parameter>instance</parameter>
 structure. </para>
<para>This macro should only be used in type implementations.</para>
<refsect3 id="G-TYPE-FROM-INSTANCE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>instance</para></entry>
<entry role="parameter_description"><para>Location of a valid <link linkend="GTypeInstance"><type>GTypeInstance</type></link> structure</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-FROM-INSTANCE.returns" role="returns">
<title>Returns</title>
<para> the <link linkend="GType"><type>GType</type></link></para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-FROM-CLASS:CAPS" role="macro">
<title>G_TYPE_FROM_CLASS()</title>
<indexterm zone="G-TYPE-FROM-CLASS:CAPS"><primary sortas="TYPE_FROM_CLASS">G_TYPE_FROM_CLASS</primary></indexterm>
<programlisting language="C">#define G_TYPE_FROM_CLASS(g_class)                              (((GTypeClass*) (g_class))-&gt;g_type)
</programlisting>
<para>Get the type identifier from a given <parameter>class</parameter>
 structure.</para>
<para>This macro should only be used in type implementations.</para>
<refsect3 id="G-TYPE-FROM-CLASS.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_class</para></entry>
<entry role="parameter_description"><para>Location of a valid <link linkend="GTypeClass"><type>GTypeClass</type></link> structure</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-FROM-CLASS.returns" role="returns">
<title>Returns</title>
<para> the <link linkend="GType"><type>GType</type></link></para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-FROM-INTERFACE:CAPS" role="macro">
<title>G_TYPE_FROM_INTERFACE()</title>
<indexterm zone="G-TYPE-FROM-INTERFACE:CAPS"><primary sortas="TYPE_FROM_INTERFACE">G_TYPE_FROM_INTERFACE</primary></indexterm>
<programlisting language="C">#define G_TYPE_FROM_INTERFACE(g_iface)                          (((GTypeInterface*) (g_iface))-&gt;g_type)
</programlisting>
<para>Get the type identifier from a given <parameter>interface</parameter>
 structure.</para>
<para>This macro should only be used in type implementations.</para>
<refsect3 id="G-TYPE-FROM-INTERFACE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_iface</para></entry>
<entry role="parameter_description"><para>Location of a valid <link linkend="GTypeInterface"><type>GTypeInterface</type></link> structure</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-FROM-INTERFACE.returns" role="returns">
<title>Returns</title>
<para> the <link linkend="GType"><type>GType</type></link></para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-INSTANCE-GET-CLASS:CAPS" role="macro">
<title>G_TYPE_INSTANCE_GET_CLASS()</title>
<indexterm zone="G-TYPE-INSTANCE-GET-CLASS:CAPS"><primary sortas="TYPE_INSTANCE_GET_CLASS">G_TYPE_INSTANCE_GET_CLASS</primary></indexterm>
<programlisting language="C">#define G_TYPE_INSTANCE_GET_CLASS(instance, g_type, c_type)     (_G_TYPE_IGC ((instance), (g_type), c_type))
</programlisting>
<para>Get the class structure of a given <parameter>instance</parameter>
, casted
to a specified ancestor type <parameter>g_type</parameter>
 of the instance.</para>
<para>Note that while calling a <link linkend="GInstanceInitFunc"><function>GInstanceInitFunc()</function></link>, the class pointer
gets modified, so it might not always return the expected pointer.</para>
<para>This macro should only be used in type implementations.</para>
<refsect3 id="G-TYPE-INSTANCE-GET-CLASS.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>instance</para></entry>
<entry role="parameter_description"><para>Location of the <link linkend="GTypeInstance"><type>GTypeInstance</type></link> structure</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>g_type</para></entry>
<entry role="parameter_description"><para>The <link linkend="GType"><type>GType</type></link> of the class to be returned</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>c_type</para></entry>
<entry role="parameter_description"><para>The C type of the class structure</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-INSTANCE-GET-CLASS.returns" role="returns">
<title>Returns</title>
<para> a pointer to the class structure</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-INSTANCE-GET-INTERFACE:CAPS" role="macro">
<title>G_TYPE_INSTANCE_GET_INTERFACE()</title>
<indexterm zone="G-TYPE-INSTANCE-GET-INTERFACE:CAPS"><primary sortas="TYPE_INSTANCE_GET_INTERFACE">G_TYPE_INSTANCE_GET_INTERFACE</primary></indexterm>
<programlisting language="C">#define G_TYPE_INSTANCE_GET_INTERFACE(instance, g_type, c_type) (_G_TYPE_IGI ((instance), (g_type), c_type))
</programlisting>
<para>Get the interface structure for interface <parameter>g_type</parameter>
 of a given <parameter>instance</parameter>
.</para>
<para>This macro should only be used in type implementations.</para>
<refsect3 id="G-TYPE-INSTANCE-GET-INTERFACE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>instance</para></entry>
<entry role="parameter_description"><para>Location of the <link linkend="GTypeInstance"><type>GTypeInstance</type></link> structure</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>g_type</para></entry>
<entry role="parameter_description"><para>The <link linkend="GType"><type>GType</type></link> of the interface to be returned</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>c_type</para></entry>
<entry role="parameter_description"><para>The C type of the interface structure</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-INSTANCE-GET-INTERFACE.returns" role="returns">
<title>Returns</title>
<para> a pointer to the interface structure</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-INSTANCE-GET-PRIVATE:CAPS" role="macro" condition="deprecated|since:2.4">
<title>G_TYPE_INSTANCE_GET_PRIVATE()</title>
<indexterm zone="G-TYPE-INSTANCE-GET-PRIVATE:CAPS" role="deprecated"><primary sortas="TYPE_INSTANCE_GET_PRIVATE">G_TYPE_INSTANCE_GET_PRIVATE</primary></indexterm><indexterm zone="G-TYPE-INSTANCE-GET-PRIVATE:CAPS" role="2.4"><primary sortas="TYPE_INSTANCE_GET_PRIVATE">G_TYPE_INSTANCE_GET_PRIVATE</primary></indexterm>
<programlisting language="C">#define G_TYPE_INSTANCE_GET_PRIVATE(instance, g_type, c_type)   ((c_type*) g_type_instance_get_private ((GTypeInstance*) (instance), (g_type)))
</programlisting>
<warning><para><literal>G_TYPE_INSTANCE_GET_PRIVATE</literal> has been deprecated since version 2.58 and should not be used in newly-written code.</para> <para>Use <link linkend="G-ADD-PRIVATE:CAPS"><literal>G_ADD_PRIVATE</literal></link> and the generated
  <literal><link linkend="your-type-get-instance-private"><function>your_type_get_instance_private()</function></link></literal> function instead</para>
</warning>
<para>Gets the private structure for a particular type.
The private structure must have been registered in the
class_init function with <link linkend="g-type-class-add-private"><function>g_type_class_add_private()</function></link>.</para>
<para>This macro should only be used in type implementations.</para>
<refsect3 id="G-TYPE-INSTANCE-GET-PRIVATE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>instance</para></entry>
<entry role="parameter_description"><para>the instance of a type deriving from <parameter>private_type</parameter>
</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>g_type</para></entry>
<entry role="parameter_description"><para>the type identifying which private data to retrieve</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>c_type</para></entry>
<entry role="parameter_description"><para>The C type for the private structure</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-INSTANCE-GET-PRIVATE.returns" role="returns">
<title>Returns</title>
<para>a pointer to the private data structure. </para>
<para><emphasis role="annotation">[<acronym>not nullable</acronym>]</emphasis></para>
</refsect3><para role="since">Since: <link linkend="api-index-2.4">2.4</link></para></refsect2>
<refsect2 id="G-TYPE-CLASS-GET-PRIVATE:CAPS" role="macro" condition="since:2.24">
<title>G_TYPE_CLASS_GET_PRIVATE()</title>
<indexterm zone="G-TYPE-CLASS-GET-PRIVATE:CAPS" role="2.24"><primary sortas="TYPE_CLASS_GET_PRIVATE">G_TYPE_CLASS_GET_PRIVATE</primary></indexterm>
<programlisting language="C">#define G_TYPE_CLASS_GET_PRIVATE(klass, g_type, c_type)   ((c_type*) g_type_class_get_private ((GTypeClass*) (klass), (g_type)))
</programlisting>
<para>Gets the private class structure for a particular type.
The private structure must have been registered in the
<link linkend="get-type"><function>get_type()</function></link> function with <link linkend="g-type-add-class-private"><function>g_type_add_class_private()</function></link>.</para>
<para>This macro should only be used in type implementations.</para>
<refsect3 id="G-TYPE-CLASS-GET-PRIVATE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>klass</para></entry>
<entry role="parameter_description"><para>the class of a type deriving from <parameter>private_type</parameter>
</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>g_type</para></entry>
<entry role="parameter_description"><para>the type identifying which private data to retrieve</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>c_type</para></entry>
<entry role="parameter_description"><para>The C type for the private structure</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-CLASS-GET-PRIVATE.returns" role="returns">
<title>Returns</title>
<para>a pointer to the private data structure. </para>
<para><emphasis role="annotation">[<acronym>not nullable</acronym>]</emphasis></para>
</refsect3><para role="since">Since: <link linkend="api-index-2.24">2.24</link></para></refsect2>
<refsect2 id="G-TYPE-CHECK-INSTANCE:CAPS" role="macro">
<title>G_TYPE_CHECK_INSTANCE()</title>
<indexterm zone="G-TYPE-CHECK-INSTANCE:CAPS"><primary sortas="TYPE_CHECK_INSTANCE">G_TYPE_CHECK_INSTANCE</primary></indexterm>
<programlisting language="C">#define G_TYPE_CHECK_INSTANCE(instance)				(_G_TYPE_CHI ((GTypeInstance*) (instance)))
</programlisting>
<para>Checks if <parameter>instance</parameter>
 is a valid <link linkend="GTypeInstance"><type>GTypeInstance</type></link> structure,
otherwise issues a warning and returns <link linkend="FALSE:CAPS"><literal>FALSE</literal></link>. <link linkend="NULL:CAPS"><literal>NULL</literal></link> is not a valid
<link linkend="GTypeInstance"><type>GTypeInstance</type></link>.</para>
<para>This macro should only be used in type implementations.</para>
<refsect3 id="G-TYPE-CHECK-INSTANCE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>instance</para></entry>
<entry role="parameter_description"><para>Location of a <link linkend="GTypeInstance"><type>GTypeInstance</type></link> structure</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-CHECK-INSTANCE.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-CHECK-INSTANCE-CAST:CAPS" role="macro">
<title>G_TYPE_CHECK_INSTANCE_CAST()</title>
<indexterm zone="G-TYPE-CHECK-INSTANCE-CAST:CAPS"><primary sortas="TYPE_CHECK_INSTANCE_CAST">G_TYPE_CHECK_INSTANCE_CAST</primary></indexterm>
<programlisting language="C">#define G_TYPE_CHECK_INSTANCE_CAST(instance, g_type, c_type)    (_G_TYPE_CIC ((instance), (g_type), c_type))
</programlisting>
<para>Checks that <parameter>instance</parameter>
 is an instance of the type identified by <parameter>g_type</parameter>

and issues a warning if this is not the case. Returns <parameter>instance</parameter>
 casted 
to a pointer to <parameter>c_type</parameter>
.</para>
<para>No warning will be issued if <parameter>instance</parameter>
 is <link linkend="NULL:CAPS"><literal>NULL</literal></link>, and <link linkend="NULL:CAPS"><literal>NULL</literal></link> will be returned.</para>
<para>This macro should only be used in type implementations.</para>
<refsect3 id="G-TYPE-CHECK-INSTANCE-CAST.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>instance</para></entry>
<entry role="parameter_description"><para>Location of a <link linkend="GTypeInstance"><type>GTypeInstance</type></link> structure. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>nullable</acronym>]</emphasis></entry></row>
<row><entry role="parameter_name"><para>g_type</para></entry>
<entry role="parameter_description"><para>The type to be returned</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>c_type</para></entry>
<entry role="parameter_description"><para>The corresponding C type of <parameter>g_type</parameter>
</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="G-TYPE-CHECK-INSTANCE-TYPE:CAPS" role="macro">
<title>G_TYPE_CHECK_INSTANCE_TYPE()</title>
<indexterm zone="G-TYPE-CHECK-INSTANCE-TYPE:CAPS"><primary sortas="TYPE_CHECK_INSTANCE_TYPE">G_TYPE_CHECK_INSTANCE_TYPE</primary></indexterm>
<programlisting language="C">#define G_TYPE_CHECK_INSTANCE_TYPE(instance, g_type)            (_G_TYPE_CIT ((instance), (g_type)))
</programlisting>
<para>Checks if <parameter>instance</parameter>
 is an instance of the type identified by <parameter>g_type</parameter>
. If
<parameter>instance</parameter>
 is <link linkend="NULL:CAPS"><literal>NULL</literal></link>, <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> will be returned.</para>
<para>This macro should only be used in type implementations.</para>
<refsect3 id="G-TYPE-CHECK-INSTANCE-TYPE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>instance</para></entry>
<entry role="parameter_description"><para>Location of a <link linkend="GTypeInstance"><type>GTypeInstance</type></link> structure. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>nullable</acronym>]</emphasis></entry></row>
<row><entry role="parameter_name"><para>g_type</para></entry>
<entry role="parameter_description"><para>The type to be checked</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-CHECK-INSTANCE-TYPE.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-CHECK-INSTANCE-FUNDAMENTAL-TYPE:CAPS" role="macro">
<title>G_TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE()</title>
<indexterm zone="G-TYPE-CHECK-INSTANCE-FUNDAMENTAL-TYPE:CAPS"><primary sortas="TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE">G_TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE</primary></indexterm>
<programlisting language="C">#define G_TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE(instance, g_type)            (_G_TYPE_CIFT ((instance), (g_type)))
</programlisting>
<para>Checks if <parameter>instance</parameter>
 is an instance of the fundamental type identified by <parameter>g_type</parameter>
.
If <parameter>instance</parameter>
 is <link linkend="NULL:CAPS"><literal>NULL</literal></link>, <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> will be returned.</para>
<para>This macro should only be used in type implementations.</para>
<refsect3 id="G-TYPE-CHECK-INSTANCE-FUNDAMENTAL-TYPE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>instance</para></entry>
<entry role="parameter_description"><para>Location of a <link linkend="GTypeInstance"><type>GTypeInstance</type></link> structure. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>nullable</acronym>]</emphasis></entry></row>
<row><entry role="parameter_name"><para>g_type</para></entry>
<entry role="parameter_description"><para>The fundamental type to be checked</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-CHECK-INSTANCE-FUNDAMENTAL-TYPE.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-CHECK-CLASS-CAST:CAPS" role="macro">
<title>G_TYPE_CHECK_CLASS_CAST()</title>
<indexterm zone="G-TYPE-CHECK-CLASS-CAST:CAPS"><primary sortas="TYPE_CHECK_CLASS_CAST">G_TYPE_CHECK_CLASS_CAST</primary></indexterm>
<programlisting language="C">#define G_TYPE_CHECK_CLASS_CAST(g_class, g_type, c_type)        (_G_TYPE_CCC ((g_class), (g_type), c_type))
</programlisting>
<para>Checks that <parameter>g_class</parameter>
 is a class structure of the type identified by <parameter>g_type</parameter>

and issues a warning if this is not the case. Returns <parameter>g_class</parameter>
 casted 
to a pointer to <parameter>c_type</parameter>
. <link linkend="NULL:CAPS"><literal>NULL</literal></link> is not a valid class structure.</para>
<para>This macro should only be used in type implementations.</para>
<refsect3 id="G-TYPE-CHECK-CLASS-CAST.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_class</para></entry>
<entry role="parameter_description"><para>Location of a <link linkend="GTypeClass"><type>GTypeClass</type></link> structure</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>g_type</para></entry>
<entry role="parameter_description"><para>The type to be returned</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>c_type</para></entry>
<entry role="parameter_description"><para>The corresponding C type of class structure of <parameter>g_type</parameter>
</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="G-TYPE-CHECK-CLASS-TYPE:CAPS" role="macro">
<title>G_TYPE_CHECK_CLASS_TYPE()</title>
<indexterm zone="G-TYPE-CHECK-CLASS-TYPE:CAPS"><primary sortas="TYPE_CHECK_CLASS_TYPE">G_TYPE_CHECK_CLASS_TYPE</primary></indexterm>
<programlisting language="C">#define G_TYPE_CHECK_CLASS_TYPE(g_class, g_type)                (_G_TYPE_CCT ((g_class), (g_type)))
</programlisting>
<para>Checks if <parameter>g_class</parameter>
 is a class structure of the type identified by 
<parameter>g_type</parameter>
. If <parameter>g_class</parameter>
 is <link linkend="NULL:CAPS"><literal>NULL</literal></link>, <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> will be returned.</para>
<para>This macro should only be used in type implementations.</para>
<refsect3 id="G-TYPE-CHECK-CLASS-TYPE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_class</para></entry>
<entry role="parameter_description"><para>Location of a <link linkend="GTypeClass"><type>GTypeClass</type></link> structure. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>nullable</acronym>]</emphasis></entry></row>
<row><entry role="parameter_name"><para>g_type</para></entry>
<entry role="parameter_description"><para>The type to be checked</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-CHECK-CLASS-TYPE.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-CHECK-VALUE:CAPS" role="macro">
<title>G_TYPE_CHECK_VALUE()</title>
<indexterm zone="G-TYPE-CHECK-VALUE:CAPS"><primary sortas="TYPE_CHECK_VALUE">G_TYPE_CHECK_VALUE</primary></indexterm>
<programlisting language="C">#define G_TYPE_CHECK_VALUE(value)				(_G_TYPE_CHV ((value)))
</programlisting>
<para>Checks if <parameter>value</parameter>
 has been initialized to hold values
of a value type.</para>
<para>This macro should only be used in type implementations.</para>
<refsect3 id="G-TYPE-CHECK-VALUE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>value</para></entry>
<entry role="parameter_description"><para>a <link linkend="GValue"><type>GValue</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-CHECK-VALUE.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success</para>
</refsect3></refsect2>
<refsect2 id="G-TYPE-CHECK-VALUE-TYPE:CAPS" role="macro">
<title>G_TYPE_CHECK_VALUE_TYPE()</title>
<indexterm zone="G-TYPE-CHECK-VALUE-TYPE:CAPS"><primary sortas="TYPE_CHECK_VALUE_TYPE">G_TYPE_CHECK_VALUE_TYPE</primary></indexterm>
<programlisting language="C">#define G_TYPE_CHECK_VALUE_TYPE(value, g_type)			(_G_TYPE_CVH ((value), (g_type)))
</programlisting>
<para>Checks if <parameter>value</parameter>
 has been initialized to hold values
of type <parameter>g_type</parameter>
. </para>
<para>This macro should only be used in type implementations.</para>
<refsect3 id="G-TYPE-CHECK-VALUE-TYPE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>value</para></entry>
<entry role="parameter_description"><para>a <link linkend="GValue"><type>GValue</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>g_type</para></entry>
<entry role="parameter_description"><para>The type to be checked</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="G-TYPE-CHECK-VALUE-TYPE.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success</para>
</refsect3></refsect2>
<refsect2 id="g-type-init" role="function" condition="deprecated:2.36: the type system is now initialised automatically">
<title>g_type_init&#160;()</title>
<indexterm zone="g-type-init" role="deprecated"><primary sortas="type_init">g_type_init</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_init (<parameter><type>void</type></parameter>);</programlisting>
<warning><para><literal>g_type_init</literal> has been deprecated since version 2.36 and should not be used in newly-written code.</para> <para>the type system is now initialised automatically</para>
</warning>
<para>This function used to initialise the type system.  Since GLib 2.36,
the type system is initialised automatically and this function does
nothing.</para>
</refsect2>
<refsect2 id="g-type-init-with-debug-flags" role="function" condition="deprecated:2.36: the type system is now initialised automatically">
<title>g_type_init_with_debug_flags&#160;()</title>
<indexterm zone="g-type-init-with-debug-flags" role="deprecated"><primary sortas="type_init_with_debug_flags">g_type_init_with_debug_flags</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_init_with_debug_flags (<parameter><link linkend="GTypeDebugFlags"><type>GTypeDebugFlags</type></link> debug_flags</parameter>);</programlisting>
<warning><para><literal>g_type_init_with_debug_flags</literal> has been deprecated since version 2.36 and should not be used in newly-written code.</para> <para>the type system is now initialised automatically</para>
</warning>
<para>This function used to initialise the type system with debugging
flags.  Since GLib 2.36, the type system is initialised automatically
and this function does nothing.</para>
<para>If you need to enable debugging features, use the GOBJECT_DEBUG
environment variable.</para>
<refsect3 id="g-type-init-with-debug-flags.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>debug_flags</para></entry>
<entry role="parameter_description"><para>bitwise combination of <link linkend="GTypeDebugFlags"><type>GTypeDebugFlags</type></link> values for
debugging purposes</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="g-type-name" role="function">
<title>g_type_name&#160;()</title>
<indexterm zone="g-type-name"><primary sortas="type_name">g_type_name</primary></indexterm>
<programlisting language="C">const <link linkend="gchar"><returnvalue>gchar</returnvalue></link>&#160;*
g_type_name (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>);</programlisting>
<para>Get the unique name that is assigned to a type ID.  Note that this
function (like all other GType API) cannot cope with invalid type
IDs. <link linkend="G-TYPE-INVALID:CAPS"><literal>G_TYPE_INVALID</literal></link> may be passed to this function, as may be any
other validly registered type ID, but randomized type IDs should
not be passed in and will most likely lead to a crash.</para>
<refsect3 id="g-type-name.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>type to return name for</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-name.returns" role="returns">
<title>Returns</title>
<para> static type name or <link linkend="NULL:CAPS"><literal>NULL</literal></link></para>
</refsect3></refsect2>
<refsect2 id="g-type-qname" role="function">
<title>g_type_qname&#160;()</title>
<indexterm zone="g-type-qname"><primary sortas="type_qname">g_type_qname</primary></indexterm>
<programlisting language="C"><link linkend="GQuark"><returnvalue>GQuark</returnvalue></link>
g_type_qname (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>);</programlisting>
<para>Get the corresponding quark of the type IDs name.</para>
<refsect3 id="g-type-qname.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>type to return quark of type name for</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-qname.returns" role="returns">
<title>Returns</title>
<para> the type names quark or 0</para>
</refsect3></refsect2>
<refsect2 id="g-type-from-name" role="function">
<title>g_type_from_name&#160;()</title>
<indexterm zone="g-type-from-name"><primary sortas="type_from_name">g_type_from_name</primary></indexterm>
<programlisting language="C"><link linkend="GType"><returnvalue>GType</returnvalue></link>
g_type_from_name (<parameter>const <link linkend="gchar"><type>gchar</type></link> *name</parameter>);</programlisting>
<para>Lookup the type ID from a given type name, returning 0 if no type
has been registered under this name (this is the preferred method
to find out by name whether a specific type has been registered
yet).</para>
<refsect3 id="g-type-from-name.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>name</para></entry>
<entry role="parameter_description"><para>type name to lookup</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-from-name.returns" role="returns">
<title>Returns</title>
<para> corresponding type ID or 0</para>
</refsect3></refsect2>
<refsect2 id="g-type-parent" role="function">
<title>g_type_parent&#160;()</title>
<indexterm zone="g-type-parent"><primary sortas="type_parent">g_type_parent</primary></indexterm>
<programlisting language="C"><link linkend="GType"><returnvalue>GType</returnvalue></link>
g_type_parent (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>);</programlisting>
<para>Return the direct parent type of the passed in type. If the passed
in type has no parent, i.e. is a fundamental type, 0 is returned.</para>
<refsect3 id="g-type-parent.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>the derived type</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-parent.returns" role="returns">
<title>Returns</title>
<para> the parent type</para>
</refsect3></refsect2>
<refsect2 id="g-type-depth" role="function">
<title>g_type_depth&#160;()</title>
<indexterm zone="g-type-depth"><primary sortas="type_depth">g_type_depth</primary></indexterm>
<programlisting language="C"><link linkend="guint"><returnvalue>guint</returnvalue></link>
g_type_depth (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>);</programlisting>
<para>Returns the length of the ancestry of the passed in type. This
includes the type itself, so that e.g. a fundamental type has depth 1.</para>
<refsect3 id="g-type-depth.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>a <link linkend="GType"><type>GType</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-depth.returns" role="returns">
<title>Returns</title>
<para> the depth of <parameter>type</parameter>
</para>
</refsect3></refsect2>
<refsect2 id="g-type-next-base" role="function">
<title>g_type_next_base&#160;()</title>
<indexterm zone="g-type-next-base"><primary sortas="type_next_base">g_type_next_base</primary></indexterm>
<programlisting language="C"><link linkend="GType"><returnvalue>GType</returnvalue></link>
g_type_next_base (<parameter><link linkend="GType"><type>GType</type></link> leaf_type</parameter>,
                  <parameter><link linkend="GType"><type>GType</type></link> root_type</parameter>);</programlisting>
<para>Given a <parameter>leaf_type</parameter>
 and a <parameter>root_type</parameter>
 which is contained in its
anchestry, return the type that <parameter>root_type</parameter>
 is the immediate parent
of. In other words, this function determines the type that is
derived directly from <parameter>root_type</parameter>
 which is also a base class of
<parameter>leaf_type</parameter>
.  Given a root type and a leaf type, this function can
be used to determine the types and order in which the leaf type is
descended from the root type.</para>
<refsect3 id="g-type-next-base.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>leaf_type</para></entry>
<entry role="parameter_description"><para>descendant of <parameter>root_type</parameter>
and the type to be returned</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>root_type</para></entry>
<entry role="parameter_description"><para>immediate parent of the returned type</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-next-base.returns" role="returns">
<title>Returns</title>
<para> immediate child of <parameter>root_type</parameter>
and anchestor of <parameter>leaf_type</parameter>
</para>
</refsect3></refsect2>
<refsect2 id="g-type-is-a" role="function">
<title>g_type_is_a&#160;()</title>
<indexterm zone="g-type-is-a"><primary sortas="type_is_a">g_type_is_a</primary></indexterm>
<programlisting language="C"><link linkend="gboolean"><returnvalue>gboolean</returnvalue></link>
g_type_is_a (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>,
             <parameter><link linkend="GType"><type>GType</type></link> is_a_type</parameter>);</programlisting>
<para>If <parameter>is_a_type</parameter>
 is a derivable type, check whether <parameter>type</parameter>
 is a
descendant of <parameter>is_a_type</parameter>
. If <parameter>is_a_type</parameter>
 is an interface, check
whether <parameter>type</parameter>
 conforms to it.</para>
<refsect3 id="g-type-is-a.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>type to check anchestry for</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>is_a_type</para></entry>
<entry role="parameter_description"><para>possible anchestor of <parameter>type</parameter>
or interface that <parameter>type</parameter>
could conform to</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-is-a.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if <parameter>type</parameter>
is a <parameter>is_a_type</parameter>
</para>
</refsect3></refsect2>
<refsect2 id="g-type-class-ref" role="function">
<title>g_type_class_ref&#160;()</title>
<indexterm zone="g-type-class-ref"><primary sortas="type_class_ref">g_type_class_ref</primary></indexterm>
<programlisting language="C"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
g_type_class_ref (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>);</programlisting>
<para>Increments the reference count of the class structure belonging to
<parameter>type</parameter>
. This function will demand-create the class if it doesn't
exist already.</para>
<refsect3 id="g-type-class-ref.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>type ID of a classed type</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-class-ref.returns" role="returns">
<title>Returns</title>
<para>the <link linkend="GTypeClass"><type>GTypeClass</type></link>
structure for the given type ID. </para>
<para><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeClass][<acronym>transfer none</acronym>]</emphasis></para>
</refsect3></refsect2>
<refsect2 id="g-type-class-peek" role="function">
<title>g_type_class_peek&#160;()</title>
<indexterm zone="g-type-class-peek"><primary sortas="type_class_peek">g_type_class_peek</primary></indexterm>
<programlisting language="C"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
g_type_class_peek (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>);</programlisting>
<para>This function is essentially the same as <link linkend="g-type-class-ref"><function>g_type_class_ref()</function></link>,
except that the classes reference count isn't incremented.
As a consequence, this function may return <link linkend="NULL:CAPS"><literal>NULL</literal></link> if the class
of the type passed in does not currently exist (hasn't been
referenced before).</para>
<refsect3 id="g-type-class-peek.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>type ID of a classed type</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-class-peek.returns" role="returns">
<title>Returns</title>
<para>the <link linkend="GTypeClass"><type>GTypeClass</type></link>
structure for the given type ID or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if the class does not
currently exist. </para>
<para><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeClass][<acronym>transfer none</acronym>]</emphasis></para>
</refsect3></refsect2>
<refsect2 id="g-type-class-peek-static" role="function" condition="since:2.4">
<title>g_type_class_peek_static&#160;()</title>
<indexterm zone="g-type-class-peek-static" role="2.4"><primary sortas="type_class_peek_static">g_type_class_peek_static</primary></indexterm>
<programlisting language="C"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
g_type_class_peek_static (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>);</programlisting>
<para>A more efficient version of <link linkend="g-type-class-peek"><function>g_type_class_peek()</function></link> which works only for
static types.</para>
<refsect3 id="g-type-class-peek-static.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>type ID of a classed type</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-class-peek-static.returns" role="returns">
<title>Returns</title>
<para>the <link linkend="GTypeClass"><type>GTypeClass</type></link>
structure for the given type ID or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if the class does not
currently exist or is dynamically loaded. </para>
<para><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeClass][<acronym>transfer none</acronym>]</emphasis></para>
</refsect3><para role="since">Since: <link linkend="api-index-2.4">2.4</link></para></refsect2>
<refsect2 id="g-type-class-unref" role="function">
<title>g_type_class_unref&#160;()</title>
<indexterm zone="g-type-class-unref"><primary sortas="type_class_unref">g_type_class_unref</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_class_unref (<parameter><link linkend="gpointer"><type>gpointer</type></link> g_class</parameter>);</programlisting>
<para>Decrements the reference count of the class structure being passed in.
Once the last reference count of a class has been released, classes
may be finalized by the type system, so further dereferencing of a
class pointer after <link linkend="g-type-class-unref"><function>g_type_class_unref()</function></link> are invalid.</para>
<refsect3 id="g-type-class-unref.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_class</para></entry>
<entry role="parameter_description"><para>a <link linkend="GTypeClass"><type>GTypeClass</type></link> structure to unref. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeClass]</emphasis></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="g-type-class-peek-parent" role="function">
<title>g_type_class_peek_parent&#160;()</title>
<indexterm zone="g-type-class-peek-parent"><primary sortas="type_class_peek_parent">g_type_class_peek_parent</primary></indexterm>
<programlisting language="C"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
g_type_class_peek_parent (<parameter><link linkend="gpointer"><type>gpointer</type></link> g_class</parameter>);</programlisting>
<para>This is a convenience function often needed in class initializers.
It returns the class structure of the immediate parent type of the
class passed in.  Since derived classes hold a reference count on
their parent classes as long as they are instantiated, the returned
class will always exist.</para>
<para>This function is essentially equivalent to:
g_type_class_peek (g_type_parent (G_TYPE_FROM_CLASS (g_class)))</para>
<refsect3 id="g-type-class-peek-parent.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_class</para></entry>
<entry role="parameter_description"><para>the <link linkend="GTypeClass"><type>GTypeClass</type></link> structure to
retrieve the parent class for. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeClass]</emphasis></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-class-peek-parent.returns" role="returns">
<title>Returns</title>
<para>the parent class
of <parameter>g_class</parameter>
. </para>
<para><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeClass][<acronym>transfer none</acronym>]</emphasis></para>
</refsect3></refsect2>
<refsect2 id="g-type-class-add-private" role="function" condition="deprecated|since:2.4">
<title>g_type_class_add_private&#160;()</title>
<indexterm zone="g-type-class-add-private" role="deprecated"><primary sortas="type_class_add_private">g_type_class_add_private</primary></indexterm><indexterm zone="g-type-class-add-private" role="2.4"><primary sortas="type_class_add_private">g_type_class_add_private</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_class_add_private (<parameter><link linkend="gpointer"><type>gpointer</type></link> g_class</parameter>,
                          <parameter><link linkend="gsize"><type>gsize</type></link> private_size</parameter>);</programlisting>
<warning><para><literal>g_type_class_add_private</literal> has been deprecated since version 2.58 and should not be used in newly-written code.</para> <para>Use the <link linkend="G-ADD-PRIVATE:CAPS"><function>G_ADD_PRIVATE()</function></link> macro with the <literal>G_DEFINE_*</literal>
  family of macros to add instance private data to a type</para>
</warning>
<para>Registers a private structure for an instantiatable type.</para>
<para>When an object is allocated, the private structures for
the type and all of its parent types are allocated
sequentially in the same memory block as the public
structures, and are zero-filled.</para>
<para>Note that the accumulated size of the private structures of
a type and all its parent types cannot exceed 64 KiB.</para>
<para>This function should be called in the type's <link linkend="class-init"><function>class_init()</function></link> function.
The private structure can be retrieved using the
<link linkend="G-TYPE-INSTANCE-GET-PRIVATE:CAPS"><function>G_TYPE_INSTANCE_GET_PRIVATE()</function></link> macro.</para>
<para>The following example shows attaching a private structure
MyObjectPrivate to an object MyObject defined in the standard
GObject fashion in the type's <link linkend="class-init"><function>class_init()</function></link> function.</para>
<para>Note the use of a structure member "priv" to avoid the overhead
of repeatedly calling <link linkend="MY-OBJECT-GET-PRIVATE:CAPS"><function>MY_OBJECT_GET_PRIVATE()</function></link>.</para>
<informalexample><programlisting role="example"><![CDATA[
typedef struct _MyObject        MyObject;
typedef struct _MyObjectPrivate MyObjectPrivate;

struct _MyObject {
 GObject parent;

 MyObjectPrivate *priv;
};

struct _MyObjectPrivate {
  int some_field;
};

static void
my_object_class_init (MyObjectClass *klass)
{
  g_type_class_add_private (klass, sizeof (MyObjectPrivate));
}

static void
my_object_init (MyObject *my_object)
{
  my_object->priv = G_TYPE_INSTANCE_GET_PRIVATE (my_object,
                                                 MY_TYPE_OBJECT,
                                                 MyObjectPrivate);
  // my_object->priv->some_field will be automatically initialised to 0
}

static int
my_object_get_some_field (MyObject *my_object)
{
  MyObjectPrivate *priv;

  g_return_val_if_fail (MY_IS_OBJECT (my_object), 0);

  priv = my_object->priv;

  return priv->some_field;
}
]]></programlisting></informalexample>
<para></para>
<refsect3 id="g-type-class-add-private.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_class</para></entry>
<entry role="parameter_description"><para>class structure for an instantiatable
type. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeClass]</emphasis></entry></row>
<row><entry role="parameter_name"><para>private_size</para></entry>
<entry role="parameter_description"><para>size of private structure</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.4">2.4</link></para></refsect2>
<refsect2 id="g-type-add-class-private" role="function" condition="since:2.24">
<title>g_type_add_class_private&#160;()</title>
<indexterm zone="g-type-add-class-private" role="2.24"><primary sortas="type_add_class_private">g_type_add_class_private</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_add_class_private (<parameter><link linkend="GType"><type>GType</type></link> class_type</parameter>,
                          <parameter><link linkend="gsize"><type>gsize</type></link> private_size</parameter>);</programlisting>
<para>Registers a private class structure for a classed type;
when the class is allocated, the private structures for
the class and all of its parent types are allocated
sequentially in the same memory block as the public
structures, and are zero-filled.</para>
<para>This function should be called in the
type's <link linkend="get-type"><function>get_type()</function></link> function after the type is registered.
The private structure can be retrieved using the
<link linkend="G-TYPE-CLASS-GET-PRIVATE:CAPS"><function>G_TYPE_CLASS_GET_PRIVATE()</function></link> macro.</para>
<refsect3 id="g-type-add-class-private.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>class_type</para></entry>
<entry role="parameter_description"><para>GType of an classed type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>private_size</para></entry>
<entry role="parameter_description"><para>size of private structure</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.24">2.24</link></para></refsect2>
<refsect2 id="g-type-interface-peek" role="function">
<title>g_type_interface_peek&#160;()</title>
<indexterm zone="g-type-interface-peek"><primary sortas="type_interface_peek">g_type_interface_peek</primary></indexterm>
<programlisting language="C"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
g_type_interface_peek (<parameter><link linkend="gpointer"><type>gpointer</type></link> instance_class</parameter>,
                       <parameter><link linkend="GType"><type>GType</type></link> iface_type</parameter>);</programlisting>
<para>Returns the <link linkend="GTypeInterface"><type>GTypeInterface</type></link> structure of an interface to which the
passed in class conforms.</para>
<refsect3 id="g-type-interface-peek.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>instance_class</para></entry>
<entry role="parameter_description"><para>a <link linkend="GTypeClass"><type>GTypeClass</type></link> structure. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeClass]</emphasis></entry></row>
<row><entry role="parameter_name"><para>iface_type</para></entry>
<entry role="parameter_description"><para>an interface ID which this class conforms to</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-interface-peek.returns" role="returns">
<title>Returns</title>
<para>the <link linkend="GTypeInterface"><type>GTypeInterface</type></link>
structure of <parameter>iface_type</parameter>
if implemented by <parameter>instance_class</parameter>
, <link linkend="NULL:CAPS"><literal>NULL</literal></link>
otherwise. </para>
<para><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeInterface][<acronym>transfer none</acronym>]</emphasis></para>
</refsect3></refsect2>
<refsect2 id="g-type-interface-peek-parent" role="function">
<title>g_type_interface_peek_parent&#160;()</title>
<indexterm zone="g-type-interface-peek-parent"><primary sortas="type_interface_peek_parent">g_type_interface_peek_parent</primary></indexterm>
<programlisting language="C"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
g_type_interface_peek_parent (<parameter><link linkend="gpointer"><type>gpointer</type></link> g_iface</parameter>);</programlisting>
<para>Returns the corresponding <link linkend="GTypeInterface"><type>GTypeInterface</type></link> structure of the parent type
of the instance type to which <parameter>g_iface</parameter>
 belongs. This is useful when
deriving the implementation of an interface from the parent type and
then possibly overriding some methods.</para>
<refsect3 id="g-type-interface-peek-parent.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_iface</para></entry>
<entry role="parameter_description"><para>a <link linkend="GTypeInterface"><type>GTypeInterface</type></link> structure. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeInterface]</emphasis></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-interface-peek-parent.returns" role="returns">
<title>Returns</title>
<para>the
corresponding <link linkend="GTypeInterface"><type>GTypeInterface</type></link> structure of the parent type of the
instance type to which <parameter>g_iface</parameter>
belongs, or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if the parent
type doesn't conform to the interface. </para>
<para><emphasis role="annotation">[<acronym>transfer none</acronym>][<acronym>type</acronym> GObject.TypeInterface]</emphasis></para>
</refsect3></refsect2>
<refsect2 id="g-type-default-interface-ref" role="function" condition="since:2.4">
<title>g_type_default_interface_ref&#160;()</title>
<indexterm zone="g-type-default-interface-ref" role="2.4"><primary sortas="type_default_interface_ref">g_type_default_interface_ref</primary></indexterm>
<programlisting language="C"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
g_type_default_interface_ref (<parameter><link linkend="GType"><type>GType</type></link> g_type</parameter>);</programlisting>
<para>Increments the reference count for the interface type <parameter>g_type</parameter>
,
and returns the default interface vtable for the type.</para>
<para>If the type is not currently in use, then the default vtable
for the type will be created and initalized by calling
the base interface init and default vtable init functions for
the type (the <parameter>base_init</parameter>
 and <parameter>class_init</parameter>
 members of <link linkend="GTypeInfo"><type>GTypeInfo</type></link>).
Calling <link linkend="g-type-default-interface-ref"><function>g_type_default_interface_ref()</function></link> is useful when you
want to make sure that signals and properties for an interface
have been installed.</para>
<refsect3 id="g-type-default-interface-ref.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_type</para></entry>
<entry role="parameter_description"><para>an interface type</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-default-interface-ref.returns" role="returns">
<title>Returns</title>
<para>the default
vtable for the interface; call <link linkend="g-type-default-interface-unref"><function>g_type_default_interface_unref()</function></link>
when you are done using the interface. </para>
<para><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeInterface][<acronym>transfer none</acronym>]</emphasis></para>
</refsect3><para role="since">Since: <link linkend="api-index-2.4">2.4</link></para></refsect2>
<refsect2 id="g-type-default-interface-peek" role="function" condition="since:2.4">
<title>g_type_default_interface_peek&#160;()</title>
<indexterm zone="g-type-default-interface-peek" role="2.4"><primary sortas="type_default_interface_peek">g_type_default_interface_peek</primary></indexterm>
<programlisting language="C"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
g_type_default_interface_peek (<parameter><link linkend="GType"><type>GType</type></link> g_type</parameter>);</programlisting>
<para>If the interface type <parameter>g_type</parameter>
 is currently in use, returns its
default interface vtable.</para>
<refsect3 id="g-type-default-interface-peek.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_type</para></entry>
<entry role="parameter_description"><para>an interface type</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-default-interface-peek.returns" role="returns">
<title>Returns</title>
<para>the default
vtable for the interface, or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if the type is not currently
in use. </para>
<para><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeInterface][<acronym>transfer none</acronym>]</emphasis></para>
</refsect3><para role="since">Since: <link linkend="api-index-2.4">2.4</link></para></refsect2>
<refsect2 id="g-type-default-interface-unref" role="function" condition="since:2.4">
<title>g_type_default_interface_unref&#160;()</title>
<indexterm zone="g-type-default-interface-unref" role="2.4"><primary sortas="type_default_interface_unref">g_type_default_interface_unref</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_default_interface_unref (<parameter><link linkend="gpointer"><type>gpointer</type></link> g_iface</parameter>);</programlisting>
<para>Decrements the reference count for the type corresponding to the
interface default vtable <parameter>g_iface</parameter>
. If the type is dynamic, then
when no one is using the interface and all references have
been released, the finalize function for the interface's default
vtable (the <parameter>class_finalize</parameter>
 member of <link linkend="GTypeInfo"><type>GTypeInfo</type></link>) will be called.</para>
<refsect3 id="g-type-default-interface-unref.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_iface</para></entry>
<entry role="parameter_description"><para>the default vtable
structure for a interface, as returned by <link linkend="g-type-default-interface-ref"><function>g_type_default_interface_ref()</function></link>. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeInterface]</emphasis></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.4">2.4</link></para></refsect2>
<refsect2 id="g-type-children" role="function">
<title>g_type_children&#160;()</title>
<indexterm zone="g-type-children"><primary sortas="type_children">g_type_children</primary></indexterm>
<programlisting language="C"><link linkend="GType"><returnvalue>GType</returnvalue></link>&#160;*
g_type_children (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>,
                 <parameter><link linkend="guint"><type>guint</type></link> *n_children</parameter>);</programlisting>
<para>Return a newly allocated and 0-terminated array of type IDs, listing
the child types of <parameter>type</parameter>
.</para>
<refsect3 id="g-type-children.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>the parent type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>n_children</para></entry>
<entry role="parameter_description"><para>location to store the length of
the returned array, or <link linkend="NULL:CAPS"><literal>NULL</literal></link>. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>out</acronym>][<acronym>optional</acronym>]</emphasis></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-children.returns" role="returns">
<title>Returns</title>
<para>Newly allocated
and 0-terminated array of child types, free with <link linkend="g-free"><function>g_free()</function></link>. </para>
<para><emphasis role="annotation">[<acronym>array</acronym> length=n_children][<acronym>transfer full</acronym>]</emphasis></para>
</refsect3></refsect2>
<refsect2 id="g-type-interfaces" role="function">
<title>g_type_interfaces&#160;()</title>
<indexterm zone="g-type-interfaces"><primary sortas="type_interfaces">g_type_interfaces</primary></indexterm>
<programlisting language="C"><link linkend="GType"><returnvalue>GType</returnvalue></link>&#160;*
g_type_interfaces (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>,
                   <parameter><link linkend="guint"><type>guint</type></link> *n_interfaces</parameter>);</programlisting>
<para>Return a newly allocated and 0-terminated array of type IDs, listing
the interface types that <parameter>type</parameter>
 conforms to.</para>
<refsect3 id="g-type-interfaces.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>the type to list interface types for</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>n_interfaces</para></entry>
<entry role="parameter_description"><para>location to store the length of
the returned array, or <link linkend="NULL:CAPS"><literal>NULL</literal></link>. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>out</acronym>][<acronym>optional</acronym>]</emphasis></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-interfaces.returns" role="returns">
<title>Returns</title>
<para>Newly allocated
and 0-terminated array of interface types, free with <link linkend="g-free"><function>g_free()</function></link>. </para>
<para><emphasis role="annotation">[<acronym>array</acronym> length=n_interfaces][<acronym>transfer full</acronym>]</emphasis></para>
</refsect3></refsect2>
<refsect2 id="g-type-interface-prerequisites" role="function" condition="since:2.2">
<title>g_type_interface_prerequisites&#160;()</title>
<indexterm zone="g-type-interface-prerequisites" role="2.2"><primary sortas="type_interface_prerequisites">g_type_interface_prerequisites</primary></indexterm>
<programlisting language="C"><link linkend="GType"><returnvalue>GType</returnvalue></link>&#160;*
g_type_interface_prerequisites (<parameter><link linkend="GType"><type>GType</type></link> interface_type</parameter>,
                                <parameter><link linkend="guint"><type>guint</type></link> *n_prerequisites</parameter>);</programlisting>
<para>Returns the prerequisites of an interfaces type.</para>
<refsect3 id="g-type-interface-prerequisites.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>interface_type</para></entry>
<entry role="parameter_description"><para>an interface type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>n_prerequisites</para></entry>
<entry role="parameter_description"><para>location to return the number
of prerequisites, or <link linkend="NULL:CAPS"><literal>NULL</literal></link>. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>out</acronym>][<acronym>optional</acronym>]</emphasis></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-interface-prerequisites.returns" role="returns">
<title>Returns</title>
<para>a
newly-allocated zero-terminated array of <link linkend="GType"><type>GType</type></link> containing
the prerequisites of <parameter>interface_type</parameter>
. </para>
<para><emphasis role="annotation">[<acronym>array</acronym> length=n_prerequisites][<acronym>transfer full</acronym>]</emphasis></para>
</refsect3><para role="since">Since: <link linkend="api-index-2.2">2.2</link></para></refsect2>
<refsect2 id="g-type-set-qdata" role="function">
<title>g_type_set_qdata&#160;()</title>
<indexterm zone="g-type-set-qdata"><primary sortas="type_set_qdata">g_type_set_qdata</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_set_qdata (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>,
                  <parameter><link linkend="GQuark"><type>GQuark</type></link> quark</parameter>,
                  <parameter><link linkend="gpointer"><type>gpointer</type></link> data</parameter>);</programlisting>
<para>Attaches arbitrary data to a type.</para>
<refsect3 id="g-type-set-qdata.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>a <link linkend="GType"><type>GType</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>quark</para></entry>
<entry role="parameter_description"><para>a <link linkend="GQuark"><type>GQuark</type></link> id to identify the data</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>data</para></entry>
<entry role="parameter_description"><para>the data</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="g-type-get-qdata" role="function">
<title>g_type_get_qdata&#160;()</title>
<indexterm zone="g-type-get-qdata"><primary sortas="type_get_qdata">g_type_get_qdata</primary></indexterm>
<programlisting language="C"><link linkend="gpointer"><returnvalue>gpointer</returnvalue></link>
g_type_get_qdata (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>,
                  <parameter><link linkend="GQuark"><type>GQuark</type></link> quark</parameter>);</programlisting>
<para>Obtains data which has previously been attached to <parameter>type</parameter>

with <link linkend="g-type-set-qdata"><function>g_type_set_qdata()</function></link>.</para>
<para>Note that this does not take subtyping into account; data
attached to one type with <link linkend="g-type-set-qdata"><function>g_type_set_qdata()</function></link> cannot
be retrieved from a subtype using <link linkend="g-type-get-qdata"><function>g_type_get_qdata()</function></link>.</para>
<refsect3 id="g-type-get-qdata.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>a <link linkend="GType"><type>GType</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>quark</para></entry>
<entry role="parameter_description"><para>a <link linkend="GQuark"><type>GQuark</type></link> id to identify the data</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-get-qdata.returns" role="returns">
<title>Returns</title>
<para>the data, or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if no data was found. </para>
<para><emphasis role="annotation">[<acronym>transfer none</acronym>]</emphasis></para>
</refsect3></refsect2>
<refsect2 id="g-type-query" role="function">
<title>g_type_query&#160;()</title>
<indexterm zone="g-type-query"><primary sortas="type_query">g_type_query</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_query (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>,
              <parameter><link linkend="GTypeQuery"><type>GTypeQuery</type></link> *query</parameter>);</programlisting>
<para>Queries the type system for information about a specific type.
This function will fill in a user-provided structure to hold
type-specific information. If an invalid <link linkend="GType"><type>GType</type></link> is passed in, the
<parameter>type</parameter>
 member of the <link linkend="GTypeQuery"><type>GTypeQuery</type></link> is 0. All members filled into the
<link linkend="GTypeQuery"><type>GTypeQuery</type></link> structure should be considered constant and have to be
left untouched.</para>
<refsect3 id="g-type-query.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para><link linkend="GType"><type>GType</type></link> of a static, classed type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>query</para></entry>
<entry role="parameter_description"><para>a user provided structure that is
filled in with constant values upon success. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>out caller-allocates</acronym>]</emphasis></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="GBaseInitFunc" role="function">
<title>GBaseInitFunc&#160;()</title>
<indexterm zone="GBaseInitFunc"><primary sortas="BaseInitFunc">GBaseInitFunc</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
<phrase role="c_punctuation">(</phrase>*GBaseInitFunc<phrase role="c_punctuation">)</phrase> (<parameter><link linkend="gpointer"><type>gpointer</type></link> g_class</parameter>);</programlisting>
<para>A callback function used by the type system to do base initialization
of the class structures of derived types. It is called as part of the
initialization process of all derived classes and should reallocate
or reset all dynamic class members copied over from the parent class.
For example, class members (such as strings) that are not sufficiently
handled by a plain memory copy of the parent class into the derived class
have to be altered. See <link linkend="GClassInitFunc"><function>GClassInitFunc()</function></link> for a discussion of the class
initialization process.</para>
<refsect3 id="GBaseInitFunc.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_class</para></entry>
<entry role="parameter_description"><para>The <link linkend="GTypeClass"><type>GTypeClass</type></link> structure to initialize. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeClass]</emphasis></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="GBaseFinalizeFunc" role="function">
<title>GBaseFinalizeFunc&#160;()</title>
<indexterm zone="GBaseFinalizeFunc"><primary sortas="BaseFinalizeFunc">GBaseFinalizeFunc</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
<phrase role="c_punctuation">(</phrase>*GBaseFinalizeFunc<phrase role="c_punctuation">)</phrase> (<parameter><link linkend="gpointer"><type>gpointer</type></link> g_class</parameter>);</programlisting>
<para>A callback function used by the type system to finalize those portions
of a derived types class structure that were setup from the corresponding
<link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link> function. Class finalization basically works the inverse
way in which class initialization is performed.
See <link linkend="GClassInitFunc"><function>GClassInitFunc()</function></link> for a discussion of the class initialization process.</para>
<refsect3 id="GBaseFinalizeFunc.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_class</para></entry>
<entry role="parameter_description"><para>The <link linkend="GTypeClass"><type>GTypeClass</type></link> structure to finalize. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeClass]</emphasis></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="GClassInitFunc" role="function">
<title>GClassInitFunc&#160;()</title>
<indexterm zone="GClassInitFunc"><primary sortas="ClassInitFunc">GClassInitFunc</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
<phrase role="c_punctuation">(</phrase>*GClassInitFunc<phrase role="c_punctuation">)</phrase> (<parameter><link linkend="gpointer"><type>gpointer</type></link> g_class</parameter>,
                   <parameter><link linkend="gpointer"><type>gpointer</type></link> class_data</parameter>);</programlisting>
<para>A callback function used by the type system to initialize the class
of a specific type. This function should initialize all static class
members.</para>
<para>The initialization process of a class involves:</para>
<itemizedlist>
<listitem><para>Copying common members from the parent class over to the
derived class structure.</para></listitem>
<listitem><para>Zero initialization of the remaining members not copied
over from the parent class.</para></listitem>
<listitem><para>Invocation of the <link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link> initializers of all parent
types and the class' type.</para></listitem>
<listitem>
<para>Invocation of the class' <link linkend="GClassInitFunc"><function>GClassInitFunc()</function></link> initializer.</para>
</listitem>
</itemizedlist>
<para>Since derived classes are partially initialized through a memory copy
of the parent class, the general rule is that <link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link> and
<link linkend="GBaseFinalizeFunc"><function>GBaseFinalizeFunc()</function></link> should take care of necessary reinitialization
and release of those class members that were introduced by the type
that specified these <link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link>/<link linkend="GBaseFinalizeFunc"><function>GBaseFinalizeFunc()</function></link>.
<link linkend="GClassInitFunc"><function>GClassInitFunc()</function></link> should only care about initializing static
class members, while dynamic class members (such as allocated strings
or reference counted resources) are better handled by a <link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link>
for this type, so proper initialization of the dynamic class members
is performed for class initialization of derived types as well.</para>
<para>An example may help to correspond the intend of the different class
initializers:</para>
<informalexample><programlisting role="example"><![CDATA[
typedef struct {
  GObjectClass parent_class;
  gint         static_integer;
  gchar       *dynamic_string;
} TypeAClass;
static void
type_a_base_class_init (TypeAClass *class)
{
  class->dynamic_string = g_strdup ("some string");
}
static void
type_a_base_class_finalize (TypeAClass *class)
{
  g_free (class->dynamic_string);
}
static void
type_a_class_init (TypeAClass *class)
{
  class->static_integer = 42;
}

typedef struct {
  TypeAClass   parent_class;
  gfloat       static_float;
  GString     *dynamic_gstring;
} TypeBClass;
static void
type_b_base_class_init (TypeBClass *class)
{
  class->dynamic_gstring = g_string_new ("some other string");
}
static void
type_b_base_class_finalize (TypeBClass *class)
{
  g_string_free (class->dynamic_gstring);
}
static void
type_b_class_init (TypeBClass *class)
{
  class->static_float = 3.14159265358979323846;
}
]]></programlisting></informalexample>
<para>
Initialization of TypeBClass will first cause initialization of
TypeAClass (derived classes reference their parent classes, see
<link linkend="g-type-class-ref"><function>g_type_class_ref()</function></link> on this).</para>
<para>Initialization of TypeAClass roughly involves zero-initializing its fields,
then calling its <link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link> <link linkend="type-a-base-class-init"><function>type_a_base_class_init()</function></link> to allocate
its dynamic members (dynamic_string), and finally calling its <link linkend="GClassInitFunc"><function>GClassInitFunc()</function></link>
<link linkend="type-a-class-init"><function>type_a_class_init()</function></link> to initialize its static members (static_integer).
The first step in the initialization process of TypeBClass is then
a plain memory copy of the contents of TypeAClass into TypeBClass and 
zero-initialization of the remaining fields in TypeBClass.
The dynamic members of TypeAClass within TypeBClass now need
reinitialization which is performed by calling <link linkend="type-a-base-class-init"><function>type_a_base_class_init()</function></link>
with an argument of TypeBClass.</para>
<para>After that, the <link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link> of TypeBClass, <link linkend="type-b-base-class-init"><function>type_b_base_class_init()</function></link>
is called to allocate the dynamic members of TypeBClass (dynamic_gstring),
and finally the <link linkend="GClassInitFunc"><function>GClassInitFunc()</function></link> of TypeBClass, <link linkend="type-b-class-init"><function>type_b_class_init()</function></link>,
is called to complete the initialization process with the static members
(static_float).</para>
<para>Corresponding finalization counter parts to the <link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link> functions
have to be provided to release allocated resources at class finalization
time.</para>
<refsect3 id="GClassInitFunc.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_class</para></entry>
<entry role="parameter_description"><para>The <link linkend="GTypeClass"><type>GTypeClass</type></link> structure to initialize. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeClass]</emphasis></entry></row>
<row><entry role="parameter_name"><para>class_data</para></entry>
<entry role="parameter_description"><para>The <parameter>class_data</parameter>
member supplied via the <link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure.</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="GClassFinalizeFunc" role="function">
<title>GClassFinalizeFunc&#160;()</title>
<indexterm zone="GClassFinalizeFunc"><primary sortas="ClassFinalizeFunc">GClassFinalizeFunc</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
<phrase role="c_punctuation">(</phrase>*GClassFinalizeFunc<phrase role="c_punctuation">)</phrase> (<parameter><link linkend="gpointer"><type>gpointer</type></link> g_class</parameter>,
                       <parameter><link linkend="gpointer"><type>gpointer</type></link> class_data</parameter>);</programlisting>
<para>A callback function used by the type system to finalize a class.
This function is rarely needed, as dynamically allocated class resources
should be handled by <link linkend="GBaseInitFunc"><function>GBaseInitFunc()</function></link> and <link linkend="GBaseFinalizeFunc"><function>GBaseFinalizeFunc()</function></link>.
Also, specification of a <link linkend="GClassFinalizeFunc"><function>GClassFinalizeFunc()</function></link> in the <link linkend="GTypeInfo"><type>GTypeInfo</type></link>
structure of a static type is invalid, because classes of static types
will never be finalized (they are artificially kept alive when their
reference count drops to zero).</para>
<refsect3 id="GClassFinalizeFunc.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_class</para></entry>
<entry role="parameter_description"><para>The <link linkend="GTypeClass"><type>GTypeClass</type></link> structure to finalize. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeClass]</emphasis></entry></row>
<row><entry role="parameter_name"><para>class_data</para></entry>
<entry role="parameter_description"><para>The <parameter>class_data</parameter>
member supplied via the <link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="GInstanceInitFunc" role="function">
<title>GInstanceInitFunc&#160;()</title>
<indexterm zone="GInstanceInitFunc"><primary sortas="InstanceInitFunc">GInstanceInitFunc</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
<phrase role="c_punctuation">(</phrase>*GInstanceInitFunc<phrase role="c_punctuation">)</phrase> (<parameter><link linkend="GTypeInstance"><type>GTypeInstance</type></link> *instance</parameter>,
                      <parameter><link linkend="gpointer"><type>gpointer</type></link> g_class</parameter>);</programlisting>
<para>A callback function used by the type system to initialize a new
instance of a type. This function initializes all instance members and
allocates any resources required by it.</para>
<para>Initialization of a derived instance involves calling all its parent
types instance initializers, so the class member of the instance
is altered during its initialization to always point to the class that
belongs to the type the current initializer was introduced for.</para>
<para>The extended members of <parameter>instance</parameter>
 are guaranteed to have been filled with
zeros before this function is called.</para>
<refsect3 id="GInstanceInitFunc.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>instance</para></entry>
<entry role="parameter_description"><para>The instance to initialize</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>g_class</para></entry>
<entry role="parameter_description"><para>The class of the type the instance is
created for. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeClass]</emphasis></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="GInterfaceInitFunc" role="function">
<title>GInterfaceInitFunc&#160;()</title>
<indexterm zone="GInterfaceInitFunc"><primary sortas="InterfaceInitFunc">GInterfaceInitFunc</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
<phrase role="c_punctuation">(</phrase>*GInterfaceInitFunc<phrase role="c_punctuation">)</phrase> (<parameter><link linkend="gpointer"><type>gpointer</type></link> g_iface</parameter>,
                       <parameter><link linkend="gpointer"><type>gpointer</type></link> iface_data</parameter>);</programlisting>
<para>A callback function used by the type system to initialize a new
interface.  This function should initialize all internal data and
allocate any resources required by the interface.</para>
<para>The members of <parameter>iface_data</parameter>
 are guaranteed to have been filled with
zeros before this function is called.</para>
<refsect3 id="GInterfaceInitFunc.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_iface</para></entry>
<entry role="parameter_description"><para>The interface structure to initialize. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeInterface]</emphasis></entry></row>
<row><entry role="parameter_name"><para>iface_data</para></entry>
<entry role="parameter_description"><para>The <parameter>interface_data</parameter>
supplied via the <link linkend="GInterfaceInfo"><type>GInterfaceInfo</type></link> structure</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="GInterfaceFinalizeFunc" role="function">
<title>GInterfaceFinalizeFunc&#160;()</title>
<indexterm zone="GInterfaceFinalizeFunc"><primary sortas="InterfaceFinalizeFunc">GInterfaceFinalizeFunc</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
<phrase role="c_punctuation">(</phrase>*GInterfaceFinalizeFunc<phrase role="c_punctuation">)</phrase> (<parameter><link linkend="gpointer"><type>gpointer</type></link> g_iface</parameter>,
                           <parameter><link linkend="gpointer"><type>gpointer</type></link> iface_data</parameter>);</programlisting>
<para>A callback function used by the type system to finalize an interface.
This function should destroy any internal data and release any resources
allocated by the corresponding <link linkend="GInterfaceInitFunc"><function>GInterfaceInitFunc()</function></link> function.</para>
<refsect3 id="GInterfaceFinalizeFunc.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_iface</para></entry>
<entry role="parameter_description"><para>The interface structure to finalize. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeInterface]</emphasis></entry></row>
<row><entry role="parameter_name"><para>iface_data</para></entry>
<entry role="parameter_description"><para>The <parameter>interface_data</parameter>
supplied via the <link linkend="GInterfaceInfo"><type>GInterfaceInfo</type></link> structure</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="GTypeClassCacheFunc" role="function">
<title>GTypeClassCacheFunc&#160;()</title>
<indexterm zone="GTypeClassCacheFunc"><primary sortas="TypeClassCacheFunc">GTypeClassCacheFunc</primary></indexterm>
<programlisting language="C"><link linkend="gboolean"><returnvalue>gboolean</returnvalue></link>
<phrase role="c_punctuation">(</phrase>*GTypeClassCacheFunc<phrase role="c_punctuation">)</phrase> (<parameter><link linkend="gpointer"><type>gpointer</type></link> cache_data</parameter>,
                        <parameter><link linkend="GTypeClass"><type>GTypeClass</type></link> *g_class</parameter>);</programlisting>
<para>A callback function which is called when the reference count of a class 
drops to zero. It may use <link linkend="g-type-class-ref"><function>g_type_class_ref()</function></link> to prevent the class from
being freed. You should not call <link linkend="g-type-class-unref"><function>g_type_class_unref()</function></link> from a 
<link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link> function to prevent infinite recursion, use 
<link linkend="g-type-class-unref-uncached"><function>g_type_class_unref_uncached()</function></link> instead.</para>
<para>The functions have to check the class id passed in to figure 
whether they actually want to cache the class of this type, since all
classes are routed through the same <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link> chain.</para>
<refsect3 id="GTypeClassCacheFunc.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>cache_data</para></entry>
<entry role="parameter_description"><para>data that was given to the <link linkend="g-type-add-class-cache-func"><function>g_type_add_class_cache_func()</function></link> call</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>g_class</para></entry>
<entry role="parameter_description"><para>The <link linkend="GTypeClass"><type>GTypeClass</type></link> structure which is
unreferenced. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeClass]</emphasis></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="GTypeClassCacheFunc.returns" role="returns">
<title>Returns</title>
<para> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> to stop further <link linkend="GTypeClassCacheFuncs"><type>GTypeClassCacheFuncs</type></link> from being
called, <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> to continue</para>
</refsect3></refsect2>
<refsect2 id="g-type-register-static" role="function">
<title>g_type_register_static&#160;()</title>
<indexterm zone="g-type-register-static"><primary sortas="type_register_static">g_type_register_static</primary></indexterm>
<programlisting language="C"><link linkend="GType"><returnvalue>GType</returnvalue></link>
g_type_register_static (<parameter><link linkend="GType"><type>GType</type></link> parent_type</parameter>,
                        <parameter>const <link linkend="gchar"><type>gchar</type></link> *type_name</parameter>,
                        <parameter>const <link linkend="GTypeInfo"><type>GTypeInfo</type></link> *info</parameter>,
                        <parameter><link linkend="GTypeFlags"><type>GTypeFlags</type></link> flags</parameter>);</programlisting>
<para>Registers <parameter>type_name</parameter>
 as the name of a new static type derived from
<parameter>parent_type</parameter>
. The type system uses the information contained in the
<link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure pointed to by <parameter>info</parameter>
 to manage the type and its
instances (if not abstract). The value of <parameter>flags</parameter>
 determines the nature
(e.g. abstract or not) of the type.</para>
<refsect3 id="g-type-register-static.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>parent_type</para></entry>
<entry role="parameter_description"><para>type from which this type will be derived</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>type_name</para></entry>
<entry role="parameter_description"><para>0-terminated string used as the name of the new type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>info</para></entry>
<entry role="parameter_description"><para><link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure for this type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>flags</para></entry>
<entry role="parameter_description"><para>bitwise combination of <link linkend="GTypeFlags"><type>GTypeFlags</type></link> values</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-register-static.returns" role="returns">
<title>Returns</title>
<para> the new type identifier</para>
</refsect3></refsect2>
<refsect2 id="g-type-register-static-simple" role="function" condition="since:2.12">
<title>g_type_register_static_simple&#160;()</title>
<indexterm zone="g-type-register-static-simple" role="2.12"><primary sortas="type_register_static_simple">g_type_register_static_simple</primary></indexterm>
<programlisting language="C"><link linkend="GType"><returnvalue>GType</returnvalue></link>
g_type_register_static_simple (<parameter><link linkend="GType"><type>GType</type></link> parent_type</parameter>,
                               <parameter>const <link linkend="gchar"><type>gchar</type></link> *type_name</parameter>,
                               <parameter><link linkend="guint"><type>guint</type></link> class_size</parameter>,
                               <parameter><link linkend="GClassInitFunc"><type>GClassInitFunc</type></link> class_init</parameter>,
                               <parameter><link linkend="guint"><type>guint</type></link> instance_size</parameter>,
                               <parameter><link linkend="GInstanceInitFunc"><type>GInstanceInitFunc</type></link> instance_init</parameter>,
                               <parameter><link linkend="GTypeFlags"><type>GTypeFlags</type></link> flags</parameter>);</programlisting>
<para>Registers <parameter>type_name</parameter>
 as the name of a new static type derived from
<parameter>parent_type</parameter>
.  The value of <parameter>flags</parameter>
 determines the nature (e.g.
abstract or not) of the type. It works by filling a <link linkend="GTypeInfo"><type>GTypeInfo</type></link>
struct and calling <link linkend="g-type-register-static"><function>g_type_register_static()</function></link>.</para>

<para><emphasis role="annotation">[<acronym>skip</acronym>]</emphasis></para><refsect3 id="g-type-register-static-simple.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>parent_type</para></entry>
<entry role="parameter_description"><para>type from which this type will be derived</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>type_name</para></entry>
<entry role="parameter_description"><para>0-terminated string used as the name of the new type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>class_size</para></entry>
<entry role="parameter_description"><para>size of the class structure (see <link linkend="GTypeInfo"><type>GTypeInfo</type></link>)</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>class_init</para></entry>
<entry role="parameter_description"><para>location of the class initialization function (see <link linkend="GTypeInfo"><type>GTypeInfo</type></link>)</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>instance_size</para></entry>
<entry role="parameter_description"><para>size of the instance structure (see <link linkend="GTypeInfo"><type>GTypeInfo</type></link>)</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>instance_init</para></entry>
<entry role="parameter_description"><para>location of the instance initialization function (see <link linkend="GTypeInfo"><type>GTypeInfo</type></link>)</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>flags</para></entry>
<entry role="parameter_description"><para>bitwise combination of <link linkend="GTypeFlags"><type>GTypeFlags</type></link> values</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-register-static-simple.returns" role="returns">
<title>Returns</title>
<para> the new type identifier</para>
</refsect3><para role="since">Since: <link linkend="api-index-2.12">2.12</link></para></refsect2>
<refsect2 id="g-type-register-dynamic" role="function">
<title>g_type_register_dynamic&#160;()</title>
<indexterm zone="g-type-register-dynamic"><primary sortas="type_register_dynamic">g_type_register_dynamic</primary></indexterm>
<programlisting language="C"><link linkend="GType"><returnvalue>GType</returnvalue></link>
g_type_register_dynamic (<parameter><link linkend="GType"><type>GType</type></link> parent_type</parameter>,
                         <parameter>const <link linkend="gchar"><type>gchar</type></link> *type_name</parameter>,
                         <parameter><link linkend="GTypePlugin"><type>GTypePlugin</type></link> *plugin</parameter>,
                         <parameter><link linkend="GTypeFlags"><type>GTypeFlags</type></link> flags</parameter>);</programlisting>
<para>Registers <parameter>type_name</parameter>
 as the name of a new dynamic type derived from
<parameter>parent_type</parameter>
.  The type system uses the information contained in the
<link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure pointed to by <parameter>plugin</parameter>
 to manage the type and its
instances (if not abstract).  The value of <parameter>flags</parameter>
 determines the nature
(e.g. abstract or not) of the type.</para>
<refsect3 id="g-type-register-dynamic.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>parent_type</para></entry>
<entry role="parameter_description"><para>type from which this type will be derived</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>type_name</para></entry>
<entry role="parameter_description"><para>0-terminated string used as the name of the new type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>plugin</para></entry>
<entry role="parameter_description"><para><link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure to retrieve the <link linkend="GTypeInfo"><type>GTypeInfo</type></link> from</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>flags</para></entry>
<entry role="parameter_description"><para>bitwise combination of <link linkend="GTypeFlags"><type>GTypeFlags</type></link> values</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-register-dynamic.returns" role="returns">
<title>Returns</title>
<para> the new type identifier or <link linkend="G-TYPE-INVALID:CAPS"><type>G_TYPE_INVALID</type></link> if registration failed</para>
</refsect3></refsect2>
<refsect2 id="g-type-register-fundamental" role="function">
<title>g_type_register_fundamental&#160;()</title>
<indexterm zone="g-type-register-fundamental"><primary sortas="type_register_fundamental">g_type_register_fundamental</primary></indexterm>
<programlisting language="C"><link linkend="GType"><returnvalue>GType</returnvalue></link>
g_type_register_fundamental (<parameter><link linkend="GType"><type>GType</type></link> type_id</parameter>,
                             <parameter>const <link linkend="gchar"><type>gchar</type></link> *type_name</parameter>,
                             <parameter>const <link linkend="GTypeInfo"><type>GTypeInfo</type></link> *info</parameter>,
                             <parameter>const <link linkend="GTypeFundamentalInfo"><type>GTypeFundamentalInfo</type></link> *finfo</parameter>,
                             <parameter><link linkend="GTypeFlags"><type>GTypeFlags</type></link> flags</parameter>);</programlisting>
<para>Registers <parameter>type_id</parameter>
 as the predefined identifier and <parameter>type_name</parameter>
 as the
name of a fundamental type. If <parameter>type_id</parameter>
 is already registered, or a
type named <parameter>type_name</parameter>
 is already registered, the behaviour is undefined.
The type system uses the information contained in the <link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure
pointed to by <parameter>info</parameter>
 and the <link linkend="GTypeFundamentalInfo"><type>GTypeFundamentalInfo</type></link> structure pointed to by
<parameter>finfo</parameter>
 to manage the type and its instances. The value of <parameter>flags</parameter>
 determines
additional characteristics of the fundamental type.</para>
<refsect3 id="g-type-register-fundamental.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type_id</para></entry>
<entry role="parameter_description"><para>a predefined type identifier</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>type_name</para></entry>
<entry role="parameter_description"><para>0-terminated string used as the name of the new type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>info</para></entry>
<entry role="parameter_description"><para><link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure for this type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>finfo</para></entry>
<entry role="parameter_description"><para><link linkend="GTypeFundamentalInfo"><type>GTypeFundamentalInfo</type></link> structure for this type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>flags</para></entry>
<entry role="parameter_description"><para>bitwise combination of <link linkend="GTypeFlags"><type>GTypeFlags</type></link> values</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-register-fundamental.returns" role="returns">
<title>Returns</title>
<para> the predefined type identifier</para>
</refsect3></refsect2>
<refsect2 id="g-type-add-interface-static" role="function">
<title>g_type_add_interface_static&#160;()</title>
<indexterm zone="g-type-add-interface-static"><primary sortas="type_add_interface_static">g_type_add_interface_static</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_add_interface_static (<parameter><link linkend="GType"><type>GType</type></link> instance_type</parameter>,
                             <parameter><link linkend="GType"><type>GType</type></link> interface_type</parameter>,
                             <parameter>const <link linkend="GInterfaceInfo"><type>GInterfaceInfo</type></link> *info</parameter>);</programlisting>
<para>Adds the static <parameter>interface_type</parameter>
 to <parameter>instantiable_type</parameter>
.
The information contained in the <link linkend="GInterfaceInfo"><type>GInterfaceInfo</type></link> structure
pointed to by <parameter>info</parameter>
 is used to manage the relationship.</para>
<refsect3 id="g-type-add-interface-static.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>instance_type</para></entry>
<entry role="parameter_description"><para><link linkend="GType"><type>GType</type></link> value of an instantiable type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>interface_type</para></entry>
<entry role="parameter_description"><para><link linkend="GType"><type>GType</type></link> value of an interface type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>info</para></entry>
<entry role="parameter_description"><para><link linkend="GInterfaceInfo"><type>GInterfaceInfo</type></link> structure for this
(<parameter>instance_type</parameter>
, <parameter>interface_type</parameter>
) combination</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="g-type-add-interface-dynamic" role="function">
<title>g_type_add_interface_dynamic&#160;()</title>
<indexterm zone="g-type-add-interface-dynamic"><primary sortas="type_add_interface_dynamic">g_type_add_interface_dynamic</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_add_interface_dynamic (<parameter><link linkend="GType"><type>GType</type></link> instance_type</parameter>,
                              <parameter><link linkend="GType"><type>GType</type></link> interface_type</parameter>,
                              <parameter><link linkend="GTypePlugin"><type>GTypePlugin</type></link> *plugin</parameter>);</programlisting>
<para>Adds the dynamic <parameter>interface_type</parameter>
 to <parameter>instantiable_type</parameter>
. The information
contained in the <link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure pointed to by <parameter>plugin</parameter>

is used to manage the relationship.</para>
<refsect3 id="g-type-add-interface-dynamic.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>instance_type</para></entry>
<entry role="parameter_description"><para><link linkend="GType"><type>GType</type></link> value of an instantiable type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>interface_type</para></entry>
<entry role="parameter_description"><para><link linkend="GType"><type>GType</type></link> value of an interface type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>plugin</para></entry>
<entry role="parameter_description"><para><link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure to retrieve the <link linkend="GInterfaceInfo"><type>GInterfaceInfo</type></link> from</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="g-type-interface-add-prerequisite" role="function">
<title>g_type_interface_add_prerequisite&#160;()</title>
<indexterm zone="g-type-interface-add-prerequisite"><primary sortas="type_interface_add_prerequisite">g_type_interface_add_prerequisite</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_interface_add_prerequisite (<parameter><link linkend="GType"><type>GType</type></link> interface_type</parameter>,
                                   <parameter><link linkend="GType"><type>GType</type></link> prerequisite_type</parameter>);</programlisting>
<para>Adds <parameter>prerequisite_type</parameter>
 to the list of prerequisites of <parameter>interface_type</parameter>
.
This means that any type implementing <parameter>interface_type</parameter>
 must also implement
<parameter>prerequisite_type</parameter>
. Prerequisites can be thought of as an alternative to
interface derivation (which GType doesn't support). An interface can have
at most one instantiatable prerequisite type.</para>
<refsect3 id="g-type-interface-add-prerequisite.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>interface_type</para></entry>
<entry role="parameter_description"><para><link linkend="GType"><type>GType</type></link> value of an interface type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>prerequisite_type</para></entry>
<entry role="parameter_description"><para><link linkend="GType"><type>GType</type></link> value of an interface or instantiatable type</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="g-type-get-plugin" role="function">
<title>g_type_get_plugin&#160;()</title>
<indexterm zone="g-type-get-plugin"><primary sortas="type_get_plugin">g_type_get_plugin</primary></indexterm>
<programlisting language="C"><link linkend="GTypePlugin"><returnvalue>GTypePlugin</returnvalue></link>&#160;*
g_type_get_plugin (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>);</programlisting>
<para>Returns the <link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure for <parameter>type</parameter>
.</para>
<refsect3 id="g-type-get-plugin.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para><link linkend="GType"><type>GType</type></link> to retrieve the plugin for</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-get-plugin.returns" role="returns">
<title>Returns</title>
<para>the corresponding plugin
if <parameter>type</parameter>
is a dynamic type, <link linkend="NULL:CAPS"><literal>NULL</literal></link> otherwise. </para>
<para><emphasis role="annotation">[<acronym>transfer none</acronym>]</emphasis></para>
</refsect3></refsect2>
<refsect2 id="g-type-interface-get-plugin" role="function">
<title>g_type_interface_get_plugin&#160;()</title>
<indexterm zone="g-type-interface-get-plugin"><primary sortas="type_interface_get_plugin">g_type_interface_get_plugin</primary></indexterm>
<programlisting language="C"><link linkend="GTypePlugin"><returnvalue>GTypePlugin</returnvalue></link>&#160;*
g_type_interface_get_plugin (<parameter><link linkend="GType"><type>GType</type></link> instance_type</parameter>,
                             <parameter><link linkend="GType"><type>GType</type></link> interface_type</parameter>);</programlisting>
<para>Returns the <link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure for the dynamic interface
<parameter>interface_type</parameter>
 which has been added to <parameter>instance_type</parameter>
, or <link linkend="NULL:CAPS"><literal>NULL</literal></link>
if <parameter>interface_type</parameter>
 has not been added to <parameter>instance_type</parameter>
 or does
not have a <link linkend="GTypePlugin"><type>GTypePlugin</type></link> structure. See <link linkend="g-type-add-interface-dynamic"><function>g_type_add_interface_dynamic()</function></link>.</para>
<refsect3 id="g-type-interface-get-plugin.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>instance_type</para></entry>
<entry role="parameter_description"><para><link linkend="GType"><type>GType</type></link> of an instantiatable type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>interface_type</para></entry>
<entry role="parameter_description"><para><link linkend="GType"><type>GType</type></link> of an interface type</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-interface-get-plugin.returns" role="returns">
<title>Returns</title>
<para>the <link linkend="GTypePlugin"><type>GTypePlugin</type></link> for the dynamic
interface <parameter>interface_type</parameter>
of <parameter>instance_type</parameter>
. </para>
<para><emphasis role="annotation">[<acronym>transfer none</acronym>]</emphasis></para>
</refsect3></refsect2>
<refsect2 id="g-type-fundamental-next" role="function">
<title>g_type_fundamental_next&#160;()</title>
<indexterm zone="g-type-fundamental-next"><primary sortas="type_fundamental_next">g_type_fundamental_next</primary></indexterm>
<programlisting language="C"><link linkend="GType"><returnvalue>GType</returnvalue></link>
g_type_fundamental_next (<parameter><type>void</type></parameter>);</programlisting>
<para>Returns the next free fundamental type id which can be used to
register a new fundamental type with <link linkend="g-type-register-fundamental"><function>g_type_register_fundamental()</function></link>.
The returned type ID represents the highest currently registered
fundamental type identifier.</para>
<refsect3 id="g-type-fundamental-next.returns" role="returns">
<title>Returns</title>
<para> the next available fundamental type ID to be registered,
or 0 if the type system ran out of fundamental type IDs</para>
</refsect3></refsect2>
<refsect2 id="g-type-fundamental" role="function">
<title>g_type_fundamental&#160;()</title>
<indexterm zone="g-type-fundamental"><primary sortas="type_fundamental">g_type_fundamental</primary></indexterm>
<programlisting language="C"><link linkend="GType"><returnvalue>GType</returnvalue></link>
g_type_fundamental (<parameter><link linkend="GType"><type>GType</type></link> type_id</parameter>);</programlisting>
<para>Internal function, used to extract the fundamental type ID portion.
Use <link linkend="G-TYPE-FUNDAMENTAL:CAPS"><function>G_TYPE_FUNDAMENTAL()</function></link> instead.</para>
<refsect3 id="g-type-fundamental.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type_id</para></entry>
<entry role="parameter_description"><para>valid type ID</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-fundamental.returns" role="returns">
<title>Returns</title>
<para> fundamental type ID</para>
</refsect3></refsect2>
<refsect2 id="g-type-create-instance" role="function">
<title>g_type_create_instance&#160;()</title>
<indexterm zone="g-type-create-instance"><primary sortas="type_create_instance">g_type_create_instance</primary></indexterm>
<programlisting language="C"><link linkend="GTypeInstance"><returnvalue>GTypeInstance</returnvalue></link>&#160;*
g_type_create_instance (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>);</programlisting>
<para>Creates and initializes an instance of <parameter>type</parameter>
 if <parameter>type</parameter>
 is valid and
can be instantiated. The type system only performs basic allocation
and structure setups for instances: actual instance creation should
happen through functions supplied by the type's fundamental type
implementation.  So use of <link linkend="g-type-create-instance"><function>g_type_create_instance()</function></link> is reserved for
implementators of fundamental types only. E.g. instances of the
<link linkend="GObject"><type>GObject</type></link> hierarchy should be created via <link linkend="g-object-new"><function>g_object_new()</function></link> and never
directly through <link linkend="g-type-create-instance"><function>g_type_create_instance()</function></link> which doesn't handle things
like singleton objects or object construction.</para>
<para>The extended members of the returned instance are guaranteed to be filled
with zeros.</para>
<para>Note: Do not use this function, unless you're implementing a
fundamental type. Also language bindings should not use this
function, but <link linkend="g-object-new"><function>g_object_new()</function></link> instead.</para>

<para><emphasis role="annotation">[<acronym>skip</acronym>]</emphasis></para><refsect3 id="g-type-create-instance.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>an instantiatable type to create an instance for</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-create-instance.returns" role="returns">
<title>Returns</title>
<para> an allocated and initialized instance, subject to further
treatment by the fundamental type implementation</para>
</refsect3></refsect2>
<refsect2 id="g-type-free-instance" role="function">
<title>g_type_free_instance&#160;()</title>
<indexterm zone="g-type-free-instance"><primary sortas="type_free_instance">g_type_free_instance</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_free_instance (<parameter><link linkend="GTypeInstance"><type>GTypeInstance</type></link> *instance</parameter>);</programlisting>
<para>Frees an instance of a type, returning it to the instance pool for
the type, if there is one.</para>
<para>Like <link linkend="g-type-create-instance"><function>g_type_create_instance()</function></link>, this function is reserved for
implementors of fundamental types.</para>
<refsect3 id="g-type-free-instance.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>instance</para></entry>
<entry role="parameter_description"><para>an instance of a type</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="g-type-add-class-cache-func" role="function">
<title>g_type_add_class_cache_func&#160;()</title>
<indexterm zone="g-type-add-class-cache-func"><primary sortas="type_add_class_cache_func">g_type_add_class_cache_func</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_add_class_cache_func (<parameter><link linkend="gpointer"><type>gpointer</type></link> cache_data</parameter>,
                             <parameter><link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link> cache_func</parameter>);</programlisting>
<para>Adds a <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link> to be called before the reference count of a
class goes from one to zero. This can be used to prevent premature class
destruction. All installed <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link> functions will be chained
until one of them returns <link linkend="TRUE:CAPS"><literal>TRUE</literal></link>. The functions have to check the class id
passed in to figure whether they actually want to cache the class of this
type, since all classes are routed through the same <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link>
chain.</para>

<para><emphasis role="annotation">[<acronym>skip</acronym>]</emphasis></para><refsect3 id="g-type-add-class-cache-func.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>cache_data</para></entry>
<entry role="parameter_description"><para>data to be passed to <parameter>cache_func</parameter>
</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>cache_func</para></entry>
<entry role="parameter_description"><para>a <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="g-type-remove-class-cache-func" role="function">
<title>g_type_remove_class_cache_func&#160;()</title>
<indexterm zone="g-type-remove-class-cache-func"><primary sortas="type_remove_class_cache_func">g_type_remove_class_cache_func</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_remove_class_cache_func (<parameter><link linkend="gpointer"><type>gpointer</type></link> cache_data</parameter>,
                                <parameter><link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link> cache_func</parameter>);</programlisting>
<para>Removes a previously installed <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link>. The cache
maintained by <parameter>cache_func</parameter>
 has to be empty when calling
<link linkend="g-type-remove-class-cache-func"><function>g_type_remove_class_cache_func()</function></link> to avoid leaks.</para>

<para><emphasis role="annotation">[<acronym>skip</acronym>]</emphasis></para><refsect3 id="g-type-remove-class-cache-func.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>cache_data</para></entry>
<entry role="parameter_description"><para>data that was given when adding <parameter>cache_func</parameter>
</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>cache_func</para></entry>
<entry role="parameter_description"><para>a <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="g-type-class-unref-uncached" role="function">
<title>g_type_class_unref_uncached&#160;()</title>
<indexterm zone="g-type-class-unref-uncached"><primary sortas="type_class_unref_uncached">g_type_class_unref_uncached</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_class_unref_uncached (<parameter><link linkend="gpointer"><type>gpointer</type></link> g_class</parameter>);</programlisting>
<para>A variant of <link linkend="g-type-class-unref"><function>g_type_class_unref()</function></link> for use in <link linkend="GTypeClassCacheFunc"><type>GTypeClassCacheFunc</type></link>
implementations. It unreferences a class without consulting the chain
of <link linkend="GTypeClassCacheFuncs"><type>GTypeClassCacheFuncs</type></link>, avoiding the recursion which would occur
otherwise.</para>

<para><emphasis role="annotation">[<acronym>skip</acronym>]</emphasis></para><refsect3 id="g-type-class-unref-uncached.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>g_class</para></entry>
<entry role="parameter_description"><para>a <link linkend="GTypeClass"><type>GTypeClass</type></link> structure to unref. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeClass]</emphasis></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="g-type-add-interface-check" role="function" condition="since:2.4">
<title>g_type_add_interface_check&#160;()</title>
<indexterm zone="g-type-add-interface-check" role="2.4"><primary sortas="type_add_interface_check">g_type_add_interface_check</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_add_interface_check (<parameter><link linkend="gpointer"><type>gpointer</type></link> check_data</parameter>,
                            <parameter><link linkend="GTypeInterfaceCheckFunc"><type>GTypeInterfaceCheckFunc</type></link> check_func</parameter>);</programlisting>
<para>Adds a function to be called after an interface vtable is
initialized for any class (i.e. after the <parameter>interface_init</parameter>

member of <link linkend="GInterfaceInfo"><type>GInterfaceInfo</type></link> has been called).</para>
<para>This function is useful when you want to check an invariant
that depends on the interfaces of a class. For instance, the
implementation of <link linkend="GObject"><type>GObject</type></link> uses this facility to check that an
object implements all of the properties that are defined on its
interfaces.</para>

<para><emphasis role="annotation">[<acronym>skip</acronym>]</emphasis></para><refsect3 id="g-type-add-interface-check.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>check_data</para></entry>
<entry role="parameter_description"><para>data to pass to <parameter>check_func</parameter>
</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>check_func</para></entry>
<entry role="parameter_description"><para>function to be called after each interface
is initialized</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.4">2.4</link></para></refsect2>
<refsect2 id="g-type-remove-interface-check" role="function" condition="since:2.4">
<title>g_type_remove_interface_check&#160;()</title>
<indexterm zone="g-type-remove-interface-check" role="2.4"><primary sortas="type_remove_interface_check">g_type_remove_interface_check</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_remove_interface_check (<parameter><link linkend="gpointer"><type>gpointer</type></link> check_data</parameter>,
                               <parameter><link linkend="GTypeInterfaceCheckFunc"><type>GTypeInterfaceCheckFunc</type></link> check_func</parameter>);</programlisting>
<para>Removes an interface check function added with
<link linkend="g-type-add-interface-check"><function>g_type_add_interface_check()</function></link>.</para>

<para><emphasis role="annotation">[<acronym>skip</acronym>]</emphasis></para><refsect3 id="g-type-remove-interface-check.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>check_data</para></entry>
<entry role="parameter_description"><para>callback data passed to <link linkend="g-type-add-interface-check"><function>g_type_add_interface_check()</function></link></para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>check_func</para></entry>
<entry role="parameter_description"><para>callback function passed to <link linkend="g-type-add-interface-check"><function>g_type_add_interface_check()</function></link></para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.4">2.4</link></para></refsect2>
<refsect2 id="GTypeInterfaceCheckFunc" role="function" condition="since:2.4">
<title>GTypeInterfaceCheckFunc&#160;()</title>
<indexterm zone="GTypeInterfaceCheckFunc" role="2.4"><primary sortas="TypeInterfaceCheckFunc">GTypeInterfaceCheckFunc</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
<phrase role="c_punctuation">(</phrase>*GTypeInterfaceCheckFunc<phrase role="c_punctuation">)</phrase> (<parameter><link linkend="gpointer"><type>gpointer</type></link> check_data</parameter>,
                            <parameter><link linkend="gpointer"><type>gpointer</type></link> g_iface</parameter>);</programlisting>
<para>A callback called after an interface vtable is initialized.
See <link linkend="g-type-add-interface-check"><function>g_type_add_interface_check()</function></link>.</para>
<refsect3 id="GTypeInterfaceCheckFunc.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>check_data</para></entry>
<entry role="parameter_description"><para>data passed to <link linkend="g-type-add-interface-check"><function>g_type_add_interface_check()</function></link></para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>g_iface</para></entry>
<entry role="parameter_description"><para>the interface that has been
initialized. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>type</acronym> GObject.TypeInterface]</emphasis></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.4">2.4</link></para></refsect2>
<refsect2 id="g-type-value-table-peek" role="function">
<title>g_type_value_table_peek&#160;()</title>
<indexterm zone="g-type-value-table-peek"><primary sortas="type_value_table_peek">g_type_value_table_peek</primary></indexterm>
<programlisting language="C"><link linkend="GTypeValueTable"><returnvalue>GTypeValueTable</returnvalue></link>&#160;*
g_type_value_table_peek (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>);</programlisting>
<para>Returns the location of the <link linkend="GTypeValueTable"><type>GTypeValueTable</type></link> associated with <parameter>type</parameter>
.</para>
<para>Note that this function should only be used from source code
that implements or has internal knowledge of the implementation of
<parameter>type</parameter>
.</para>

<para><emphasis role="annotation">[<acronym>skip</acronym>]</emphasis></para><refsect3 id="g-type-value-table-peek.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>a <link linkend="GType"><type>GType</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-value-table-peek.returns" role="returns">
<title>Returns</title>
<para> location of the <link linkend="GTypeValueTable"><type>GTypeValueTable</type></link> associated with <parameter>type</parameter>
or
<link linkend="NULL:CAPS"><literal>NULL</literal></link> if there is no <link linkend="GTypeValueTable"><type>GTypeValueTable</type></link> associated with <parameter>type</parameter>
</para>
</refsect3></refsect2>
<refsect2 id="g-type-ensure" role="function" condition="since:2.34">
<title>g_type_ensure&#160;()</title>
<indexterm zone="g-type-ensure" role="2.34"><primary sortas="type_ensure">g_type_ensure</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
g_type_ensure (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>);</programlisting>
<para>Ensures that the indicated <parameter>type</parameter>
 has been registered with the
type system, and its <link linkend="class-init"><function>_class_init()</function></link> method has been run.</para>
<para>In theory, simply calling the type's <link linkend="get-type"><function>_get_type()</function></link> method (or using
the corresponding macro) is supposed take care of this. However,
<link linkend="get-type"><function>_get_type()</function></link> methods are often marked <link linkend="G-GNUC-CONST:CAPS"><literal>G_GNUC_CONST</literal></link> for performance
reasons, even though this is technically incorrect (since
<link linkend="G-GNUC-CONST:CAPS"><literal>G_GNUC_CONST</literal></link> requires that the function not have side effects,
which <link linkend="get-type"><function>_get_type()</function></link> methods do on the first call). As a result, if
you write a bare call to a <link linkend="get-type"><function>_get_type()</function></link> macro, it may get optimized
out by the compiler. Using <link linkend="g-type-ensure"><function>g_type_ensure()</function></link> guarantees that the
type's <link linkend="get-type"><function>_get_type()</function></link> method is called.</para>
<refsect3 id="g-type-ensure.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>a <link linkend="GType"><type>GType</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.34">2.34</link></para></refsect2>
<refsect2 id="g-type-get-type-registration-serial" role="function" condition="since:2.36">
<title>g_type_get_type_registration_serial&#160;()</title>
<indexterm zone="g-type-get-type-registration-serial" role="2.36"><primary sortas="type_get_type_registration_serial">g_type_get_type_registration_serial</primary></indexterm>
<programlisting language="C"><link linkend="guint"><returnvalue>guint</returnvalue></link>
g_type_get_type_registration_serial (<parameter><type>void</type></parameter>);</programlisting>
<para>Returns an opaque serial number that represents the state of the set
of registered types. Any time a type is registered this serial changes,
which means you can cache information based on type lookups (such as
<link linkend="g-type-from-name"><function>g_type_from_name()</function></link>) and know if the cache is still valid at a later
time by comparing the current serial with the one at the type lookup.</para>
<refsect3 id="g-type-get-type-registration-serial.returns" role="returns">
<title>Returns</title>
<para> An unsigned int, representing the state of type registrations</para>
</refsect3><para role="since">Since: <link linkend="api-index-2.36">2.36</link></para></refsect2>
<refsect2 id="g-type-get-instance-count" role="function" condition="since:2.44">
<title>g_type_get_instance_count&#160;()</title>
<indexterm zone="g-type-get-instance-count" role="2.44"><primary sortas="type_get_instance_count">g_type_get_instance_count</primary></indexterm>
<programlisting language="C"><link linkend="int"><returnvalue>int</returnvalue></link>
g_type_get_instance_count (<parameter><link linkend="GType"><type>GType</type></link> type</parameter>);</programlisting>
<para>Returns the number of instances allocated of the particular type;
this is only available if GLib is built with debugging support and
the instance_count debug flag is set (by setting the GOBJECT_DEBUG
variable to include instance-count).</para>
<refsect3 id="g-type-get-instance-count.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>type</para></entry>
<entry role="parameter_description"><para>a <link linkend="GType"><type>GType</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="g-type-get-instance-count.returns" role="returns">
<title>Returns</title>
<para> the number of instances allocated of the given type;
if instance counts are not available, returns 0.</para>
</refsect3><para role="since">Since: <link linkend="api-index-2.44">2.44</link></para></refsect2>
<refsect2 id="G-DECLARE-FINAL-TYPE:CAPS" role="macro" condition="since:2.44">
<title>G_DECLARE_FINAL_TYPE()</title>
<indexterm zone="G-DECLARE-FINAL-TYPE:CAPS" role="2.44"><primary sortas="DECLARE_FINAL_TYPE">G_DECLARE_FINAL_TYPE</primary></indexterm>
<programlisting language="C">#define             G_DECLARE_FINAL_TYPE(ModuleObjName, module_obj_name, MODULE, OBJ_NAME, ParentName)</programlisting>
<para>A convenience macro for emitting the usual declarations in the header file for a type which is not (at the
present time) intended to be subclassed.</para>
<para>You might use it in a header as follows:</para>
<informalexample><programlisting role="example"><![CDATA[
#ifndef _myapp_window_h_
#define _myapp_window_h_

#include <gtk/gtk.h>

#define MY_APP_TYPE_WINDOW my_app_window_get_type ()
G_DECLARE_FINAL_TYPE (MyAppWindow, my_app_window, MY_APP, WINDOW, GtkWindow)

MyAppWindow *    my_app_window_new    (void);

...

#endif
]]></programlisting></informalexample>
<para></para>
<para>This results in the following things happening:</para>
<itemizedlist>
<listitem>
<para>the usual <link linkend="my-app-window-get-type"><function>my_app_window_get_type()</function></link> function is declared with a return type of <link linkend="GType"><type>GType</type></link></para>
</listitem>
<listitem>
<para>the MyAppWindow types is defined as a typedef of struct _MyAppWindow.  The struct itself is not
defined and should be defined from the .c file before <link linkend="G-DEFINE-TYPE:CAPS"><function>G_DEFINE_TYPE()</function></link> is used.</para>
</listitem>
<listitem>
<para>the <link linkend="MY-APP-WINDOW:CAPS"><function>MY_APP_WINDOW()</function></link> cast is emitted as static inline function along with the <link linkend="MY-APP-IS-WINDOW:CAPS"><function>MY_APP_IS_WINDOW()</function></link> type
checking function</para>
</listitem>
<listitem>
<para>the MyAppWindowClass type is defined as a struct containing GtkWindowClass.  This is done for the
convenience of the person defining the type and should not be considered to be part of the ABI.  In
particular, without a firm declaration of the instance structure, it is not possible to subclass the type
and therefore the fact that the size of the class structure is exposed is not a concern and it can be
freely changed at any point in the future.</para>
</listitem>
<listitem>
<para>g_autoptr() support being added for your type, based on the type of your parent class</para>
</listitem>
</itemizedlist>
<para>You can only use this function if your parent type also supports <link linkend="g-autoptr"><function>g_autoptr()</function></link>.</para>
<para>Because the type macro (MY_APP_TYPE_WINDOW in the above example) is not a callable, you must continue to
manually define this as a macro for yourself.</para>
<para>The declaration of the <link linkend="get-type"><function>_get_type()</function></link> function is the first thing emitted by the macro.  This allows this macro
to be used in the usual way with export control and API versioning macros.</para>
<para>If you want to declare your own class structure, use <link linkend="G-DECLARE-DERIVABLE-TYPE:CAPS"><function>G_DECLARE_DERIVABLE_TYPE()</function></link>.</para>
<para>If you are writing a library, it is important to note that it is possible to convert a type from using
<link linkend="G-DECLARE-FINAL-TYPE:CAPS"><function>G_DECLARE_FINAL_TYPE()</function></link> to <link linkend="G-DECLARE-DERIVABLE-TYPE:CAPS"><function>G_DECLARE_DERIVABLE_TYPE()</function></link> without breaking API or ABI.  As a precaution, you
should therefore use <link linkend="G-DECLARE-FINAL-TYPE:CAPS"><function>G_DECLARE_FINAL_TYPE()</function></link> until you are sure that it makes sense for your class to be
subclassed.  Once a class structure has been exposed it is not possible to change its size or remove or
reorder items without breaking the API and/or ABI.</para>
<refsect3 id="G-DECLARE-FINAL-TYPE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>ModuleObjName</para></entry>
<entry role="parameter_description"><para>The name of the new type, in camel case (like GtkWidget)</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>module_obj_name</para></entry>
<entry role="parameter_description"><para>The name of the new type in lowercase, with words
separated by '_' (like 'gtk_widget')</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>MODULE</para></entry>
<entry role="parameter_description"><para>The name of the module, in all caps (like 'GTK')</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>OBJ_NAME</para></entry>
<entry role="parameter_description"><para>The bare name of the type, in all caps (like 'WIDGET')</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>ParentName</para></entry>
<entry role="parameter_description"><para>the name of the parent type, in camel case (like GtkWidget)</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.44">2.44</link></para></refsect2>
<refsect2 id="G-DECLARE-DERIVABLE-TYPE:CAPS" role="macro" condition="since:2.44">
<title>G_DECLARE_DERIVABLE_TYPE()</title>
<indexterm zone="G-DECLARE-DERIVABLE-TYPE:CAPS" role="2.44"><primary sortas="DECLARE_DERIVABLE_TYPE">G_DECLARE_DERIVABLE_TYPE</primary></indexterm>
<programlisting language="C">#define             G_DECLARE_DERIVABLE_TYPE(ModuleObjName, module_obj_name, MODULE, OBJ_NAME, ParentName)</programlisting>
<para>A convenience macro for emitting the usual declarations in the header file for a type which will is intended
to be subclassed.</para>
<para>You might use it in a header as follows:</para>
<informalexample><programlisting role="example"><![CDATA[
#ifndef _gtk_frobber_h_
#define _gtk_frobber_h_

#define GTK_TYPE_FROBBER gtk_frobber_get_type ()
GDK_AVAILABLE_IN_3_12
G_DECLARE_DERIVABLE_TYPE (GtkFrobber, gtk_frobber, GTK, FROBBER, GtkWidget)

struct _GtkFrobberClass
{
  GtkWidgetClass parent_class;

  void (* handle_frob)  (GtkFrobber *frobber,
                         guint       n_frobs);

  gpointer padding[12];
};

GtkWidget *    gtk_frobber_new   (void);

...

#endif
]]></programlisting></informalexample>
<para></para>
<para>This results in the following things happening:</para>
<itemizedlist>
<listitem>
<para>the usual <link linkend="gtk-frobber-get-type"><function>gtk_frobber_get_type()</function></link> function is declared with a return type of <link linkend="GType"><type>GType</type></link></para>
</listitem>
<listitem>
<para>the GtkFrobber struct is created with GtkWidget as the first and only item.  You are expected to use
a private structure from your .c file to store your instance variables.</para>
</listitem>
<listitem>
<para>the GtkFrobberClass type is defined as a typedef to struct _GtkFrobberClass, which is left undefined.
You should do this from the header file directly after you use the macro.</para>
</listitem>
<listitem>
<para>the <link linkend="GTK-FROBBER:CAPS"><function>GTK_FROBBER()</function></link> and <link linkend="GTK-FROBBER-CLASS:CAPS"><function>GTK_FROBBER_CLASS()</function></link> casts are emitted as static inline functions along with
the <link linkend="GTK-IS-FROBBER:CAPS"><function>GTK_IS_FROBBER()</function></link> and <link linkend="GTK-IS-FROBBER-CLASS:CAPS"><function>GTK_IS_FROBBER_CLASS()</function></link> type checking functions and <link linkend="GTK-FROBBER-GET-CLASS:CAPS"><function>GTK_FROBBER_GET_CLASS()</function></link>
function.</para>
</listitem>
<listitem>
<para>g_autoptr() support being added for your type, based on the type of your parent class</para>
</listitem>
</itemizedlist>
<para>You can only use this function if your parent type also supports <link linkend="g-autoptr"><function>g_autoptr()</function></link>.</para>
<para>Because the type macro (GTK_TYPE_FROBBER in the above example) is not a callable, you must continue to
manually define this as a macro for yourself.</para>
<para>The declaration of the <link linkend="get-type"><function>_get_type()</function></link> function is the first thing emitted by the macro.  This allows this macro
to be used in the usual way with export control and API versioning macros.</para>
<para>If you are writing a library, it is important to note that it is possible to convert a type from using
<link linkend="G-DECLARE-FINAL-TYPE:CAPS"><function>G_DECLARE_FINAL_TYPE()</function></link> to <link linkend="G-DECLARE-DERIVABLE-TYPE:CAPS"><function>G_DECLARE_DERIVABLE_TYPE()</function></link> without breaking API or ABI.  As a precaution, you
should therefore use <link linkend="G-DECLARE-FINAL-TYPE:CAPS"><function>G_DECLARE_FINAL_TYPE()</function></link> until you are sure that it makes sense for your class to be
subclassed.  Once a class structure has been exposed it is not possible to change its size or remove or
reorder items without breaking the API and/or ABI.  If you want to declare your own class structure, use
<link linkend="G-DECLARE-DERIVABLE-TYPE:CAPS"><function>G_DECLARE_DERIVABLE_TYPE()</function></link>.  If you want to declare a class without exposing the class or instance
structures, use <link linkend="G-DECLARE-FINAL-TYPE:CAPS"><function>G_DECLARE_FINAL_TYPE()</function></link>.</para>
<para>If you must use <link linkend="G-DECLARE-DERIVABLE-TYPE:CAPS"><function>G_DECLARE_DERIVABLE_TYPE()</function></link> you should be sure to include some padding at the bottom of your
class structure to leave space for the addition of future virtual functions.</para>
<refsect3 id="G-DECLARE-DERIVABLE-TYPE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>ModuleObjName</para></entry>
<entry role="parameter_description"><para>The name of the new type, in camel case (like GtkWidget)</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>module_obj_name</para></entry>
<entry role="parameter_description"><para>The name of the new type in lowercase, with words
separated by '_' (like 'gtk_widget')</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>MODULE</para></entry>
<entry role="parameter_description"><para>The name of the module, in all caps (like 'GTK')</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>OBJ_NAME</para></entry>
<entry role="parameter_description"><para>The bare name of the type, in all caps (like 'WIDGET')</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>ParentName</para></entry>
<entry role="parameter_description"><para>the name of the parent type, in camel case (like GtkWidget)</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.44">2.44</link></para></refsect2>
<refsect2 id="G-DECLARE-INTERFACE:CAPS" role="macro" condition="since:2.44">
<title>G_DECLARE_INTERFACE()</title>
<indexterm zone="G-DECLARE-INTERFACE:CAPS" role="2.44"><primary sortas="DECLARE_INTERFACE">G_DECLARE_INTERFACE</primary></indexterm>
<programlisting language="C">#define             G_DECLARE_INTERFACE(ModuleObjName, module_obj_name, MODULE, OBJ_NAME, PrerequisiteName)</programlisting>
<para>A convenience macro for emitting the usual declarations in the header file for a GInterface type.</para>
<para>You might use it in a header as follows:</para>
<informalexample><programlisting role="example"><![CDATA[
#ifndef _my_model_h_
#define _my_model_h_

#define MY_TYPE_MODEL my_model_get_type ()
GDK_AVAILABLE_IN_3_12
G_DECLARE_INTERFACE (MyModel, my_model, MY, MODEL, GObject)

struct _MyModelInterface
{
  GTypeInterface g_iface;

  gpointer (* get_item)  (MyModel *model);
};

gpointer my_model_get_item (MyModel *model);

...

#endif
]]></programlisting></informalexample>
<para></para>
<para>This results in the following things happening:</para>
<itemizedlist>
<listitem>
<para>the usual <link linkend="my-model-get-type"><function>my_model_get_type()</function></link> function is declared with a return type of <link linkend="GType"><type>GType</type></link></para>
</listitem>
<listitem>
<para>the MyModelInterface type is defined as a typedef to struct _MyModelInterface,
which is left undefined. You should do this from the header file directly after
you use the macro.</para>
</listitem>
<listitem>
<para>the <link linkend="MY-MODEL:CAPS"><function>MY_MODEL()</function></link> cast is emitted as static inline functions along with
the <link linkend="MY-IS-MODEL:CAPS"><function>MY_IS_MODEL()</function></link> type checking function and <link linkend="MY-MODEL-GET-IFACE:CAPS"><function>MY_MODEL_GET_IFACE()</function></link> function.</para>
</listitem>
<listitem>
<para>g_autoptr() support being added for your type, based on your prerequisite type.</para>
</listitem>
</itemizedlist>
<para>You can only use this function if your prerequisite type also supports <link linkend="g-autoptr"><function>g_autoptr()</function></link>.</para>
<para>Because the type macro (MY_TYPE_MODEL in the above example) is not a callable, you must continue to
manually define this as a macro for yourself.</para>
<para>The declaration of the <link linkend="get-type"><function>_get_type()</function></link> function is the first thing emitted by the macro.  This allows this macro
to be used in the usual way with export control and API versioning macros.</para>
<refsect3 id="G-DECLARE-INTERFACE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>ModuleObjName</para></entry>
<entry role="parameter_description"><para>The name of the new type, in camel case (like GtkWidget)</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>module_obj_name</para></entry>
<entry role="parameter_description"><para>The name of the new type in lowercase, with words
separated by '_' (like 'gtk_widget')</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>MODULE</para></entry>
<entry role="parameter_description"><para>The name of the module, in all caps (like 'GTK')</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>OBJ_NAME</para></entry>
<entry role="parameter_description"><para>The bare name of the type, in all caps (like 'WIDGET')</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>PrerequisiteName</para></entry>
<entry role="parameter_description"><para>the name of the prerequisite type, in camel case (like GtkWidget)</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.44">2.44</link></para></refsect2>
<refsect2 id="G-DEFINE-TYPE:CAPS" role="macro" condition="since:2.4">
<title>G_DEFINE_TYPE()</title>
<indexterm zone="G-DEFINE-TYPE:CAPS" role="2.4"><primary sortas="DEFINE_TYPE">G_DEFINE_TYPE</primary></indexterm>
<programlisting language="C">#define G_DEFINE_TYPE(TN, t_n, T_P)			    G_DEFINE_TYPE_EXTENDED (TN, t_n, T_P, 0, {})
</programlisting>
<para>A convenience macro for type implementations, which declares a class
initialization function, an instance initialization function (see <link linkend="GTypeInfo"><type>GTypeInfo</type></link>
for information about these) and a static variable named <literal>t_n_parent_class</literal>
pointing to the parent class. Furthermore, it defines  a *_get_type() function.
See <link linkend="G-DEFINE-TYPE-EXTENDED:CAPS"><function>G_DEFINE_TYPE_EXTENDED()</function></link> for an example.</para>
<refsect3 id="G-DEFINE-TYPE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TN</para></entry>
<entry role="parameter_description"><para>The name of the new type, in Camel case.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>t_n</para></entry>
<entry role="parameter_description"><para>The name of the new type, in lowercase, with words
separated by '_'.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>T_P</para></entry>
<entry role="parameter_description"><para>The <link linkend="GType"><type>GType</type></link> of the parent type.</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.4">2.4</link></para></refsect2>
<refsect2 id="G-DEFINE-TYPE-WITH-PRIVATE:CAPS" role="macro" condition="since:2.38">
<title>G_DEFINE_TYPE_WITH_PRIVATE()</title>
<indexterm zone="G-DEFINE-TYPE-WITH-PRIVATE:CAPS" role="2.38"><primary sortas="DEFINE_TYPE_WITH_PRIVATE">G_DEFINE_TYPE_WITH_PRIVATE</primary></indexterm>
<programlisting language="C">#define G_DEFINE_TYPE_WITH_PRIVATE(TN, t_n, T_P)            G_DEFINE_TYPE_EXTENDED (TN, t_n, T_P, 0, G_ADD_PRIVATE (TN))
</programlisting>
<para>A convenience macro for type implementations, which declares a class
initialization function, an instance initialization function (see <link linkend="GTypeInfo"><type>GTypeInfo</type></link>
for information about these), a static variable named <literal>t_n_parent_class</literal>
pointing to the parent class, and adds private instance data to the type.
Furthermore, it defines a *_get_type() function. See <link linkend="G-DEFINE-TYPE-EXTENDED:CAPS"><function>G_DEFINE_TYPE_EXTENDED()</function></link>
for an example.</para>
<para>Note that private structs added with this macros must have a struct
name of the form <parameter>TN</parameter>
 Private.</para>
<refsect3 id="G-DEFINE-TYPE-WITH-PRIVATE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TN</para></entry>
<entry role="parameter_description"><para>The name of the new type, in Camel case.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>t_n</para></entry>
<entry role="parameter_description"><para>The name of the new type, in lowercase, with words
separated by '_'.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>T_P</para></entry>
<entry role="parameter_description"><para>The <link linkend="GType"><type>GType</type></link> of the parent type.</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.38">2.38</link></para></refsect2>
<refsect2 id="G-DEFINE-TYPE-WITH-CODE:CAPS" role="macro" condition="since:2.4">
<title>G_DEFINE_TYPE_WITH_CODE()</title>
<indexterm zone="G-DEFINE-TYPE-WITH-CODE:CAPS" role="2.4"><primary sortas="DEFINE_TYPE_WITH_CODE">G_DEFINE_TYPE_WITH_CODE</primary></indexterm>
<programlisting language="C">#define G_DEFINE_TYPE_WITH_CODE(TN, t_n, T_P, _C_)	    _G_DEFINE_TYPE_EXTENDED_BEGIN (TN, t_n, T_P, 0) {_C_;} _G_DEFINE_TYPE_EXTENDED_END()
</programlisting>
<para>A convenience macro for type implementations.  
Similar to <link linkend="G-DEFINE-TYPE:CAPS"><function>G_DEFINE_TYPE()</function></link>, but allows you to insert custom code into the 
*_get_type() function, e.g. interface implementations via <link linkend="G-IMPLEMENT-INTERFACE:CAPS"><function>G_IMPLEMENT_INTERFACE()</function></link>.
See <link linkend="G-DEFINE-TYPE-EXTENDED:CAPS"><function>G_DEFINE_TYPE_EXTENDED()</function></link> for an example.</para>
<refsect3 id="G-DEFINE-TYPE-WITH-CODE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TN</para></entry>
<entry role="parameter_description"><para>The name of the new type, in Camel case.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>t_n</para></entry>
<entry role="parameter_description"><para>The name of the new type in lowercase, with words separated by '_'.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>T_P</para></entry>
<entry role="parameter_description"><para>The <link linkend="GType"><type>GType</type></link> of the parent type.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>_C_</para></entry>
<entry role="parameter_description"><para>Custom code that gets inserted in the *_get_type() function.</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.4">2.4</link></para></refsect2>
<refsect2 id="G-DEFINE-ABSTRACT-TYPE:CAPS" role="macro" condition="since:2.4">
<title>G_DEFINE_ABSTRACT_TYPE()</title>
<indexterm zone="G-DEFINE-ABSTRACT-TYPE:CAPS" role="2.4"><primary sortas="DEFINE_ABSTRACT_TYPE">G_DEFINE_ABSTRACT_TYPE</primary></indexterm>
<programlisting language="C">#define G_DEFINE_ABSTRACT_TYPE(TN, t_n, T_P)		    G_DEFINE_TYPE_EXTENDED (TN, t_n, T_P, G_TYPE_FLAG_ABSTRACT, {})
</programlisting>
<para>A convenience macro for type implementations. 
Similar to <link linkend="G-DEFINE-TYPE:CAPS"><function>G_DEFINE_TYPE()</function></link>, but defines an abstract type. 
See <link linkend="G-DEFINE-TYPE-EXTENDED:CAPS"><function>G_DEFINE_TYPE_EXTENDED()</function></link> for an example.</para>
<refsect3 id="G-DEFINE-ABSTRACT-TYPE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TN</para></entry>
<entry role="parameter_description"><para>The name of the new type, in Camel case.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>t_n</para></entry>
<entry role="parameter_description"><para>The name of the new type, in lowercase, with words
separated by '_'.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>T_P</para></entry>
<entry role="parameter_description"><para>The <link linkend="GType"><type>GType</type></link> of the parent type.</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.4">2.4</link></para></refsect2>
<refsect2 id="G-DEFINE-ABSTRACT-TYPE-WITH-PRIVATE:CAPS" role="macro" condition="since:2.38">
<title>G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE()</title>
<indexterm zone="G-DEFINE-ABSTRACT-TYPE-WITH-PRIVATE:CAPS" role="2.38"><primary sortas="DEFINE_ABSTRACT_TYPE_WITH_PRIVATE">G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE</primary></indexterm>
<programlisting language="C">#define G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE(TN, t_n, T_P)   G_DEFINE_TYPE_EXTENDED (TN, t_n, T_P, G_TYPE_FLAG_ABSTRACT, G_ADD_PRIVATE (TN))
</programlisting>
<para>Similar to <link linkend="G-DEFINE-TYPE-WITH-PRIVATE:CAPS"><function>G_DEFINE_TYPE_WITH_PRIVATE()</function></link>, but defines an abstract type. 
See <link linkend="G-DEFINE-TYPE-EXTENDED:CAPS"><function>G_DEFINE_TYPE_EXTENDED()</function></link> for an example.</para>
<refsect3 id="G-DEFINE-ABSTRACT-TYPE-WITH-PRIVATE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TN</para></entry>
<entry role="parameter_description"><para>The name of the new type, in Camel case.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>t_n</para></entry>
<entry role="parameter_description"><para>The name of the new type, in lowercase, with words
separated by '_'.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>T_P</para></entry>
<entry role="parameter_description"><para>The <link linkend="GType"><type>GType</type></link> of the parent type.</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.38">2.38</link></para></refsect2>
<refsect2 id="G-DEFINE-ABSTRACT-TYPE-WITH-CODE:CAPS" role="macro" condition="since:2.4">
<title>G_DEFINE_ABSTRACT_TYPE_WITH_CODE()</title>
<indexterm zone="G-DEFINE-ABSTRACT-TYPE-WITH-CODE:CAPS" role="2.4"><primary sortas="DEFINE_ABSTRACT_TYPE_WITH_CODE">G_DEFINE_ABSTRACT_TYPE_WITH_CODE</primary></indexterm>
<programlisting language="C">#define G_DEFINE_ABSTRACT_TYPE_WITH_CODE(TN, t_n, T_P, _C_) _G_DEFINE_TYPE_EXTENDED_BEGIN (TN, t_n, T_P, G_TYPE_FLAG_ABSTRACT) {_C_;} _G_DEFINE_TYPE_EXTENDED_END()
</programlisting>
<para>A convenience macro for type implementations.
Similar to <link linkend="G-DEFINE-TYPE-WITH-CODE:CAPS"><function>G_DEFINE_TYPE_WITH_CODE()</function></link>, but defines an abstract type and
allows you to insert custom code into the *_get_type() function, e.g.
interface implementations  via <link linkend="G-IMPLEMENT-INTERFACE:CAPS"><function>G_IMPLEMENT_INTERFACE()</function></link>.
See <link linkend="G-DEFINE-TYPE-EXTENDED:CAPS"><function>G_DEFINE_TYPE_EXTENDED()</function></link> for an example.</para>
<refsect3 id="G-DEFINE-ABSTRACT-TYPE-WITH-CODE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TN</para></entry>
<entry role="parameter_description"><para>The name of the new type, in Camel case.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>t_n</para></entry>
<entry role="parameter_description"><para>The name of the new type, in lowercase, with words
separated by '_'.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>T_P</para></entry>
<entry role="parameter_description"><para>The <link linkend="GType"><type>GType</type></link> of the parent type.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>_C_</para></entry>
<entry role="parameter_description"><para>Custom code that gets inserted in the <parameter><link linkend="type-name-get-type"><function>type_name_get_type()</function></link></parameter>
function.</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.4">2.4</link></para></refsect2>
<refsect2 id="G-ADD-PRIVATE:CAPS" role="macro" condition="since:2.38">
<title>G_ADD_PRIVATE()</title>
<indexterm zone="G-ADD-PRIVATE:CAPS" role="2.38"><primary sortas="ADD_PRIVATE">G_ADD_PRIVATE</primary></indexterm>
<programlisting language="C">#define             G_ADD_PRIVATE(TypeName)</programlisting>
<para>A convenience macro to ease adding private data to instances of a new type
in the <parameter>_C_</parameter>
 section of <link linkend="G-DEFINE-TYPE-WITH-CODE:CAPS"><function>G_DEFINE_TYPE_WITH_CODE()</function></link> or
<link linkend="G-DEFINE-ABSTRACT-TYPE-WITH-CODE:CAPS"><function>G_DEFINE_ABSTRACT_TYPE_WITH_CODE()</function></link>.</para>
<para>For instance:</para>
<informalexample><programlisting role="example"><![CDATA[
  typedef struct _MyObject MyObject;
  typedef struct _MyObjectClass MyObjectClass;

  typedef struct {
    gint foo;
    gint bar;
  } MyObjectPrivate;

  G_DEFINE_TYPE_WITH_CODE (MyObject, my_object, G_TYPE_OBJECT,
                           G_ADD_PRIVATE (MyObject))
]]></programlisting></informalexample>
<para></para>
<para>Will add MyObjectPrivate as the private data to any instance of the MyObject
type.</para>
<para>G_DEFINE_TYPE_* macros will automatically create a private function
based on the arguments to this macro, which can be used to safely
retrieve the private data from an instance of the type; for instance:</para>
<informalexample><programlisting role="example"><![CDATA[
  gint
  my_object_get_foo (MyObject *obj)
  {
    MyObjectPrivate *priv = my_object_get_instance_private (obj);

    g_return_val_if_fail (MY_IS_OBJECT (obj), 0);

    return priv->foo;
  }

  void
  my_object_set_bar (MyObject *obj,
                     gint      bar)
  {
    MyObjectPrivate *priv = my_object_get_instance_private (obj);

    g_return_if_fail (MY_IS_OBJECT (obj));

    if (priv->bar != bar)
      priv->bar = bar;
  }
]]></programlisting></informalexample>
<para></para>
<para>Note that this macro can only be used together with the G_DEFINE_TYPE_*
macros, since it depends on variable names from those macros.</para>
<para>Also note that private structs added with these macros must have a struct
name of the form <literal>TypeNamePrivate</literal>.</para>
<para>It is safe to call _get_instance_private on <link linkend="NULL:CAPS"><literal>NULL</literal></link> or invalid object since
it's only adding an offset to the instance pointer. In that case the returned
pointer must not be dereferenced.</para>
<refsect3 id="G-ADD-PRIVATE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TypeName</para></entry>
<entry role="parameter_description"><para>the name of the type in CamelCase</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.38">2.38</link></para></refsect2>
<refsect2 id="G-PRIVATE-OFFSET:CAPS" role="macro" condition="since:2.38">
<title>G_PRIVATE_OFFSET()</title>
<indexterm zone="G-PRIVATE-OFFSET:CAPS" role="2.38"><primary sortas="PRIVATE_OFFSET">G_PRIVATE_OFFSET</primary></indexterm>
<programlisting language="C">#define             G_PRIVATE_OFFSET(TypeName, field)</programlisting>
<para>Evaluates to the offset of the <parameter>field</parameter>
 inside the instance private data
structure for <parameter>TypeName</parameter>
.</para>
<para>Note that this macro can only be used together with the G_DEFINE_TYPE_*
and <link linkend="G-ADD-PRIVATE:CAPS"><function>G_ADD_PRIVATE()</function></link> macros, since it depends on variable names from
those macros.</para>
<refsect3 id="G-PRIVATE-OFFSET.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TypeName</para></entry>
<entry role="parameter_description"><para>the name of the type in CamelCase</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>field</para></entry>
<entry role="parameter_description"><para>the name of the field in the private data structure</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.38">2.38</link></para></refsect2>
<refsect2 id="G-PRIVATE-FIELD:CAPS" role="macro" condition="since:2.38">
<title>G_PRIVATE_FIELD()</title>
<indexterm zone="G-PRIVATE-FIELD:CAPS" role="2.38"><primary sortas="PRIVATE_FIELD">G_PRIVATE_FIELD</primary></indexterm>
<programlisting language="C">#define             G_PRIVATE_FIELD(TypeName, inst, field_type, field_name)</programlisting>
<para>Evaluates to the <parameter>field_name</parameter>
 inside the <parameter>inst</parameter>
 private data
structure for <parameter>TypeName</parameter>
.</para>
<para>Note that this macro can only be used together with the G_DEFINE_TYPE_*
and <link linkend="G-ADD-PRIVATE:CAPS"><function>G_ADD_PRIVATE()</function></link> macros, since it depends on variable names from
those macros.</para>
<refsect3 id="G-PRIVATE-FIELD.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TypeName</para></entry>
<entry role="parameter_description"><para>the name of the type in CamelCase</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>inst</para></entry>
<entry role="parameter_description"><para>the instance of <parameter>TypeName</parameter>
you wish to access</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>field_type</para></entry>
<entry role="parameter_description"><para>the type of the field in the private data structure</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>field_name</para></entry>
<entry role="parameter_description"><para>the name of the field in the private data structure</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.38">2.38</link></para></refsect2>
<refsect2 id="G-PRIVATE-FIELD-P:CAPS" role="macro" condition="since:2.38">
<title>G_PRIVATE_FIELD_P()</title>
<indexterm zone="G-PRIVATE-FIELD-P:CAPS" role="2.38"><primary sortas="PRIVATE_FIELD_P">G_PRIVATE_FIELD_P</primary></indexterm>
<programlisting language="C">#define             G_PRIVATE_FIELD_P(TypeName, inst, field_name)</programlisting>
<para>Evaluates to a pointer to the <parameter>field_name</parameter>
 inside the <parameter>inst</parameter>
 private data
structure for <parameter>TypeName</parameter>
.</para>
<para>Note that this macro can only be used together with the G_DEFINE_TYPE_*
and <link linkend="G-ADD-PRIVATE:CAPS"><function>G_ADD_PRIVATE()</function></link> macros, since it depends on variable names from
those macros.</para>
<refsect3 id="G-PRIVATE-FIELD-P.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TypeName</para></entry>
<entry role="parameter_description"><para>the name of the type in CamelCase</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>inst</para></entry>
<entry role="parameter_description"><para>the instance of <parameter>TypeName</parameter>
you wish to access</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>field_name</para></entry>
<entry role="parameter_description"><para>the name of the field in the private data structure</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.38">2.38</link></para></refsect2>
<refsect2 id="G-DEFINE-INTERFACE:CAPS" role="macro" condition="since:2.24">
<title>G_DEFINE_INTERFACE()</title>
<indexterm zone="G-DEFINE-INTERFACE:CAPS" role="2.24"><primary sortas="DEFINE_INTERFACE">G_DEFINE_INTERFACE</primary></indexterm>
<programlisting language="C">#define G_DEFINE_INTERFACE(TN, t_n, T_P)		    G_DEFINE_INTERFACE_WITH_CODE(TN, t_n, T_P, ;)
</programlisting>
<para>A convenience macro for <link linkend="GTypeInterface"><type>GTypeInterface</type></link> definitions, which declares
a default vtable initialization function and defines a *_get_type()
function.</para>
<para>The macro expects the interface initialization function to have the
name <literal>t_n ## _default_init</literal>, and the interface structure to have the
name <literal>TN ## Interface</literal>.</para>
<refsect3 id="G-DEFINE-INTERFACE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TN</para></entry>
<entry role="parameter_description"><para>The name of the new type, in Camel case.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>t_n</para></entry>
<entry role="parameter_description"><para>The name of the new type, in lowercase, with words separated by '_'.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>T_P</para></entry>
<entry role="parameter_description"><para>The <link linkend="GType"><type>GType</type></link> of the prerequisite type for the interface, or 0
(<link linkend="G-TYPE-INVALID:CAPS"><literal>G_TYPE_INVALID</literal></link>) for no prerequisite type.</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.24">2.24</link></para></refsect2>
<refsect2 id="G-DEFINE-INTERFACE-WITH-CODE:CAPS" role="macro" condition="since:2.24">
<title>G_DEFINE_INTERFACE_WITH_CODE()</title>
<indexterm zone="G-DEFINE-INTERFACE-WITH-CODE:CAPS" role="2.24"><primary sortas="DEFINE_INTERFACE_WITH_CODE">G_DEFINE_INTERFACE_WITH_CODE</primary></indexterm>
<programlisting language="C">#define G_DEFINE_INTERFACE_WITH_CODE(TN, t_n, T_P, _C_)     _G_DEFINE_INTERFACE_EXTENDED_BEGIN(TN, t_n, T_P) {_C_;} _G_DEFINE_INTERFACE_EXTENDED_END()
</programlisting>
<para>A convenience macro for <link linkend="GTypeInterface"><type>GTypeInterface</type></link> definitions. Similar to
<link linkend="G-DEFINE-INTERFACE:CAPS"><function>G_DEFINE_INTERFACE()</function></link>, but allows you to insert custom code into the
*_get_type() function, e.g. additional interface implementations
via <link linkend="G-IMPLEMENT-INTERFACE:CAPS"><function>G_IMPLEMENT_INTERFACE()</function></link>, or additional prerequisite types. See
<link linkend="G-DEFINE-TYPE-EXTENDED:CAPS"><function>G_DEFINE_TYPE_EXTENDED()</function></link> for a similar example using
<link linkend="G-DEFINE-TYPE-WITH-CODE:CAPS"><function>G_DEFINE_TYPE_WITH_CODE()</function></link>.</para>
<refsect3 id="G-DEFINE-INTERFACE-WITH-CODE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TN</para></entry>
<entry role="parameter_description"><para>The name of the new type, in Camel case.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>t_n</para></entry>
<entry role="parameter_description"><para>The name of the new type, in lowercase, with words separated by '_'.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>T_P</para></entry>
<entry role="parameter_description"><para>The <link linkend="GType"><type>GType</type></link> of the prerequisite type for the interface, or 0
(<link linkend="G-TYPE-INVALID:CAPS"><literal>G_TYPE_INVALID</literal></link>) for no prerequisite type.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>_C_</para></entry>
<entry role="parameter_description"><para>Custom code that gets inserted in the *_get_type() function.</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.24">2.24</link></para></refsect2>
<refsect2 id="G-IMPLEMENT-INTERFACE:CAPS" role="macro" condition="since:2.4">
<title>G_IMPLEMENT_INTERFACE()</title>
<indexterm zone="G-IMPLEMENT-INTERFACE:CAPS" role="2.4"><primary sortas="IMPLEMENT_INTERFACE">G_IMPLEMENT_INTERFACE</primary></indexterm>
<programlisting language="C">#define             G_IMPLEMENT_INTERFACE(TYPE_IFACE, iface_init)</programlisting>
<para>A convenience macro to ease interface addition in the <literal>_C_</literal> section
of <link linkend="G-DEFINE-TYPE-WITH-CODE:CAPS"><function>G_DEFINE_TYPE_WITH_CODE()</function></link> or <link linkend="G-DEFINE-ABSTRACT-TYPE-WITH-CODE:CAPS"><function>G_DEFINE_ABSTRACT_TYPE_WITH_CODE()</function></link>.
See <link linkend="G-DEFINE-TYPE-EXTENDED:CAPS"><function>G_DEFINE_TYPE_EXTENDED()</function></link> for an example.</para>
<para>Note that this macro can only be used together with the G_DEFINE_TYPE_*
macros, since it depends on variable names from those macros.</para>
<refsect3 id="G-IMPLEMENT-INTERFACE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TYPE_IFACE</para></entry>
<entry role="parameter_description"><para>The <link linkend="GType"><type>GType</type></link> of the interface to add</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>iface_init</para></entry>
<entry role="parameter_description"><para>The interface init function</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.4">2.4</link></para></refsect2>
<refsect2 id="G-DEFINE-TYPE-EXTENDED:CAPS" role="macro" condition="since:2.4">
<title>G_DEFINE_TYPE_EXTENDED()</title>
<indexterm zone="G-DEFINE-TYPE-EXTENDED:CAPS" role="2.4"><primary sortas="DEFINE_TYPE_EXTENDED">G_DEFINE_TYPE_EXTENDED</primary></indexterm>
<programlisting language="C">#define G_DEFINE_TYPE_EXTENDED(TN, t_n, T_P, _f_, _C_)	    _G_DEFINE_TYPE_EXTENDED_BEGIN (TN, t_n, T_P, _f_) {_C_;} _G_DEFINE_TYPE_EXTENDED_END()
</programlisting>
<para>The most general convenience macro for type implementations, on which
<link linkend="G-DEFINE-TYPE:CAPS"><function>G_DEFINE_TYPE()</function></link>, etc are based.</para>
<informalexample><programlisting role="example"><![CDATA[
G_DEFINE_TYPE_EXTENDED (GtkGadget,
                        gtk_gadget,
                        GTK_TYPE_WIDGET,
                        0,
                        G_IMPLEMENT_INTERFACE (TYPE_GIZMO,
                                               gtk_gadget_gizmo_init));
]]></programlisting></informalexample>
<para>
expands to</para>
<informalexample><programlisting role="example"><![CDATA[
static void     gtk_gadget_init       (GtkGadget      *self);
static void     gtk_gadget_class_init (GtkGadgetClass *klass);
static gpointer gtk_gadget_parent_class = NULL;
static void     gtk_gadget_class_intern_init (gpointer klass)
{
  gtk_gadget_parent_class = g_type_class_peek_parent (klass);
  gtk_gadget_class_init ((GtkGadgetClass*) klass);
}

GType
gtk_gadget_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;
  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      GType g_define_type_id =
        g_type_register_static_simple (GTK_TYPE_WIDGET,
                                       g_intern_static_string ("GtkGadget"),
                                       sizeof (GtkGadgetClass),
                                       (GClassInitFunc) gtk_gadget_class_intern_init,
                                       sizeof (GtkGadget),
                                       (GInstanceInitFunc) gtk_gadget_init,
                                       0);
      {
        const GInterfaceInfo g_implement_interface_info = {
          (GInterfaceInitFunc) gtk_gadget_gizmo_init
        };
        g_type_add_interface_static (g_define_type_id, TYPE_GIZMO, &g_implement_interface_info);
      }
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }
  return g_define_type_id__volatile;
}
]]></programlisting></informalexample>
<para>
The only pieces which have to be manually provided are the definitions of
the instance and class structure and the definitions of the instance and
class init functions.</para>
<refsect3 id="G-DEFINE-TYPE-EXTENDED.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TN</para></entry>
<entry role="parameter_description"><para>The name of the new type, in Camel case.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>t_n</para></entry>
<entry role="parameter_description"><para>The name of the new type, in lowercase, with words
separated by '_'.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>T_P</para></entry>
<entry role="parameter_description"><para>The <link linkend="GType"><type>GType</type></link> of the parent type.</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>_f_</para></entry>
<entry role="parameter_description"><para><link linkend="GTypeFlags"><type>GTypeFlags</type></link> to pass to <link linkend="g-type-register-static"><function>g_type_register_static()</function></link></para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>_C_</para></entry>
<entry role="parameter_description"><para>Custom code that gets inserted in the *_get_type() function.</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.4">2.4</link></para></refsect2>
<refsect2 id="G-DEFINE-BOXED-TYPE:CAPS" role="macro" condition="since:2.26">
<title>G_DEFINE_BOXED_TYPE()</title>
<indexterm zone="G-DEFINE-BOXED-TYPE:CAPS" role="2.26"><primary sortas="DEFINE_BOXED_TYPE">G_DEFINE_BOXED_TYPE</primary></indexterm>
<programlisting language="C">#define G_DEFINE_BOXED_TYPE(TypeName, type_name, copy_func, free_func) G_DEFINE_BOXED_TYPE_WITH_CODE (TypeName, type_name, copy_func, free_func, {})
</programlisting>
<para>A convenience macro for boxed type implementations, which defines a
<link linkend="type-name-get-type"><function>type_name_get_type()</function></link> function registering the boxed type.</para>
<refsect3 id="G-DEFINE-BOXED-TYPE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TypeName</para></entry>
<entry role="parameter_description"><para>The name of the new type, in Camel case</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>type_name</para></entry>
<entry role="parameter_description"><para>The name of the new type, in lowercase, with words
separated by '_'</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>copy_func</para></entry>
<entry role="parameter_description"><para>the <link linkend="GBoxedCopyFunc"><type>GBoxedCopyFunc</type></link> for the new type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>free_func</para></entry>
<entry role="parameter_description"><para>the <link linkend="GBoxedFreeFunc"><type>GBoxedFreeFunc</type></link> for the new type</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.26">2.26</link></para></refsect2>
<refsect2 id="G-DEFINE-BOXED-TYPE-WITH-CODE:CAPS" role="macro" condition="since:2.26">
<title>G_DEFINE_BOXED_TYPE_WITH_CODE()</title>
<indexterm zone="G-DEFINE-BOXED-TYPE-WITH-CODE:CAPS" role="2.26"><primary sortas="DEFINE_BOXED_TYPE_WITH_CODE">G_DEFINE_BOXED_TYPE_WITH_CODE</primary></indexterm>
<programlisting language="C">#define G_DEFINE_BOXED_TYPE_WITH_CODE(TypeName, type_name, copy_func, free_func, _C_) _G_DEFINE_BOXED_TYPE_BEGIN (TypeName, type_name, copy_func, free_func) {_C_;} _G_DEFINE_TYPE_EXTENDED_END()
</programlisting>
<para>A convenience macro for boxed type implementations.
Similar to <link linkend="G-DEFINE-BOXED-TYPE:CAPS"><function>G_DEFINE_BOXED_TYPE()</function></link>, but allows to insert custom code into the
<link linkend="type-name-get-type"><function>type_name_get_type()</function></link> function, e.g. to register value transformations with
<link linkend="g-value-register-transform-func"><function>g_value_register_transform_func()</function></link>, for instance:</para>
<informalexample><programlisting role="example"><![CDATA[
G_DEFINE_BOXED_TYPE_WITH_CODE (GdkRectangle, gdk_rectangle,
                               gdk_rectangle_copy,
                               gdk_rectangle_free,
                               register_rectangle_transform_funcs (g_define_type_id))
]]></programlisting></informalexample>
<para></para>
<para>Similarly to the <link linkend="G-DEFINE-TYPE:CAPS"><literal>G_DEFINE_TYPE</literal></link> family of macros, the <link linkend="GType"><type>GType</type></link> of the newly
defined boxed type is exposed in the <literal>g_define_type_id</literal> variable.</para>
<refsect3 id="G-DEFINE-BOXED-TYPE-WITH-CODE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TypeName</para></entry>
<entry role="parameter_description"><para>The name of the new type, in Camel case</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>type_name</para></entry>
<entry role="parameter_description"><para>The name of the new type, in lowercase, with words
separated by '_'</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>copy_func</para></entry>
<entry role="parameter_description"><para>the <link linkend="GBoxedCopyFunc"><type>GBoxedCopyFunc</type></link> for the new type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>free_func</para></entry>
<entry role="parameter_description"><para>the <link linkend="GBoxedFreeFunc"><type>GBoxedFreeFunc</type></link> for the new type</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>_C_</para></entry>
<entry role="parameter_description"><para>Custom code that gets inserted in the *_get_type() function</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.26">2.26</link></para></refsect2>
<refsect2 id="G-DEFINE-POINTER-TYPE:CAPS" role="macro" condition="since:2.26">
<title>G_DEFINE_POINTER_TYPE()</title>
<indexterm zone="G-DEFINE-POINTER-TYPE:CAPS" role="2.26"><primary sortas="DEFINE_POINTER_TYPE">G_DEFINE_POINTER_TYPE</primary></indexterm>
<programlisting language="C">#define G_DEFINE_POINTER_TYPE(TypeName, type_name) G_DEFINE_POINTER_TYPE_WITH_CODE (TypeName, type_name, {})
</programlisting>
<para>A convenience macro for pointer type implementations, which defines a
<link linkend="type-name-get-type"><function>type_name_get_type()</function></link> function registering the pointer type.</para>
<refsect3 id="G-DEFINE-POINTER-TYPE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TypeName</para></entry>
<entry role="parameter_description"><para>The name of the new type, in Camel case</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>type_name</para></entry>
<entry role="parameter_description"><para>The name of the new type, in lowercase, with words
separated by '_'</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.26">2.26</link></para></refsect2>
<refsect2 id="G-DEFINE-POINTER-TYPE-WITH-CODE:CAPS" role="macro" condition="since:2.26">
<title>G_DEFINE_POINTER_TYPE_WITH_CODE()</title>
<indexterm zone="G-DEFINE-POINTER-TYPE-WITH-CODE:CAPS" role="2.26"><primary sortas="DEFINE_POINTER_TYPE_WITH_CODE">G_DEFINE_POINTER_TYPE_WITH_CODE</primary></indexterm>
<programlisting language="C">#define G_DEFINE_POINTER_TYPE_WITH_CODE(TypeName, type_name, _C_) _G_DEFINE_POINTER_TYPE_BEGIN (TypeName, type_name) {_C_;} _G_DEFINE_TYPE_EXTENDED_END()
</programlisting>
<para>A convenience macro for pointer type implementations.
Similar to <link linkend="G-DEFINE-POINTER-TYPE:CAPS"><function>G_DEFINE_POINTER_TYPE()</function></link>, but allows to insert
custom code into the <link linkend="type-name-get-type"><function>type_name_get_type()</function></link> function.</para>
<refsect3 id="G-DEFINE-POINTER-TYPE-WITH-CODE.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>TypeName</para></entry>
<entry role="parameter_description"><para>The name of the new type, in Camel case</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>type_name</para></entry>
<entry role="parameter_description"><para>The name of the new type, in lowercase, with words
separated by '_'</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>_C_</para></entry>
<entry role="parameter_description"><para>Custom code that gets inserted in the *_get_type() function</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-2.26">2.26</link></para></refsect2>

</refsect1>
<refsect1 id="gobject-Type-Information.other_details" role="details">
<title role="details.title">Types and Values</title>
<refsect2 id="GType" role="typedef">
<title>GType</title>
<indexterm zone="GType"><primary sortas="Type">GType</primary></indexterm>
<para>A numerical value which represents the unique identifier of a registered
type.</para>
</refsect2>
<refsect2 id="G-TYPE-FUNDAMENTAL-MAX:CAPS" role="macro">
<title>G_TYPE_FUNDAMENTAL_MAX</title>
<indexterm zone="G-TYPE-FUNDAMENTAL-MAX:CAPS"><primary sortas="TYPE_FUNDAMENTAL_MAX">G_TYPE_FUNDAMENTAL_MAX</primary></indexterm>
<programlisting language="C">#define&#160;G_TYPE_FUNDAMENTAL_MAX		(255 &lt;&lt; G_TYPE_FUNDAMENTAL_SHIFT)
</programlisting>
<para>An integer constant that represents the number of identifiers reserved
for types that are assigned at compile-time.</para>
</refsect2>
<refsect2 id="GTypeInterface" role="struct">
<title>struct GTypeInterface</title>
<indexterm zone="GTypeInterface"><primary sortas="TypeInterface">GTypeInterface</primary></indexterm>
<programlisting language="C">struct GTypeInterface {
};
</programlisting>
<para>An opaque structure used as the base of all interface types.</para>
</refsect2>
<refsect2 id="GTypeInstance" role="struct">
<title>struct GTypeInstance</title>
<indexterm zone="GTypeInstance"><primary sortas="TypeInstance">GTypeInstance</primary></indexterm>
<programlisting language="C">struct GTypeInstance {
};
</programlisting>
<para>An opaque structure used as the base of all type instances.</para>
</refsect2>
<refsect2 id="GTypeClass" role="struct">
<title>struct GTypeClass</title>
<indexterm zone="GTypeClass"><primary sortas="TypeClass">GTypeClass</primary></indexterm>
<programlisting language="C">struct GTypeClass {
};
</programlisting>
<para>An opaque structure used as the base of all classes.</para>
</refsect2>
<refsect2 id="GTypeInfo" role="struct">
<title>struct GTypeInfo</title>
<indexterm zone="GTypeInfo"><primary sortas="TypeInfo">GTypeInfo</primary></indexterm>
<programlisting language="C">struct GTypeInfo {
  /* interface types, classed types, instantiated types */
  guint16                class_size;
  
  GBaseInitFunc          base_init;
  GBaseFinalizeFunc      base_finalize;
  
  /* interface types, classed types, instantiated types */
  GClassInitFunc         class_init;
  GClassFinalizeFunc     class_finalize;
  gconstpointer          class_data;
  
  /* instantiated types */
  guint16                instance_size;
  guint16                n_preallocs;
  GInstanceInitFunc      instance_init;
  
  /* value handling */
  const GTypeValueTable&#160;*value_table;
};
</programlisting>
<para>This structure is used to provide the type system with the information
required to initialize and destruct (finalize) a type's class and
its instances.</para>
<para>The initialized structure is passed to the <link linkend="g-type-register-static"><function>g_type_register_static()</function></link> function
(or is copied into the provided <link linkend="GTypeInfo"><type>GTypeInfo</type></link> structure in the
<link linkend="g-type-plugin-complete-type-info"><function>g_type_plugin_complete_type_info()</function></link>). The type system will perform a deep
copy of this structure, so its memory does not need to be persistent
across invocation of <link linkend="g-type-register-static"><function>g_type_register_static()</function></link>.</para>
<refsect3 id="GTypeInfo.members" role="struct_members">
<title>Members</title>
<informaltable role="struct_members_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="struct_members_name" colwidth="300px"/>
<colspec colname="struct_members_description"/>
<colspec colname="struct_members_annotations" colwidth="200px"/>
<tbody>
<row role="member"><entry role="struct_member_name"><para><link linkend="guint16"><type>guint16</type></link>&#160;<structfield id="GTypeInfo.class-size">class_size</structfield>;</para></entry>
<entry role="struct_member_description"><para>Size of the class structure (required for interface, classed and instantiatable types)</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><link linkend="GBaseInitFunc"><type>GBaseInitFunc</type></link>&#160;<structfield id="GTypeInfo.base-init">base_init</structfield>;</para></entry>
<entry role="struct_member_description"><para>Location of the base initialization function (optional)</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><link linkend="GBaseFinalizeFunc"><type>GBaseFinalizeFunc</type></link>&#160;<structfield id="GTypeInfo.base-finalize">base_finalize</structfield>;</para></entry>
<entry role="struct_member_description"><para>Location of the base finalization function (optional)</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><link linkend="GClassInitFunc"><type>GClassInitFunc</type></link>&#160;<structfield id="GTypeInfo.class-init">class_init</structfield>;</para></entry>
<entry role="struct_member_description"><para>Location of the class initialization function for
classed and instantiatable types. Location of the default vtable
inititalization function for interface types. (optional) This function
is used both to fill in virtual functions in the class or default vtable,
and to do type-specific setup such as registering signals and object
properties.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><link linkend="GClassFinalizeFunc"><type>GClassFinalizeFunc</type></link>&#160;<structfield id="GTypeInfo.class-finalize">class_finalize</structfield>;</para></entry>
<entry role="struct_member_description"><para>Location of the class finalization function for
classed and instantiatable types. Location of the default vtable
finalization function for interface types. (optional)</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><link linkend="gconstpointer"><type>gconstpointer</type></link>&#160;<structfield id="GTypeInfo.class-data">class_data</structfield>;</para></entry>
<entry role="struct_member_description"><para>User-supplied data passed to the class init/finalize functions</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><link linkend="guint16"><type>guint16</type></link>&#160;<structfield id="GTypeInfo.instance-size">instance_size</structfield>;</para></entry>
<entry role="struct_member_description"><para>Size of the instance (object) structure (required for instantiatable types only)</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><link linkend="guint16"><type>guint16</type></link>&#160;<structfield id="GTypeInfo.n-preallocs">n_preallocs</structfield>;</para></entry>
<entry role="struct_member_description"><para>Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the <link linkend="glib-Memory-Slices">slice allocator</link> now.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><link linkend="GInstanceInitFunc"><type>GInstanceInitFunc</type></link>&#160;<structfield id="GTypeInfo.instance-init">instance_init</structfield>;</para></entry>
<entry role="struct_member_description"><para>Location of the instance initialization function (optional, for instantiatable types only)</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para>const&#160;<link linkend="GTypeValueTable"><type>GTypeValueTable</type></link>&#160;*<structfield id="GTypeInfo.value-table">value_table</structfield>;</para></entry>
<entry role="struct_member_description"><para>A <link linkend="GTypeValueTable"><type>GTypeValueTable</type></link> function table for generic handling of GValues
of this type (usually only useful for fundamental types)</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
</tbody></tgroup></informaltable>
</refsect3>
</refsect2>
<refsect2 id="GTypeFundamentalInfo" role="struct">
<title>struct GTypeFundamentalInfo</title>
<indexterm zone="GTypeFundamentalInfo"><primary sortas="TypeFundamentalInfo">GTypeFundamentalInfo</primary></indexterm>
<programlisting language="C">struct GTypeFundamentalInfo {
  GTypeFundamentalFlags  type_flags;
};
</programlisting>
<para>A structure that provides information to the type system which is
used specifically for managing fundamental types.</para>
<refsect3 id="GTypeFundamentalInfo.members" role="struct_members">
<title>Members</title>
<informaltable role="struct_members_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="struct_members_name" colwidth="300px"/>
<colspec colname="struct_members_description"/>
<colspec colname="struct_members_annotations" colwidth="200px"/>
<tbody>
<row role="member"><entry role="struct_member_name"><para><link linkend="GTypeFundamentalFlags"><type>GTypeFundamentalFlags</type></link>&#160;<structfield id="GTypeFundamentalInfo.type-flags">type_flags</structfield>;</para></entry>
<entry role="struct_member_description"><para><link linkend="GTypeFundamentalFlags"><type>GTypeFundamentalFlags</type></link> describing the characteristics of the fundamental type</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
</tbody></tgroup></informaltable>
</refsect3>
</refsect2>
<refsect2 id="GInterfaceInfo" role="struct">
<title>struct GInterfaceInfo</title>
<indexterm zone="GInterfaceInfo"><primary sortas="InterfaceInfo">GInterfaceInfo</primary></indexterm>
<programlisting language="C">struct GInterfaceInfo {
  GInterfaceInitFunc     interface_init;
  GInterfaceFinalizeFunc interface_finalize;
  gpointer               interface_data;
};
</programlisting>
<para>A structure that provides information to the type system which is
used specifically for managing interface types.</para>
<refsect3 id="GInterfaceInfo.members" role="struct_members">
<title>Members</title>
<informaltable role="struct_members_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="struct_members_name" colwidth="300px"/>
<colspec colname="struct_members_description"/>
<colspec colname="struct_members_annotations" colwidth="200px"/>
<tbody>
<row role="member"><entry role="struct_member_name"><para><link linkend="GInterfaceInitFunc"><type>GInterfaceInitFunc</type></link>&#160;<structfield id="GInterfaceInfo.interface-init">interface_init</structfield>;</para></entry>
<entry role="struct_member_description"><para>location of the interface initialization function</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><link linkend="GInterfaceFinalizeFunc"><type>GInterfaceFinalizeFunc</type></link>&#160;<structfield id="GInterfaceInfo.interface-finalize">interface_finalize</structfield>;</para></entry>
<entry role="struct_member_description"><para>location of the interface finalization function</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><link linkend="gpointer"><type>gpointer</type></link>&#160;<structfield id="GInterfaceInfo.interface-data">interface_data</structfield>;</para></entry>
<entry role="struct_member_description"><para>user-supplied data passed to the interface init/finalize functions</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
</tbody></tgroup></informaltable>
</refsect3>
</refsect2>
<refsect2 id="GTypeValueTable" role="struct">
<title>struct GTypeValueTable</title>
<indexterm zone="GTypeValueTable"><primary sortas="TypeValueTable">GTypeValueTable</primary></indexterm>
<programlisting language="C">struct GTypeValueTable {
  void     (*value_init)         (GValue       *value);
  void     (*value_free)         (GValue       *value);
  void     (*value_copy)         (const GValue *src_value,
				  GValue       *dest_value);
  /* varargs functionality (optional) */
  gpointer (*value_peek_pointer) (const GValue *value);
  const gchar *collect_format;
  gchar*   (*collect_value)      (GValue       *value,
				  guint         n_collect_values,
				  GTypeCValue  *collect_values,
				  guint		collect_flags);
  const gchar *lcopy_format;
  gchar*   (*lcopy_value)        (const GValue *value,
				  guint         n_collect_values,
				  GTypeCValue  *collect_values,
				  guint		collect_flags);
};
</programlisting>
<para>The <link linkend="GTypeValueTable"><type>GTypeValueTable</type></link> provides the functions required by the <link linkend="GValue"><type>GValue</type></link>
implementation, to serve as a container for values of a type.</para>
<refsect3 id="GTypeValueTable.members" role="struct_members">
<title>Members</title>
<informaltable role="struct_members_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="struct_members_name" colwidth="300px"/>
<colspec colname="struct_members_description"/>
<colspec colname="struct_members_annotations" colwidth="200px"/>
<tbody>
<row role="member"><entry role="struct_member_name"><para><structfield id="GTypeValueTable.value-init">value_init</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Default initialize <parameter>values</parameter>
contents by poking values
directly into the value->data array. The data array of
the <link linkend="GValue"><type>GValue</type></link> passed into this function was zero-filled
with <literal><link linkend="memset"><function>memset()</function></link></literal>, so no care has to be taken to free any
old contents. E.g. for the implementation of a string
value that may never be <link linkend="NULL:CAPS"><literal>NULL</literal></link>, the implementation might
look like:</para>
<informalexample><programlisting role="example"><![CDATA[
value->data[0].v_pointer = g_strdup ("");
]]></programlisting></informalexample>
<para></para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GTypeValueTable.value-free">value_free</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Free any old contents that might be left in the
data array of the passed in <parameter>value</parameter>
. No resources may
remain allocated through the <link linkend="GValue"><type>GValue</type></link> contents after
this function returns. E.g. for our above string type:</para>
<informalexample><programlisting role="example"><![CDATA[
// only free strings without a specific flag for static storage
if (!(value->data[1].v_uint & G_VALUE_NOCOPY_CONTENTS))
g_free (value->data[0].v_pointer);
]]></programlisting></informalexample>
<para></para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GTypeValueTable.value-copy">value_copy</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para><parameter>dest_value</parameter>
is a <link linkend="GValue"><type>GValue</type></link> with zero-filled data section
and <parameter>src_value</parameter>
is a properly setup <link linkend="GValue"><type>GValue</type></link> of same or
derived type.
The purpose of this function is to copy the contents of
<parameter>src_value</parameter>
into <parameter>dest_value</parameter>
in a way, that even after
<parameter>src_value</parameter>
has been freed, the contents of <parameter>dest_value</parameter>
remain valid. String type example:</para>
<informalexample><programlisting role="example"><![CDATA[
dest_value->data[0].v_pointer = g_strdup (src_value->data[0].v_pointer);
]]></programlisting></informalexample>
<para></para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GTypeValueTable.value-peek-pointer">value_peek_pointer</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>If the value contents fit into a pointer, such as objects
or strings, return this pointer, so the caller can peek at
the current contents. To extend on our above string example:</para>
<informalexample><programlisting role="example"><![CDATA[
return value->data[0].v_pointer;
]]></programlisting></informalexample>
<para></para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para>const&#160;<link linkend="gchar"><type>gchar</type></link>&#160;*<structfield id="GTypeValueTable.collect-format">collect_format</structfield>;</para></entry>
<entry role="struct_member_description"><para>A string format describing how to collect the contents of
this value bit-by-bit. Each character in the format represents
an argument to be collected, and the characters themselves indicate
the type of the argument. Currently supported arguments are:</para>
<itemizedlist>
<listitem><para>'i' - Integers. passed as collect_values[].v_int.</para></listitem>
<listitem><para>'l' - Longs. passed as collect_values[].v_long.</para></listitem>
<listitem><para>'d' - Doubles. passed as collect_values[].v_double.</para></listitem>
<listitem><para>'p' - Pointers. passed as collect_values[].v_pointer.
It should be noted that for variable argument list construction,
ANSI C promotes every type smaller than an integer to an int, and
floats to doubles. So for collection of short int or char, 'i'
needs to be used, and for collection of floats 'd'.</para></listitem>
</itemizedlist></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GTypeValueTable.collect-value">collect_value</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>The <link linkend="collect-value"><function>collect_value()</function></link> function is responsible for converting the
values collected from a variable argument list into contents
suitable for storage in a GValue. This function should setup
<parameter>value</parameter>
similar to <link linkend="value-init"><function>value_init()</function></link>; e.g. for a string value that
does not allow <link linkend="NULL:CAPS"><literal>NULL</literal></link> pointers, it needs to either spew an error,
or do an implicit conversion by storing an empty string.
The <parameter>value</parameter>
passed in to this function has a zero-filled data
array, so just like for <link linkend="value-init"><function>value_init()</function></link> it is guaranteed to not
contain any old contents that might need freeing.
<parameter>n_collect_values</parameter>
is exactly the string length of <parameter>collect_format</parameter>
,
and <parameter>collect_values</parameter>
is an array of unions <link linkend="GTypeCValue"><type>GTypeCValue</type></link> with
length <parameter>n_collect_values</parameter>
, containing the collected values
according to <parameter>collect_format</parameter>
.
<parameter>collect_flags</parameter>
is an argument provided as a hint by the caller.
It may contain the flag <link linkend="G-VALUE-NOCOPY-CONTENTS:CAPS"><literal>G_VALUE_NOCOPY_CONTENTS</literal></link> indicating,
that the collected value contents may be considered "static"
for the duration of the <parameter>value</parameter>
lifetime.
Thus an extra copy of the contents stored in <parameter>collect_values</parameter>
is
not required for assignment to <parameter>value</parameter>
.
For our above string example, we continue with:</para>
<informalexample><programlisting role="example"><![CDATA[
if (!collect_values[0].v_pointer)
value->data[0].v_pointer = g_strdup ("");
else if (collect_flags & G_VALUE_NOCOPY_CONTENTS)
{
value->data[0].v_pointer = collect_values[0].v_pointer;
// keep a flag for the value_free() implementation to not free this string
value->data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
}
else
value->data[0].v_pointer = g_strdup (collect_values[0].v_pointer);
return NULL;
]]></programlisting></informalexample>
<para>
It should be noted, that it is generally a bad idea to follow the
<link linkend="G-VALUE-NOCOPY-CONTENTS:CAPS"><type>G_VALUE_NOCOPY_CONTENTS</type></link> hint for reference counted types. Due to
reentrancy requirements and reference count assertions performed
by the signal emission code, reference counts should always be
incremented for reference counted contents stored in the value->data
array.  To deviate from our string example for a moment, and taking
a look at an exemplary implementation for <link linkend="collect-value"><function>collect_value()</function></link> of
<link linkend="GObject"><type>GObject</type></link>:</para>
<informalexample><programlisting role="example"><![CDATA[
if (collect_values[0].v_pointer)
{
GObject *object = G_OBJECT (collect_values[0].v_pointer);
// never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types
value->data[0].v_pointer = g_object_ref (object);
return NULL;
}
else
return g_strdup_printf ("Object passed as invalid NULL pointer");
}
]]></programlisting></informalexample>
<para>
The reference count for valid objects is always incremented,
regardless of <parameter>collect_flags</parameter>
. For invalid objects, the example
returns a newly allocated string without altering <parameter>value</parameter>
.
Upon success, <link linkend="collect-value"><function>collect_value()</function></link> needs to return <link linkend="NULL:CAPS"><literal>NULL</literal></link>. If, however,
an error condition occurred, <link linkend="collect-value"><function>collect_value()</function></link> may spew an
error by returning a newly allocated non-<link linkend="NULL:CAPS"><literal>NULL</literal></link> string, giving
a suitable description of the error condition.
The calling code makes no assumptions about the <parameter>value</parameter>
contents being valid upon error returns, <parameter>value</parameter>
is simply thrown away without further freeing. As such, it is
a good idea to not allocate <link linkend="GValue"><type>GValue</type></link> contents, prior to returning
an error, however, <link linkend="collect-values"><function>collect_values()</function></link> is not obliged to return
a correctly setup <parameter>value</parameter>
for error returns, simply because
any non-<link linkend="NULL:CAPS"><literal>NULL</literal></link> return is considered a fatal condition so further
program behaviour is undefined.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para>const&#160;<link linkend="gchar"><type>gchar</type></link>&#160;*<structfield id="GTypeValueTable.lcopy-format">lcopy_format</structfield>;</para></entry>
<entry role="struct_member_description"><para>Format description of the arguments to collect for <parameter>lcopy_value</parameter>
,
analogous to <parameter>collect_format</parameter>
. Usually, <parameter>lcopy_format</parameter>
string consists
only of 'p's to provide <link linkend="lcopy-value"><function>lcopy_value()</function></link> with pointers to storage locations.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GTypeValueTable.lcopy-value">lcopy_value</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>This function is responsible for storing the <parameter>value</parameter>
contents into
arguments passed through a variable argument list which got
collected into <parameter>collect_values</parameter>
according to <parameter>lcopy_format</parameter>
.
<parameter>n_collect_values</parameter>
equals the string length of <parameter>lcopy_format</parameter>
,
and <parameter>collect_flags</parameter>
may contain <link linkend="G-VALUE-NOCOPY-CONTENTS:CAPS"><literal>G_VALUE_NOCOPY_CONTENTS</literal></link>.
In contrast to <link linkend="collect-value"><function>collect_value()</function></link>, <link linkend="lcopy-value"><function>lcopy_value()</function></link> is obliged to
always properly support <link linkend="G-VALUE-NOCOPY-CONTENTS:CAPS"><literal>G_VALUE_NOCOPY_CONTENTS</literal></link>.
Similar to <link linkend="collect-value"><function>collect_value()</function></link> the function may prematurely abort
by returning a newly allocated string describing an error condition.
To complete the string example:</para>
<informalexample><programlisting role="example"><![CDATA[
gchar **string_p = collect_values[0].v_pointer;
if (!string_p)
return g_strdup_printf ("string location passed as NULL");
if (collect_flags & G_VALUE_NOCOPY_CONTENTS)
*string_p = value->data[0].v_pointer;
else
*string_p = g_strdup (value->data[0].v_pointer);
]]></programlisting></informalexample>
<para>
And an illustrative version of <link linkend="lcopy-value"><function>lcopy_value()</function></link> for
reference-counted types:</para>
<informalexample><programlisting role="example"><![CDATA[
GObject **object_p = collect_values[0].v_pointer;
if (!object_p)
return g_strdup_printf ("object location passed as NULL");
if (!value->data[0].v_pointer)
*object_p = NULL;
else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) // always honour
*object_p = value->data[0].v_pointer;
else
*object_p = g_object_ref (value->data[0].v_pointer);
return NULL;
]]></programlisting></informalexample>
<para></para></entry>
<entry role="struct_member_annotations"></entry>
</row>
</tbody></tgroup></informaltable>
</refsect3>
</refsect2>
<refsect2 id="G-TYPE-FLAG-RESERVED-ID-BIT:CAPS" role="macro">
<title>G_TYPE_FLAG_RESERVED_ID_BIT</title>
<indexterm zone="G-TYPE-FLAG-RESERVED-ID-BIT:CAPS"><primary sortas="TYPE_FLAG_RESERVED_ID_BIT">G_TYPE_FLAG_RESERVED_ID_BIT</primary></indexterm>
<programlisting language="C">#define&#160;G_TYPE_FLAG_RESERVED_ID_BIT&#160;((GType) (1 &lt;&lt; 0))
</programlisting>
<para>A bit in the type number that's supposed to be left untouched.</para>
</refsect2>
<refsect2 id="GTypeDebugFlags" role="enum" condition="deprecated:2.36: g_type_init() is now done automatically">
<title>enum GTypeDebugFlags</title>
<indexterm zone="GTypeDebugFlags" role="deprecated"><primary sortas="TypeDebugFlags">GTypeDebugFlags</primary></indexterm>
<warning><para><literal>GTypeDebugFlags</literal> has been deprecated since version 2.36 and should not be used in newly-written code.</para> <para>g_type_init() is now done automatically</para>
</warning>
<para>These flags used to be passed to <link linkend="g-type-init-with-debug-flags"><function>g_type_init_with_debug_flags()</function></link> which
is now deprecated.</para>
<para>If you need to enable debugging features, use the GOBJECT_DEBUG
environment variable.</para>
<refsect3 id="GTypeDebugFlags.members" role="enum_members">
<title>Members</title>
<informaltable role="enum_members_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="enum_members_name" colwidth="300px"/>
<colspec colname="enum_members_description"/>
<colspec colname="enum_members_annotations" colwidth="200px"/>
<tbody>
<row role="constant"><entry role="enum_member_name"><para id="G-TYPE-DEBUG-NONE:CAPS">G_TYPE_DEBUG_NONE</para></entry>
<entry role="enum_member_description"><para>Print no messages</para>
</entry>
<entry role="enum_member_annotations"></entry>
</row>
<row role="constant"><entry role="enum_member_name"><para id="G-TYPE-DEBUG-OBJECTS:CAPS">G_TYPE_DEBUG_OBJECTS</para></entry>
<entry role="enum_member_description"><para>Print messages about object bookkeeping</para>
</entry>
<entry role="enum_member_annotations"></entry>
</row>
<row role="constant"><entry role="enum_member_name"><para id="G-TYPE-DEBUG-SIGNALS:CAPS">G_TYPE_DEBUG_SIGNALS</para></entry>
<entry role="enum_member_description"><para>Print messages about signal emissions</para>
</entry>
<entry role="enum_member_annotations"></entry>
</row>
<row role="constant"><entry role="enum_member_name"><para id="G-TYPE-DEBUG-INSTANCE-COUNT:CAPS">G_TYPE_DEBUG_INSTANCE_COUNT</para></entry>
<entry role="enum_member_description"><para>Keep a count of instances of each type</para>
</entry>
<entry role="enum_member_annotations"></entry>
</row>
<row role="constant"><entry role="enum_member_name"><para id="G-TYPE-DEBUG-MASK:CAPS">G_TYPE_DEBUG_MASK</para></entry>
<entry role="enum_member_description"><para>Mask covering all debug flags</para>
</entry>
<entry role="enum_member_annotations"></entry>
</row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="GTypeQuery" role="struct">
<title>struct GTypeQuery</title>
<indexterm zone="GTypeQuery"><primary sortas="TypeQuery">GTypeQuery</primary></indexterm>
<programlisting language="C">struct GTypeQuery {
  GType		type;
  const gchar  *type_name;
  guint		class_size;
  guint		instance_size;
};
</programlisting>
<para>A structure holding information for a specific type.
It is filled in by the <link linkend="g-type-query"><function>g_type_query()</function></link> function.</para>
<refsect3 id="GTypeQuery.members" role="struct_members">
<title>Members</title>
<informaltable role="struct_members_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="struct_members_name" colwidth="300px"/>
<colspec colname="struct_members_description"/>
<colspec colname="struct_members_annotations" colwidth="200px"/>
<tbody>
<row role="member"><entry role="struct_member_name"><para><link linkend="GType"><type>GType</type></link>&#160;<structfield id="GTypeQuery.type">type</structfield>;</para></entry>
<entry role="struct_member_description"><para>the <link linkend="GType"><type>GType</type></link> value of the type</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para>const&#160;<link linkend="gchar"><type>gchar</type></link>&#160;*<structfield id="GTypeQuery.type-name">type_name</structfield>;</para></entry>
<entry role="struct_member_description"><para>the name of the type</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><link linkend="guint"><type>guint</type></link>&#160;<structfield id="GTypeQuery.class-size">class_size</structfield>;</para></entry>
<entry role="struct_member_description"><para>the size of the class structure</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><link linkend="guint"><type>guint</type></link>&#160;<structfield id="GTypeQuery.instance-size">instance_size</structfield>;</para></entry>
<entry role="struct_member_description"><para>the size of the instance structure</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
</tbody></tgroup></informaltable>
</refsect3>
</refsect2>
<refsect2 id="GTypeFlags" role="enum">
<title>enum GTypeFlags</title>
<indexterm zone="GTypeFlags"><primary sortas="TypeFlags">GTypeFlags</primary></indexterm>
<para>Bit masks used to check or determine characteristics of a type.</para>
<refsect3 id="GTypeFlags.members" role="enum_members">
<title>Members</title>
<informaltable role="enum_members_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="enum_members_name" colwidth="300px"/>
<colspec colname="enum_members_description"/>
<colspec colname="enum_members_annotations" colwidth="200px"/>
<tbody>
<row role="constant"><entry role="enum_member_name"><para id="G-TYPE-FLAG-ABSTRACT:CAPS">G_TYPE_FLAG_ABSTRACT</para></entry>
<entry role="enum_member_description"><para>Indicates an abstract type. No instances can be
 created for an abstract type</para>
</entry>
<entry role="enum_member_annotations"></entry>
</row>
<row role="constant"><entry role="enum_member_name"><para id="G-TYPE-FLAG-VALUE-ABSTRACT:CAPS">G_TYPE_FLAG_VALUE_ABSTRACT</para></entry>
<entry role="enum_member_description"><para>Indicates an abstract value type, i.e. a type
 that introduces a value table, but can't be used for
 <link linkend="g-value-init"><function>g_value_init()</function></link></para>
</entry>
<entry role="enum_member_annotations"></entry>
</row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="GTypeFundamentalFlags" role="enum">
<title>enum GTypeFundamentalFlags</title>
<indexterm zone="GTypeFundamentalFlags"><primary sortas="TypeFundamentalFlags">GTypeFundamentalFlags</primary></indexterm>
<para>Bit masks used to check or determine specific characteristics of a
fundamental type.</para>
<refsect3 id="GTypeFundamentalFlags.members" role="enum_members">
<title>Members</title>
<informaltable role="enum_members_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="enum_members_name" colwidth="300px"/>
<colspec colname="enum_members_description"/>
<colspec colname="enum_members_annotations" colwidth="200px"/>
<tbody>
<row role="constant"><entry role="enum_member_name"><para id="G-TYPE-FLAG-CLASSED:CAPS">G_TYPE_FLAG_CLASSED</para></entry>
<entry role="enum_member_description"><para>Indicates a classed type</para>
</entry>
<entry role="enum_member_annotations"></entry>
</row>
<row role="constant"><entry role="enum_member_name"><para id="G-TYPE-FLAG-INSTANTIATABLE:CAPS">G_TYPE_FLAG_INSTANTIATABLE</para></entry>
<entry role="enum_member_description"><para>Indicates an instantiable type (implies classed)</para>
</entry>
<entry role="enum_member_annotations"></entry>
</row>
<row role="constant"><entry role="enum_member_name"><para id="G-TYPE-FLAG-DERIVABLE:CAPS">G_TYPE_FLAG_DERIVABLE</para></entry>
<entry role="enum_member_description"><para>Indicates a flat derivable type</para>
</entry>
<entry role="enum_member_annotations"></entry>
</row>
<row role="constant"><entry role="enum_member_name"><para id="G-TYPE-FLAG-DEEP-DERIVABLE:CAPS">G_TYPE_FLAG_DEEP_DERIVABLE</para></entry>
<entry role="enum_member_description"><para>Indicates a deep derivable type (implies derivable)</para>
</entry>
<entry role="enum_member_annotations"></entry>
</row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="G-TYPE-INVALID:CAPS" role="macro">
<title>G_TYPE_INVALID</title>
<indexterm zone="G-TYPE-INVALID:CAPS"><primary sortas="TYPE_INVALID">G_TYPE_INVALID</primary></indexterm>
<programlisting language="C">#define G_TYPE_INVALID			G_TYPE_MAKE_FUNDAMENTAL (0)
</programlisting>
<para>An invalid <link linkend="GType"><type>GType</type></link> used as error return value in some functions which return
a <link linkend="GType"><type>GType</type></link>.</para>
</refsect2>
<refsect2 id="G-TYPE-NONE:CAPS" role="macro">
<title>G_TYPE_NONE</title>
<indexterm zone="G-TYPE-NONE:CAPS"><primary sortas="TYPE_NONE">G_TYPE_NONE</primary></indexterm>
<programlisting language="C">#define G_TYPE_NONE			G_TYPE_MAKE_FUNDAMENTAL (1)
</programlisting>
<para>A fundamental type which is used as a replacement for the C
void return type.</para>
</refsect2>
<refsect2 id="G-TYPE-INTERFACE:CAPS" role="macro">
<title>G_TYPE_INTERFACE</title>
<indexterm zone="G-TYPE-INTERFACE:CAPS"><primary sortas="TYPE_INTERFACE">G_TYPE_INTERFACE</primary></indexterm>
<programlisting language="C">#define G_TYPE_INTERFACE		G_TYPE_MAKE_FUNDAMENTAL (2)
</programlisting>
<para>The fundamental type from which all interfaces are derived.</para>
</refsect2>
<refsect2 id="G-TYPE-CHAR:CAPS" role="macro">
<title>G_TYPE_CHAR</title>
<indexterm zone="G-TYPE-CHAR:CAPS"><primary sortas="TYPE_CHAR">G_TYPE_CHAR</primary></indexterm>
<programlisting language="C">#define G_TYPE_CHAR			G_TYPE_MAKE_FUNDAMENTAL (3)
</programlisting>
<para>The fundamental type corresponding to <link linkend="gchar"><type>gchar</type></link>.
The type designated by G_TYPE_CHAR is unconditionally an 8-bit signed integer.
This may or may not be the same type a the C type "gchar".</para>
</refsect2>
<refsect2 id="G-TYPE-UCHAR:CAPS" role="macro">
<title>G_TYPE_UCHAR</title>
<indexterm zone="G-TYPE-UCHAR:CAPS"><primary sortas="TYPE_UCHAR">G_TYPE_UCHAR</primary></indexterm>
<programlisting language="C">#define G_TYPE_UCHAR			G_TYPE_MAKE_FUNDAMENTAL (4)
</programlisting>
<para>The fundamental type corresponding to <link linkend="guchar"><type>guchar</type></link>.</para>
</refsect2>
<refsect2 id="G-TYPE-BOOLEAN:CAPS" role="macro">
<title>G_TYPE_BOOLEAN</title>
<indexterm zone="G-TYPE-BOOLEAN:CAPS"><primary sortas="TYPE_BOOLEAN">G_TYPE_BOOLEAN</primary></indexterm>
<programlisting language="C">#define G_TYPE_BOOLEAN			G_TYPE_MAKE_FUNDAMENTAL (5)
</programlisting>
<para>The fundamental type corresponding to <link linkend="gboolean"><type>gboolean</type></link>.</para>
</refsect2>
<refsect2 id="G-TYPE-INT:CAPS" role="macro">
<title>G_TYPE_INT</title>
<indexterm zone="G-TYPE-INT:CAPS"><primary sortas="TYPE_INT">G_TYPE_INT</primary></indexterm>
<programlisting language="C">#define G_TYPE_INT			G_TYPE_MAKE_FUNDAMENTAL (6)
</programlisting>
<para>The fundamental type corresponding to <link linkend="gint"><type>gint</type></link>.</para>
</refsect2>
<refsect2 id="G-TYPE-UINT:CAPS" role="macro">
<title>G_TYPE_UINT</title>
<indexterm zone="G-TYPE-UINT:CAPS"><primary sortas="TYPE_UINT">G_TYPE_UINT</primary></indexterm>
<programlisting language="C">#define G_TYPE_UINT			G_TYPE_MAKE_FUNDAMENTAL (7)
</programlisting>
<para>The fundamental type corresponding to <link linkend="guint"><type>guint</type></link>.</para>
</refsect2>
<refsect2 id="G-TYPE-LONG:CAPS" role="macro">
<title>G_TYPE_LONG</title>
<indexterm zone="G-TYPE-LONG:CAPS"><primary sortas="TYPE_LONG">G_TYPE_LONG</primary></indexterm>
<programlisting language="C">#define G_TYPE_LONG			G_TYPE_MAKE_FUNDAMENTAL (8)
</programlisting>
<para>The fundamental type corresponding to <link linkend="glong"><type>glong</type></link>.</para>
</refsect2>
<refsect2 id="G-TYPE-ULONG:CAPS" role="macro">
<title>G_TYPE_ULONG</title>
<indexterm zone="G-TYPE-ULONG:CAPS"><primary sortas="TYPE_ULONG">G_TYPE_ULONG</primary></indexterm>
<programlisting language="C">#define G_TYPE_ULONG			G_TYPE_MAKE_FUNDAMENTAL (9)
</programlisting>
<para>The fundamental type corresponding to <link linkend="gulong"><type>gulong</type></link>.</para>
</refsect2>
<refsect2 id="G-TYPE-INT64:CAPS" role="macro">
<title>G_TYPE_INT64</title>
<indexterm zone="G-TYPE-INT64:CAPS"><primary sortas="TYPE_INT64">G_TYPE_INT64</primary></indexterm>
<programlisting language="C">#define G_TYPE_INT64			G_TYPE_MAKE_FUNDAMENTAL (10)
</programlisting>
<para>The fundamental type corresponding to <link linkend="gint64"><type>gint64</type></link>.</para>
</refsect2>
<refsect2 id="G-TYPE-UINT64:CAPS" role="macro">
<title>G_TYPE_UINT64</title>
<indexterm zone="G-TYPE-UINT64:CAPS"><primary sortas="TYPE_UINT64">G_TYPE_UINT64</primary></indexterm>
<programlisting language="C">#define G_TYPE_UINT64			G_TYPE_MAKE_FUNDAMENTAL (11)
</programlisting>
<para>The fundamental type corresponding to <link linkend="guint64"><type>guint64</type></link>.</para>
</refsect2>
<refsect2 id="G-TYPE-ENUM:CAPS" role="macro">
<title>G_TYPE_ENUM</title>
<indexterm zone="G-TYPE-ENUM:CAPS"><primary sortas="TYPE_ENUM">G_TYPE_ENUM</primary></indexterm>
<programlisting language="C">#define G_TYPE_ENUM			G_TYPE_MAKE_FUNDAMENTAL (12)
</programlisting>
<para>The fundamental type from which all enumeration types are derived.</para>
</refsect2>
<refsect2 id="G-TYPE-FLAGS:CAPS" role="macro">
<title>G_TYPE_FLAGS</title>
<indexterm zone="G-TYPE-FLAGS:CAPS"><primary sortas="TYPE_FLAGS">G_TYPE_FLAGS</primary></indexterm>
<programlisting language="C">#define G_TYPE_FLAGS			G_TYPE_MAKE_FUNDAMENTAL (13)
</programlisting>
<para>The fundamental type from which all flags types are derived.</para>
</refsect2>
<refsect2 id="G-TYPE-FLOAT:CAPS" role="macro">
<title>G_TYPE_FLOAT</title>
<indexterm zone="G-TYPE-FLOAT:CAPS"><primary sortas="TYPE_FLOAT">G_TYPE_FLOAT</primary></indexterm>
<programlisting language="C">#define G_TYPE_FLOAT			G_TYPE_MAKE_FUNDAMENTAL (14)
</programlisting>
<para>The fundamental type corresponding to <link linkend="gfloat"><type>gfloat</type></link>.</para>
</refsect2>
<refsect2 id="G-TYPE-DOUBLE:CAPS" role="macro">
<title>G_TYPE_DOUBLE</title>
<indexterm zone="G-TYPE-DOUBLE:CAPS"><primary sortas="TYPE_DOUBLE">G_TYPE_DOUBLE</primary></indexterm>
<programlisting language="C">#define G_TYPE_DOUBLE			G_TYPE_MAKE_FUNDAMENTAL (15)
</programlisting>
<para>The fundamental type corresponding to <link linkend="gdouble"><type>gdouble</type></link>.</para>
</refsect2>
<refsect2 id="G-TYPE-STRING:CAPS" role="macro">
<title>G_TYPE_STRING</title>
<indexterm zone="G-TYPE-STRING:CAPS"><primary sortas="TYPE_STRING">G_TYPE_STRING</primary></indexterm>
<programlisting language="C">#define G_TYPE_STRING			G_TYPE_MAKE_FUNDAMENTAL (16)
</programlisting>
<para>The fundamental type corresponding to nul-terminated C strings.</para>
</refsect2>
<refsect2 id="G-TYPE-POINTER:CAPS" role="macro">
<title>G_TYPE_POINTER</title>
<indexterm zone="G-TYPE-POINTER:CAPS"><primary sortas="TYPE_POINTER">G_TYPE_POINTER</primary></indexterm>
<programlisting language="C">#define G_TYPE_POINTER			G_TYPE_MAKE_FUNDAMENTAL (17)
</programlisting>
<para>The fundamental type corresponding to <link linkend="gpointer"><type>gpointer</type></link>.</para>
</refsect2>
<refsect2 id="G-TYPE-BOXED:CAPS" role="macro">
<title>G_TYPE_BOXED</title>
<indexterm zone="G-TYPE-BOXED:CAPS"><primary sortas="TYPE_BOXED">G_TYPE_BOXED</primary></indexterm>
<programlisting language="C">#define G_TYPE_BOXED			G_TYPE_MAKE_FUNDAMENTAL (18)
</programlisting>
<para>The fundamental type from which all boxed types are derived.</para>
</refsect2>
<refsect2 id="G-TYPE-PARAM:CAPS" role="macro">
<title>G_TYPE_PARAM</title>
<indexterm zone="G-TYPE-PARAM:CAPS"><primary sortas="TYPE_PARAM">G_TYPE_PARAM</primary></indexterm>
<programlisting language="C">#define G_TYPE_PARAM			G_TYPE_MAKE_FUNDAMENTAL (19)
</programlisting>
<para>The fundamental type from which all <link linkend="GParamSpec"><type>GParamSpec</type></link> types are derived.</para>
</refsect2>
<refsect2 id="G-TYPE-OBJECT:CAPS" role="macro">
<title>G_TYPE_OBJECT</title>
<indexterm zone="G-TYPE-OBJECT:CAPS"><primary sortas="TYPE_OBJECT">G_TYPE_OBJECT</primary></indexterm>
<programlisting language="C">#define G_TYPE_OBJECT			G_TYPE_MAKE_FUNDAMENTAL (20)
</programlisting>
<para>The fundamental type for <link linkend="GObject"><type>GObject</type></link>.</para>
</refsect2>
<refsect2 id="G-TYPE-GTYPE:CAPS" role="macro">
<title>G_TYPE_GTYPE</title>
<indexterm zone="G-TYPE-GTYPE:CAPS"><primary sortas="TYPE_GTYPE">G_TYPE_GTYPE</primary></indexterm>
<programlisting language="C">#define&#160;G_TYPE_GTYPE			 (g_gtype_get_type())
</programlisting>
<para>The type for <link linkend="GType"><type>GType</type></link>.</para>
</refsect2>
<refsect2 id="G-TYPE-VARIANT:CAPS" role="macro" condition="since:2.26">
<title>G_TYPE_VARIANT</title>
<indexterm zone="G-TYPE-VARIANT:CAPS" role="2.26"><primary sortas="TYPE_VARIANT">G_TYPE_VARIANT</primary></indexterm>
<programlisting language="C">#define&#160;G_TYPE_VARIANT                  G_TYPE_MAKE_FUNDAMENTAL (21)
</programlisting>
<para>The fundamental type corresponding to <link linkend="GVariant"><type>GVariant</type></link>.</para>
<para>All floating <link linkend="GVariant"><type>GVariant</type></link> instances passed through the <link linkend="GType"><type>GType</type></link> system are
consumed.</para>
<para>Note that callbacks in closures, and signal handlers
for signals of return type <link linkend="G-TYPE-VARIANT:CAPS"><literal>G_TYPE_VARIANT</literal></link>, must never return floating
variants.</para>
<para>Note: GLib 2.24 did include a boxed type with this name. It was replaced
with this fundamental type in 2.26.</para>
<para role="since">Since: <link linkend="api-index-2.26">2.26</link></para></refsect2>
<refsect2 id="G-TYPE-CHECKSUM:CAPS" role="macro" condition="since:2.36">
<title>G_TYPE_CHECKSUM</title>
<indexterm zone="G-TYPE-CHECKSUM:CAPS" role="2.36"><primary sortas="TYPE_CHECKSUM">G_TYPE_CHECKSUM</primary></indexterm>
<programlisting language="C">#define G_TYPE_CHECKSUM (g_checksum_get_type ())
</programlisting>
<para>The <link linkend="GType"><type>GType</type></link> for a boxed type holding a <link linkend="GChecksum"><type>GChecksum</type></link>.</para>
<para role="since">Since: <link linkend="api-index-2.36">2.36</link></para></refsect2>
<refsect2 id="G-TYPE-RESERVED-GLIB-FIRST:CAPS" role="macro">
<title>G_TYPE_RESERVED_GLIB_FIRST</title>
<indexterm zone="G-TYPE-RESERVED-GLIB-FIRST:CAPS"><primary sortas="TYPE_RESERVED_GLIB_FIRST">G_TYPE_RESERVED_GLIB_FIRST</primary></indexterm>
<programlisting language="C">#define G_TYPE_RESERVED_GLIB_FIRST&#160;(22)
</programlisting>
<para>First fundamental type number to create a new fundamental type id with
<link linkend="G-TYPE-MAKE-FUNDAMENTAL:CAPS"><function>G_TYPE_MAKE_FUNDAMENTAL()</function></link> reserved for GLib.</para>
</refsect2>
<refsect2 id="G-TYPE-RESERVED-GLIB-LAST:CAPS" role="macro">
<title>G_TYPE_RESERVED_GLIB_LAST</title>
<indexterm zone="G-TYPE-RESERVED-GLIB-LAST:CAPS"><primary sortas="TYPE_RESERVED_GLIB_LAST">G_TYPE_RESERVED_GLIB_LAST</primary></indexterm>
<programlisting language="C">#define G_TYPE_RESERVED_GLIB_LAST&#160;(31)
</programlisting>
<para>Last fundamental type number reserved for GLib.</para>
</refsect2>
<refsect2 id="G-TYPE-RESERVED-BSE-FIRST:CAPS" role="macro">
<title>G_TYPE_RESERVED_BSE_FIRST</title>
<indexterm zone="G-TYPE-RESERVED-BSE-FIRST:CAPS"><primary sortas="TYPE_RESERVED_BSE_FIRST">G_TYPE_RESERVED_BSE_FIRST</primary></indexterm>
<programlisting language="C">#define G_TYPE_RESERVED_BSE_FIRST&#160;(32)
</programlisting>
<para>First fundamental type number to create a new fundamental type id with
<link linkend="G-TYPE-MAKE-FUNDAMENTAL:CAPS"><function>G_TYPE_MAKE_FUNDAMENTAL()</function></link> reserved for BSE.</para>
</refsect2>
<refsect2 id="G-TYPE-RESERVED-BSE-LAST:CAPS" role="macro">
<title>G_TYPE_RESERVED_BSE_LAST</title>
<indexterm zone="G-TYPE-RESERVED-BSE-LAST:CAPS"><primary sortas="TYPE_RESERVED_BSE_LAST">G_TYPE_RESERVED_BSE_LAST</primary></indexterm>
<programlisting language="C">#define G_TYPE_RESERVED_BSE_LAST&#160;(48)
</programlisting>
<para>Last fundamental type number reserved for BSE.</para>
</refsect2>
<refsect2 id="G-TYPE-RESERVED-USER-FIRST:CAPS" role="macro">
<title>G_TYPE_RESERVED_USER_FIRST</title>
<indexterm zone="G-TYPE-RESERVED-USER-FIRST:CAPS"><primary sortas="TYPE_RESERVED_USER_FIRST">G_TYPE_RESERVED_USER_FIRST</primary></indexterm>
<programlisting language="C">#define G_TYPE_RESERVED_USER_FIRST&#160;(49)
</programlisting>
<para>First available fundamental type number to create new fundamental 
type id with <link linkend="G-TYPE-MAKE-FUNDAMENTAL:CAPS"><function>G_TYPE_MAKE_FUNDAMENTAL()</function></link>.</para>
</refsect2>

</refsect1>

</refentry>
