<MACRO>
<NAME>G_TYPE_ACTION</NAME>
#define G_TYPE_ACTION                                       (g_action_get_type ())
</MACRO>
<MACRO>
<NAME>G_ACTION</NAME>
#define G_ACTION(inst)                                      (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_ACTION, GAction))
</MACRO>
<MACRO>
<NAME>G_IS_ACTION</NAME>
#define G_IS_ACTION(inst)                                   (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_ACTION))
</MACRO>
<MACRO>
<NAME>G_ACTION_GET_IFACE</NAME>
#define G_ACTION_GET_IFACE(inst)                            (G_TYPE_INSTANCE_GET_INTERFACE ((inst),                  \
                                                             G_TYPE_ACTION, GActionInterface))
</MACRO>
<STRUCT>
<NAME>GActionInterface</NAME>
struct _GActionInterface
{
  GTypeInterface g_iface;

  /* virtual functions */
  const gchar *        (* get_name)             (GAction  *action);
  const GVariantType * (* get_parameter_type)   (GAction  *action);
  const GVariantType * (* get_state_type)       (GAction  *action);
  GVariant *           (* get_state_hint)       (GAction  *action);

  gboolean             (* get_enabled)          (GAction  *action);
  GVariant *           (* get_state)            (GAction  *action);

  void                 (* change_state)         (GAction  *action,
                                                 GVariant *value);
  void                 (* activate)             (GAction  *action,
                                                 GVariant *parameter);
};
</STRUCT>
<FUNCTION>
<NAME>g_action_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_action_get_name</NAME>
<RETURNS>const gchar  *           </RETURNS>
GAction            *action
</FUNCTION>
<FUNCTION>
<NAME>g_action_get_parameter_type</NAME>
<RETURNS>const GVariantType  *    </RETURNS>
GAction            *action
</FUNCTION>
<FUNCTION>
<NAME>g_action_get_state_type</NAME>
<RETURNS>const GVariantType  *    </RETURNS>
GAction            *action
</FUNCTION>
<FUNCTION>
<NAME>g_action_get_state_hint</NAME>
<RETURNS>GVariant  *              </RETURNS>
GAction            *action
</FUNCTION>
<FUNCTION>
<NAME>g_action_get_enabled</NAME>
<RETURNS>gboolean                 </RETURNS>
GAction            *action
</FUNCTION>
<FUNCTION>
<NAME>g_action_get_state</NAME>
<RETURNS>GVariant  *              </RETURNS>
GAction            *action
</FUNCTION>
<FUNCTION>
<NAME>g_action_change_state</NAME>
<RETURNS>void                     </RETURNS>
GAction            *action, GVariant           *value
</FUNCTION>
<FUNCTION>
<NAME>g_action_activate</NAME>
<RETURNS>void                     </RETURNS>
GAction            *action, GVariant           *parameter
</FUNCTION>
<FUNCTION>
<NAME>g_action_name_is_valid</NAME>
<RETURNS>gboolean                 </RETURNS>
const gchar        *action_name
</FUNCTION>
<FUNCTION>
<NAME>g_action_parse_detailed_name</NAME>
<RETURNS>gboolean                 </RETURNS>
const gchar        *detailed_name, gchar             **action_name, GVariant          **target_value, GError            **error
</FUNCTION>
<FUNCTION>
<NAME>g_action_print_detailed_name</NAME>
<RETURNS>gchar  *                 </RETURNS>
const gchar        *action_name, GVariant           *target_value
</FUNCTION>
<MACRO>
<NAME>G_TYPE_ACTION_GROUP</NAME>
#define G_TYPE_ACTION_GROUP                                 (g_action_group_get_type ())
</MACRO>
<MACRO>
<NAME>G_ACTION_GROUP</NAME>
#define G_ACTION_GROUP(inst)                                (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_ACTION_GROUP, GActionGroup))
</MACRO>
<MACRO>
<NAME>G_IS_ACTION_GROUP</NAME>
#define G_IS_ACTION_GROUP(inst)                             (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_ACTION_GROUP))
</MACRO>
<MACRO>
<NAME>G_ACTION_GROUP_GET_IFACE</NAME>
#define G_ACTION_GROUP_GET_IFACE(inst)                      (G_TYPE_INSTANCE_GET_INTERFACE ((inst),                  \
                                                             G_TYPE_ACTION_GROUP, GActionGroupInterface))
</MACRO>
<STRUCT>
<NAME>GActionGroupInterface</NAME>
struct _GActionGroupInterface
{
  GTypeInterface g_iface;

  /* virtual functions */
  gboolean              (* has_action)                 (GActionGroup  *action_group,
                                                        const gchar   *action_name);

  gchar **              (* list_actions)               (GActionGroup  *action_group);

  gboolean              (* get_action_enabled)         (GActionGroup  *action_group,
                                                        const gchar   *action_name);

  const GVariantType *  (* get_action_parameter_type)  (GActionGroup  *action_group,
                                                        const gchar   *action_name);

  const GVariantType *  (* get_action_state_type)      (GActionGroup  *action_group,
                                                        const gchar   *action_name);

  GVariant *            (* get_action_state_hint)      (GActionGroup  *action_group,
                                                        const gchar   *action_name);

  GVariant *            (* get_action_state)           (GActionGroup  *action_group,
                                                        const gchar   *action_name);

  void                  (* change_action_state)        (GActionGroup  *action_group,
                                                        const gchar   *action_name,
                                                        GVariant      *value);

  void                  (* activate_action)            (GActionGroup  *action_group,
                                                        const gchar   *action_name,
                                                        GVariant      *parameter);

  /* signals */
  void                  (* action_added)               (GActionGroup  *action_group,
                                                        const gchar   *action_name);
  void                  (* action_removed)             (GActionGroup  *action_group,
                                                        const gchar   *action_name);
  void                  (* action_enabled_changed)     (GActionGroup  *action_group,
                                                        const gchar   *action_name,
                                                        gboolean       enabled);
  void                  (* action_state_changed)       (GActionGroup   *action_group,
                                                        const gchar    *action_name,
                                                        GVariant       *state);

  /* more virtual functions */
  gboolean              (* query_action)               (GActionGroup        *action_group,
                                                        const gchar         *action_name,
                                                        gboolean            *enabled,
                                                        const GVariantType **parameter_type,
                                                        const GVariantType **state_type,
                                                        GVariant           **state_hint,
                                                        GVariant           **state);
};
</STRUCT>
<FUNCTION>
<NAME>g_action_group_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_action_group_has_action</NAME>
<RETURNS>gboolean                 </RETURNS>
GActionGroup *action_group, const gchar  *action_name
</FUNCTION>
<FUNCTION>
<NAME>g_action_group_list_actions</NAME>
<RETURNS>gchar  **                </RETURNS>
GActionGroup *action_group
</FUNCTION>
<FUNCTION>
<NAME>g_action_group_get_action_parameter_type</NAME>
<RETURNS>const GVariantType  *    </RETURNS>
GActionGroup *action_group, const gchar  *action_name
</FUNCTION>
<FUNCTION>
<NAME>g_action_group_get_action_state_type</NAME>
<RETURNS>const GVariantType  *    </RETURNS>
GActionGroup *action_group, const gchar  *action_name
</FUNCTION>
<FUNCTION>
<NAME>g_action_group_get_action_state_hint</NAME>
<RETURNS>GVariant  *              </RETURNS>
GActionGroup *action_group, const gchar  *action_name
</FUNCTION>
<FUNCTION>
<NAME>g_action_group_get_action_enabled</NAME>
<RETURNS>gboolean                 </RETURNS>
GActionGroup *action_group, const gchar  *action_name
</FUNCTION>
<FUNCTION>
<NAME>g_action_group_get_action_state</NAME>
<RETURNS>GVariant  *              </RETURNS>
GActionGroup *action_group, const gchar  *action_name
</FUNCTION>
<FUNCTION>
<NAME>g_action_group_change_action_state</NAME>
<RETURNS>void                     </RETURNS>
GActionGroup *action_group, const gchar  *action_name, GVariant     *value
</FUNCTION>
<FUNCTION>
<NAME>g_action_group_activate_action</NAME>
<RETURNS>void                     </RETURNS>
GActionGroup *action_group, const gchar  *action_name, GVariant     *parameter
</FUNCTION>
<FUNCTION>
<NAME>g_action_group_action_added</NAME>
<RETURNS>void                     </RETURNS>
GActionGroup *action_group, const gchar  *action_name
</FUNCTION>
<FUNCTION>
<NAME>g_action_group_action_removed</NAME>
<RETURNS>void                     </RETURNS>
GActionGroup *action_group, const gchar  *action_name
</FUNCTION>
<FUNCTION>
<NAME>g_action_group_action_enabled_changed</NAME>
<RETURNS>void                     </RETURNS>
GActionGroup *action_group, const gchar  *action_name, gboolean      enabled
</FUNCTION>
<FUNCTION>
<NAME>g_action_group_action_state_changed</NAME>
<RETURNS>void                     </RETURNS>
GActionGroup *action_group, const gchar  *action_name, GVariant     *state
</FUNCTION>
<FUNCTION>
<NAME>g_action_group_query_action</NAME>
<RETURNS>gboolean                 </RETURNS>
GActionGroup        *action_group, const gchar         *action_name, gboolean            *enabled, const GVariantType **parameter_type, const GVariantType **state_type, GVariant           **state_hint, GVariant           **state
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_export_action_group</NAME>
<RETURNS>guint                    </RETURNS>
GDBusConnection  *connection, const gchar      *object_path, GActionGroup     *action_group, GError          **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_unexport_action_group</NAME>
<RETURNS>void                     </RETURNS>
GDBusConnection  *connection, guint             export_id
</FUNCTION>
<MACRO>
<NAME>G_TYPE_ACTION_MAP</NAME>
#define G_TYPE_ACTION_MAP                                   (g_action_map_get_type ())
</MACRO>
<MACRO>
<NAME>G_ACTION_MAP</NAME>
#define G_ACTION_MAP(inst)                                  (G_TYPE_CHECK_INSTANCE_CAST ((inst),                      \
                                                             G_TYPE_ACTION_MAP, GActionMap))
</MACRO>
<MACRO>
<NAME>G_IS_ACTION_MAP</NAME>
#define G_IS_ACTION_MAP(inst)                               (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                      \
                                                             G_TYPE_ACTION_MAP))
</MACRO>
<MACRO>
<NAME>G_ACTION_MAP_GET_IFACE</NAME>
#define G_ACTION_MAP_GET_IFACE(inst)                        (G_TYPE_INSTANCE_GET_INTERFACE ((inst),                   \
                                                             G_TYPE_ACTION_MAP, GActionMapInterface))
</MACRO>
<STRUCT>
<NAME>GActionMapInterface</NAME>
struct _GActionMapInterface
{
  GTypeInterface g_iface;

  GAction * (* lookup_action) (GActionMap  *action_map,
                               const gchar *action_name);
  void      (* add_action)    (GActionMap  *action_map,
                               GAction     *action);
  void      (* remove_action) (GActionMap  *action_map,
                               const gchar *action_name);
};
</STRUCT>
<STRUCT>
<NAME>GActionEntry</NAME>
struct _GActionEntry
{
  const gchar *name;

  void (* activate) (GSimpleAction *action,
                     GVariant      *parameter,
                     gpointer       user_data);

  const gchar *parameter_type;

  const gchar *state;

  void (* change_state) (GSimpleAction *action,
                         GVariant      *value,
                         gpointer       user_data);

  /*< private >*/
  gsize padding[3];
};
</STRUCT>
<FUNCTION>
<NAME>g_action_map_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_action_map_lookup_action</NAME>
<RETURNS>GAction  *               </RETURNS>
GActionMap         *action_map, const gchar        *action_name
</FUNCTION>
<FUNCTION>
<NAME>g_action_map_add_action</NAME>
<RETURNS>void                     </RETURNS>
GActionMap         *action_map, GAction            *action
</FUNCTION>
<FUNCTION>
<NAME>g_action_map_remove_action</NAME>
<RETURNS>void                     </RETURNS>
GActionMap         *action_map, const gchar        *action_name
</FUNCTION>
<FUNCTION>
<NAME>g_action_map_add_action_entries</NAME>
<RETURNS>void                     </RETURNS>
GActionMap         *action_map, const GActionEntry *entries, gint                n_entries, gpointer            user_data
</FUNCTION>
<MACRO>
<NAME>G_TYPE_APP_INFO</NAME>
#define G_TYPE_APP_INFO            (g_app_info_get_type ())
</MACRO>
<MACRO>
<NAME>G_APP_INFO</NAME>
#define G_APP_INFO(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_APP_INFO, GAppInfo))
</MACRO>
<MACRO>
<NAME>G_IS_APP_INFO</NAME>
#define G_IS_APP_INFO(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_APP_INFO))
</MACRO>
<MACRO>
<NAME>G_APP_INFO_GET_IFACE</NAME>
#define G_APP_INFO_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_APP_INFO, GAppInfoIface))
</MACRO>
<MACRO>
<NAME>G_TYPE_APP_LAUNCH_CONTEXT</NAME>
#define G_TYPE_APP_LAUNCH_CONTEXT         (g_app_launch_context_get_type ())
</MACRO>
<MACRO>
<NAME>G_APP_LAUNCH_CONTEXT</NAME>
#define G_APP_LAUNCH_CONTEXT(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContext))
</MACRO>
<MACRO>
<NAME>G_APP_LAUNCH_CONTEXT_CLASS</NAME>
#define G_APP_LAUNCH_CONTEXT_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContextClass))
</MACRO>
<MACRO>
<NAME>G_IS_APP_LAUNCH_CONTEXT</NAME>
#define G_IS_APP_LAUNCH_CONTEXT(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_APP_LAUNCH_CONTEXT))
</MACRO>
<MACRO>
<NAME>G_IS_APP_LAUNCH_CONTEXT_CLASS</NAME>
#define G_IS_APP_LAUNCH_CONTEXT_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_APP_LAUNCH_CONTEXT))
</MACRO>
<MACRO>
<NAME>G_APP_LAUNCH_CONTEXT_GET_CLASS</NAME>
#define G_APP_LAUNCH_CONTEXT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContextClass))
</MACRO>
<STRUCT>
<NAME>GAppInfoIface</NAME>
struct _GAppInfoIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  GAppInfo *   (* dup)                          (GAppInfo           *appinfo);
  gboolean     (* equal)                        (GAppInfo           *appinfo1,
                                                 GAppInfo           *appinfo2);
  const char * (* get_id)                       (GAppInfo           *appinfo);
  const char * (* get_name)                     (GAppInfo           *appinfo);
  const char * (* get_description)              (GAppInfo           *appinfo);
  const char * (* get_executable)               (GAppInfo           *appinfo);
  GIcon *      (* get_icon)                     (GAppInfo           *appinfo);
  gboolean     (* launch)                       (GAppInfo           *appinfo,
                                                 GList              *files,
                                                 GAppLaunchContext  *context,
                                                 GError            **error);
  gboolean     (* supports_uris)                (GAppInfo           *appinfo);
  gboolean     (* supports_files)               (GAppInfo           *appinfo);
  gboolean     (* launch_uris)                  (GAppInfo           *appinfo,
                                                 GList              *uris,
                                                 GAppLaunchContext  *context,
                                                 GError            **error);
  gboolean     (* should_show)                  (GAppInfo           *appinfo);

  /* For changing associations */
  gboolean     (* set_as_default_for_type)      (GAppInfo           *appinfo,
                                                 const char         *content_type,
                                                 GError            **error);
  gboolean     (* set_as_default_for_extension) (GAppInfo           *appinfo,
                                                 const char         *extension,
                                                 GError            **error);
  gboolean     (* add_supports_type)            (GAppInfo           *appinfo,
                                                 const char         *content_type,
                                                 GError            **error);
  gboolean     (* can_remove_supports_type)     (GAppInfo           *appinfo);
  gboolean     (* remove_supports_type)         (GAppInfo           *appinfo,
                                                 const char         *content_type,
                                                 GError            **error);
  gboolean     (* can_delete)                   (GAppInfo           *appinfo);
  gboolean     (* do_delete)                    (GAppInfo           *appinfo);
  const char * (* get_commandline)              (GAppInfo           *appinfo);
  const char * (* get_display_name)             (GAppInfo           *appinfo);
  gboolean     (* set_as_last_used_for_type)    (GAppInfo           *appinfo,
                                                 const char         *content_type,
                                                 GError            **error);
  const char ** (* get_supported_types)         (GAppInfo           *appinfo);
};
</STRUCT>
<FUNCTION>
<NAME>g_app_info_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_create_from_commandline</NAME>
<RETURNS>GAppInfo  *  </RETURNS>
const char           *commandline, const char           *application_name, GAppInfoCreateFlags   flags, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_dup</NAME>
<RETURNS>GAppInfo  *  </RETURNS>
GAppInfo             *appinfo
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_equal</NAME>
<RETURNS>gboolean     </RETURNS>
GAppInfo             *appinfo1, GAppInfo             *appinfo2
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_get_id</NAME>
<RETURNS>const char  *</RETURNS>
GAppInfo             *appinfo
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_get_name</NAME>
<RETURNS>const char  *</RETURNS>
GAppInfo             *appinfo
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_get_display_name</NAME>
<RETURNS>const char  *</RETURNS>
GAppInfo             *appinfo
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_get_description</NAME>
<RETURNS>const char  *</RETURNS>
GAppInfo             *appinfo
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_get_executable</NAME>
<RETURNS>const char  *</RETURNS>
GAppInfo             *appinfo
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_get_commandline</NAME>
<RETURNS>const char  *</RETURNS>
GAppInfo             *appinfo
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_get_icon</NAME>
<RETURNS>GIcon  *     </RETURNS>
GAppInfo             *appinfo
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_launch</NAME>
<RETURNS>gboolean     </RETURNS>
GAppInfo             *appinfo, GList                *files, GAppLaunchContext    *context, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_supports_uris</NAME>
<RETURNS>gboolean     </RETURNS>
GAppInfo             *appinfo
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_supports_files</NAME>
<RETURNS>gboolean     </RETURNS>
GAppInfo             *appinfo
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_launch_uris</NAME>
<RETURNS>gboolean     </RETURNS>
GAppInfo             *appinfo, GList                *uris, GAppLaunchContext    *context, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_should_show</NAME>
<RETURNS>gboolean     </RETURNS>
GAppInfo             *appinfo
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_set_as_default_for_type</NAME>
<RETURNS>gboolean     </RETURNS>
GAppInfo             *appinfo, const char           *content_type, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_set_as_default_for_extension</NAME>
<RETURNS>gboolean     </RETURNS>
GAppInfo             *appinfo, const char           *extension, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_add_supports_type</NAME>
<RETURNS>gboolean     </RETURNS>
GAppInfo             *appinfo, const char           *content_type, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_can_remove_supports_type</NAME>
<RETURNS>gboolean     </RETURNS>
GAppInfo             *appinfo
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_remove_supports_type</NAME>
<RETURNS>gboolean     </RETURNS>
GAppInfo             *appinfo, const char           *content_type, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_get_supported_types</NAME>
<RETURNS>const char  **</RETURNS>
GAppInfo             *appinfo
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_can_delete</NAME>
<RETURNS>gboolean     </RETURNS>
GAppInfo   *appinfo
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_delete</NAME>
<RETURNS>gboolean     </RETURNS>
GAppInfo   *appinfo
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_set_as_last_used_for_type</NAME>
<RETURNS>gboolean     </RETURNS>
GAppInfo             *appinfo, const char           *content_type, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_get_all</NAME>
<RETURNS>GList  *   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_get_all_for_type</NAME>
<RETURNS>GList  *   </RETURNS>
const char  *content_type
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_get_recommended_for_type</NAME>
<RETURNS>GList  *   </RETURNS>
const gchar *content_type
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_get_fallback_for_type</NAME>
<RETURNS>GList  *   </RETURNS>
const gchar *content_type
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_reset_type_associations</NAME>
<RETURNS>void       </RETURNS>
const char  *content_type
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_get_default_for_type</NAME>
<RETURNS>GAppInfo  *</RETURNS>
const char  *content_type, gboolean     must_support_uris
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_get_default_for_uri_scheme</NAME>
<RETURNS>GAppInfo  *</RETURNS>
const char  *uri_scheme
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_launch_default_for_uri</NAME>
<RETURNS>gboolean   </RETURNS>
const char              *uri, GAppLaunchContext       *context, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_launch_default_for_uri_async</NAME>
<RETURNS>void       </RETURNS>
const char           *uri, GAppLaunchContext    *context, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_launch_default_for_uri_finish</NAME>
<RETURNS>gboolean   </RETURNS>
GAsyncResult         *result, GError              **error
</FUNCTION>
<STRUCT>
<NAME>GAppLaunchContext</NAME>
struct _GAppLaunchContext
{
  GObject parent_instance;

  /*< private >*/
  GAppLaunchContextPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GAppLaunchContextClass</NAME>
struct _GAppLaunchContextClass
{
  GObjectClass parent_class;

  char * (* get_display)           (GAppLaunchContext *context,
                                    GAppInfo          *info,
                                    GList             *files);
  char * (* get_startup_notify_id) (GAppLaunchContext *context,
                                    GAppInfo          *info,
                                    GList             *files);
  void   (* launch_failed)         (GAppLaunchContext *context,
                                    const char        *startup_notify_id);
  void   (* launched)              (GAppLaunchContext *context,
                                    GAppInfo          *info,
                                    GVariant          *platform_data);

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_app_launch_context_get_type</NAME>
<RETURNS>GType               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_app_launch_context_new</NAME>
<RETURNS>GAppLaunchContext  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_app_launch_context_setenv</NAME>
<RETURNS>void                </RETURNS>
GAppLaunchContext *context, const char        *variable, const char        *value
</FUNCTION>
<FUNCTION>
<NAME>g_app_launch_context_unsetenv</NAME>
<RETURNS>void                </RETURNS>
GAppLaunchContext *context, const char        *variable
</FUNCTION>
<FUNCTION>
<NAME>g_app_launch_context_get_environment</NAME>
<RETURNS>char  **            </RETURNS>
GAppLaunchContext *context
</FUNCTION>
<FUNCTION>
<NAME>g_app_launch_context_get_display</NAME>
<RETURNS>char  *             </RETURNS>
GAppLaunchContext *context, GAppInfo          *info, GList             *files
</FUNCTION>
<FUNCTION>
<NAME>g_app_launch_context_get_startup_notify_id</NAME>
<RETURNS>char  *             </RETURNS>
GAppLaunchContext *context, GAppInfo          *info, GList             *files
</FUNCTION>
<FUNCTION>
<NAME>g_app_launch_context_launch_failed</NAME>
<RETURNS>void                </RETURNS>
GAppLaunchContext *context, const char *       startup_notify_id
</FUNCTION>
<MACRO>
<NAME>G_TYPE_APP_INFO_MONITOR</NAME>
#define G_TYPE_APP_INFO_MONITOR                             (g_app_info_monitor_get_type ())
</MACRO>
<MACRO>
<NAME>G_APP_INFO_MONITOR</NAME>
#define G_APP_INFO_MONITOR(inst)                            (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_APP_INFO_MONITOR, GAppInfoMonitor))
</MACRO>
<MACRO>
<NAME>G_IS_APP_INFO_MONITOR</NAME>
#define G_IS_APP_INFO_MONITOR(inst)                         (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_APP_INFO_MONITOR))
</MACRO>
<FUNCTION>
<NAME>g_app_info_monitor_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_monitor_get</NAME>
<RETURNS>GAppInfoMonitor  *       </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GAppInfoMonitor</NAME>
</STRUCT>
<STRUCT>
<NAME>GAppLaunchContextPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_APPLICATION</NAME>
#define G_TYPE_APPLICATION                                  (g_application_get_type ())
</MACRO>
<MACRO>
<NAME>G_APPLICATION</NAME>
#define G_APPLICATION(inst)                                 (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_APPLICATION, GApplication))
</MACRO>
<MACRO>
<NAME>G_APPLICATION_CLASS</NAME>
#define G_APPLICATION_CLASS(class)                          (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_APPLICATION, GApplicationClass))
</MACRO>
<MACRO>
<NAME>G_IS_APPLICATION</NAME>
#define G_IS_APPLICATION(inst)                              (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_APPLICATION))
</MACRO>
<MACRO>
<NAME>G_IS_APPLICATION_CLASS</NAME>
#define G_IS_APPLICATION_CLASS(class)                       (G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_APPLICATION))
</MACRO>
<MACRO>
<NAME>G_APPLICATION_GET_CLASS</NAME>
#define G_APPLICATION_GET_CLASS(inst)                       (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_APPLICATION, GApplicationClass))
</MACRO>
<STRUCT>
<NAME>GApplication</NAME>
struct _GApplication
{
  /*< private >*/
  GObject parent_instance;

  GApplicationPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GApplicationClass</NAME>
struct _GApplicationClass
{
  /*< private >*/
  GObjectClass parent_class;

  /*< public >*/
  /* signals */
  void                      (* startup)             (GApplication              *application);

  void                      (* activate)            (GApplication              *application);

  void                      (* open)                (GApplication              *application,
                                                     GFile                    **files,
                                                     gint                       n_files,
                                                     const gchar               *hint);

  int                       (* command_line)        (GApplication              *application,
                                                     GApplicationCommandLine   *command_line);

  /* vfuncs */

  /**
   * GApplicationClass::local_command_line:
   * @application: a #GApplication
   * @arguments: (inout) (array zero-terminated=1): array of command line arguments
   * @exit_status: (out): exit status to fill after processing the command line.
   *
   * This virtual function is always invoked in the local instance. It
   * gets passed a pointer to a %NULL-terminated copy of @argv and is
   * expected to remove arguments that it handled (shifting up remaining
   * arguments).
   *
   * The last argument to local_command_line() is a pointer to the @status
   * variable which can used to set the exit status that is returned from
   * g_application_run().
   *
   * See g_application_run() for more details on #GApplication startup.
   *
   * Returns: %TRUE if the commandline has been completely handled
   */
  gboolean                  (* local_command_line)  (GApplication              *application,
                                                     gchar                   ***arguments,
                                                     int                       *exit_status);

  void                      (* before_emit)         (GApplication              *application,
                                                     GVariant                  *platform_data);
  void                      (* after_emit)          (GApplication              *application,
                                                     GVariant                  *platform_data);
  void                      (* add_platform_data)   (GApplication              *application,
                                                     GVariantBuilder           *builder);
  void                      (* quit_mainloop)       (GApplication              *application);
  void                      (* run_mainloop)        (GApplication              *application);
  void                      (* shutdown)            (GApplication              *application);

  gboolean                  (* dbus_register)       (GApplication              *application,
                                                     GDBusConnection           *connection,
                                                     const gchar               *object_path,
                                                     GError                   **error);
  void                      (* dbus_unregister)     (GApplication              *application,
                                                     GDBusConnection           *connection,
                                                     const gchar               *object_path);
  gint                      (* handle_local_options)(GApplication              *application,
                                                     GVariantDict              *options);

  /*< private >*/
  gpointer padding[8];
};
</STRUCT>
<FUNCTION>
<NAME>g_application_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_application_id_is_valid</NAME>
<RETURNS>gboolean                 </RETURNS>
const gchar              *application_id
</FUNCTION>
<FUNCTION>
<NAME>g_application_new</NAME>
<RETURNS>GApplication  *          </RETURNS>
const gchar              *application_id, GApplicationFlags         flags
</FUNCTION>
<FUNCTION>
<NAME>g_application_get_application_id</NAME>
<RETURNS>const gchar  *           </RETURNS>
GApplication             *application
</FUNCTION>
<FUNCTION>
<NAME>g_application_set_application_id</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application, const gchar              *application_id
</FUNCTION>
<FUNCTION>
<NAME>g_application_get_dbus_connection</NAME>
<RETURNS>GDBusConnection  *       </RETURNS>
GApplication             *application
</FUNCTION>
<FUNCTION>
<NAME>g_application_get_dbus_object_path</NAME>
<RETURNS>const gchar  *           </RETURNS>
GApplication             *application
</FUNCTION>
<FUNCTION>
<NAME>g_application_get_inactivity_timeout</NAME>
<RETURNS>guint                    </RETURNS>
GApplication             *application
</FUNCTION>
<FUNCTION>
<NAME>g_application_set_inactivity_timeout</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application, guint                     inactivity_timeout
</FUNCTION>
<FUNCTION>
<NAME>g_application_get_flags</NAME>
<RETURNS>GApplicationFlags        </RETURNS>
GApplication             *application
</FUNCTION>
<FUNCTION>
<NAME>g_application_set_flags</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application, GApplicationFlags         flags
</FUNCTION>
<FUNCTION>
<NAME>g_application_get_resource_base_path</NAME>
<RETURNS>const gchar  *           </RETURNS>
GApplication             *application
</FUNCTION>
<FUNCTION>
<NAME>g_application_set_resource_base_path</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application, const gchar              *resource_path
</FUNCTION>
<FUNCTION>
<NAME>g_application_set_action_group</NAME>
<DEPRECATED/>
<RETURNS>void                     </RETURNS>
GApplication             *application, GActionGroup             *action_group
</FUNCTION>
<FUNCTION>
<NAME>g_application_add_main_option_entries</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application, const GOptionEntry       *entries
</FUNCTION>
<FUNCTION>
<NAME>g_application_add_main_option</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application, const char               *long_name, char                      short_name, GOptionFlags              flags, GOptionArg                arg, const char               *description, const char               *arg_description
</FUNCTION>
<FUNCTION>
<NAME>g_application_add_option_group</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application, GOptionGroup             *group
</FUNCTION>
<FUNCTION>
<NAME>g_application_set_option_context_parameter_string</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application, const gchar              *parameter_string
</FUNCTION>
<FUNCTION>
<NAME>g_application_set_option_context_summary</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application, const gchar              *summary
</FUNCTION>
<FUNCTION>
<NAME>g_application_set_option_context_description</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application, const gchar              *description
</FUNCTION>
<FUNCTION>
<NAME>g_application_get_is_registered</NAME>
<RETURNS>gboolean                 </RETURNS>
GApplication             *application
</FUNCTION>
<FUNCTION>
<NAME>g_application_get_is_remote</NAME>
<RETURNS>gboolean                 </RETURNS>
GApplication             *application
</FUNCTION>
<FUNCTION>
<NAME>g_application_register</NAME>
<RETURNS>gboolean                 </RETURNS>
GApplication             *application, GCancellable             *cancellable, GError                  **error
</FUNCTION>
<FUNCTION>
<NAME>g_application_hold</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application
</FUNCTION>
<FUNCTION>
<NAME>g_application_release</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application
</FUNCTION>
<FUNCTION>
<NAME>g_application_activate</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application
</FUNCTION>
<FUNCTION>
<NAME>g_application_open</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application, GFile                   **files, gint                      n_files, const gchar              *hint
</FUNCTION>
<FUNCTION>
<NAME>g_application_run</NAME>
<RETURNS>int                      </RETURNS>
GApplication             *application, int                       argc, char                    **argv
</FUNCTION>
<FUNCTION>
<NAME>g_application_quit</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application
</FUNCTION>
<FUNCTION>
<NAME>g_application_get_default</NAME>
<RETURNS>GApplication  *          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_application_set_default</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application
</FUNCTION>
<FUNCTION>
<NAME>g_application_mark_busy</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application
</FUNCTION>
<FUNCTION>
<NAME>g_application_unmark_busy</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application
</FUNCTION>
<FUNCTION>
<NAME>g_application_get_is_busy</NAME>
<RETURNS>gboolean                 </RETURNS>
GApplication             *application
</FUNCTION>
<FUNCTION>
<NAME>g_application_send_notification</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application, const gchar              *id, GNotification            *notification
</FUNCTION>
<FUNCTION>
<NAME>g_application_withdraw_notification</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application, const gchar              *id
</FUNCTION>
<FUNCTION>
<NAME>g_application_bind_busy_property</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application, gpointer                  object, const gchar              *property
</FUNCTION>
<FUNCTION>
<NAME>g_application_unbind_busy_property</NAME>
<RETURNS>void                     </RETURNS>
GApplication             *application, gpointer                  object, const gchar              *property
</FUNCTION>
<STRUCT>
<NAME>GApplicationPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_APPLICATION_COMMAND_LINE</NAME>
#define G_TYPE_APPLICATION_COMMAND_LINE                     (g_application_command_line_get_type ())
</MACRO>
<MACRO>
<NAME>G_APPLICATION_COMMAND_LINE</NAME>
#define G_APPLICATION_COMMAND_LINE(inst)                    (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_APPLICATION_COMMAND_LINE,                        \
                                                             GApplicationCommandLine))
</MACRO>
<MACRO>
<NAME>G_APPLICATION_COMMAND_LINE_CLASS</NAME>
#define G_APPLICATION_COMMAND_LINE_CLASS(class)             (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_APPLICATION_COMMAND_LINE,                        \
                                                             GApplicationCommandLineClass))
</MACRO>
<MACRO>
<NAME>G_IS_APPLICATION_COMMAND_LINE</NAME>
#define G_IS_APPLICATION_COMMAND_LINE(inst)                 (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_APPLICATION_COMMAND_LINE))
</MACRO>
<MACRO>
<NAME>G_IS_APPLICATION_COMMAND_LINE_CLASS</NAME>
#define G_IS_APPLICATION_COMMAND_LINE_CLASS(class)          (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_APPLICATION_COMMAND_LINE))
</MACRO>
<MACRO>
<NAME>G_APPLICATION_COMMAND_LINE_GET_CLASS</NAME>
#define G_APPLICATION_COMMAND_LINE_GET_CLASS(inst)          (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_APPLICATION_COMMAND_LINE,                        \
                                                             GApplicationCommandLineClass))
</MACRO>
<STRUCT>
<NAME>GApplicationCommandLine</NAME>
struct _GApplicationCommandLine
{
  /*< private >*/
  GObject parent_instance;

  GApplicationCommandLinePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GApplicationCommandLineClass</NAME>
struct _GApplicationCommandLineClass
{
  /*< private >*/
  GObjectClass parent_class;

  void                  (* print_literal)       (GApplicationCommandLine *cmdline,
                                                 const gchar             *message);
  void                  (* printerr_literal)    (GApplicationCommandLine *cmdline,
                                                 const gchar             *message);
  GInputStream *        (* get_stdin)           (GApplicationCommandLine *cmdline);

  gpointer padding[11];
};
</STRUCT>
<FUNCTION>
<NAME>g_application_command_line_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_application_command_line_get_arguments</NAME>
<RETURNS>gchar  **                </RETURNS>
GApplicationCommandLine   *cmdline, int                       *argc
</FUNCTION>
<FUNCTION>
<NAME>g_application_command_line_get_options_dict</NAME>
<RETURNS>GVariantDict  *          </RETURNS>
GApplicationCommandLine   *cmdline
</FUNCTION>
<FUNCTION>
<NAME>g_application_command_line_get_stdin</NAME>
<RETURNS>GInputStream  *          </RETURNS>
GApplicationCommandLine   *cmdline
</FUNCTION>
<FUNCTION>
<NAME>g_application_command_line_get_environ</NAME>
<RETURNS>const gchar  * const *</RETURNS>
GApplicationCommandLine   *cmdline
</FUNCTION>
<FUNCTION>
<NAME>g_application_command_line_getenv</NAME>
<RETURNS>const gchar  *           </RETURNS>
GApplicationCommandLine   *cmdline, const gchar               *name
</FUNCTION>
<FUNCTION>
<NAME>g_application_command_line_get_cwd</NAME>
<RETURNS>const gchar  *           </RETURNS>
GApplicationCommandLine   *cmdline
</FUNCTION>
<FUNCTION>
<NAME>g_application_command_line_get_is_remote</NAME>
<RETURNS>gboolean                 </RETURNS>
GApplicationCommandLine   *cmdline
</FUNCTION>
<FUNCTION>
<NAME>g_application_command_line_print</NAME>
<RETURNS>void                     </RETURNS>
GApplicationCommandLine   *cmdline, const gchar               *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_application_command_line_printerr</NAME>
<RETURNS>void                     </RETURNS>
GApplicationCommandLine   *cmdline, const gchar               *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_application_command_line_get_exit_status</NAME>
<RETURNS>int                      </RETURNS>
GApplicationCommandLine   *cmdline
</FUNCTION>
<FUNCTION>
<NAME>g_application_command_line_set_exit_status</NAME>
<RETURNS>void                     </RETURNS>
GApplicationCommandLine   *cmdline, int                        exit_status
</FUNCTION>
<FUNCTION>
<NAME>g_application_command_line_get_platform_data</NAME>
<RETURNS>GVariant  *              </RETURNS>
GApplicationCommandLine   *cmdline
</FUNCTION>
<FUNCTION>
<NAME>g_application_command_line_create_file_for_arg</NAME>
<RETURNS>GFile  *                 </RETURNS>
GApplicationCommandLine   *cmdline, const gchar               *arg
</FUNCTION>
<STRUCT>
<NAME>GApplicationCommandLinePrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_ASYNC_INITABLE</NAME>
#define G_TYPE_ASYNC_INITABLE            (g_async_initable_get_type ())
</MACRO>
<MACRO>
<NAME>G_ASYNC_INITABLE</NAME>
#define G_ASYNC_INITABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_ASYNC_INITABLE, GAsyncInitable))
</MACRO>
<MACRO>
<NAME>G_IS_ASYNC_INITABLE</NAME>
#define G_IS_ASYNC_INITABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_ASYNC_INITABLE))
</MACRO>
<MACRO>
<NAME>G_ASYNC_INITABLE_GET_IFACE</NAME>
#define G_ASYNC_INITABLE_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_ASYNC_INITABLE, GAsyncInitableIface))
</MACRO>
<MACRO>
<NAME>G_TYPE_IS_ASYNC_INITABLE</NAME>
#define G_TYPE_IS_ASYNC_INITABLE(type)   (g_type_is_a ((type), G_TYPE_ASYNC_INITABLE))
</MACRO>
<STRUCT>
<NAME>GAsyncInitableIface</NAME>
struct _GAsyncInitableIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  void     (* init_async)  (GAsyncInitable      *initable,
			    int                  io_priority,
			    GCancellable        *cancellable,
			    GAsyncReadyCallback  callback,
			    gpointer             user_data);
  gboolean (* init_finish) (GAsyncInitable      *initable,
			    GAsyncResult        *res,
			    GError             **error);
};
</STRUCT>
<FUNCTION>
<NAME>g_async_initable_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_async_initable_init_async</NAME>
<RETURNS>void      </RETURNS>
GAsyncInitable       *initable, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_async_initable_init_finish</NAME>
<RETURNS>gboolean  </RETURNS>
GAsyncInitable       *initable, GAsyncResult         *res, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_async_initable_new_async</NAME>
<RETURNS>void      </RETURNS>
GType                 object_type, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data, const gchar          *first_property_name, ...
</FUNCTION>
<FUNCTION>
<NAME>g_async_initable_newv_async</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GType                 object_type, guint                 n_parameters, GParameter           *parameters, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_async_initable_new_valist_async</NAME>
<RETURNS>void      </RETURNS>
GType                 object_type, const gchar          *first_property_name, va_list               var_args, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_async_initable_new_finish</NAME>
<RETURNS>GObject  *</RETURNS>
GAsyncInitable       *initable, GAsyncResult         *res, GError              **error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_ASYNC_RESULT</NAME>
#define G_TYPE_ASYNC_RESULT            (g_async_result_get_type ())
</MACRO>
<MACRO>
<NAME>G_ASYNC_RESULT</NAME>
#define G_ASYNC_RESULT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_ASYNC_RESULT, GAsyncResult))
</MACRO>
<MACRO>
<NAME>G_IS_ASYNC_RESULT</NAME>
#define G_IS_ASYNC_RESULT(obj)	       (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_ASYNC_RESULT))
</MACRO>
<MACRO>
<NAME>G_ASYNC_RESULT_GET_IFACE</NAME>
#define G_ASYNC_RESULT_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_ASYNC_RESULT, GAsyncResultIface))
</MACRO>
<STRUCT>
<NAME>GAsyncResultIface</NAME>
struct _GAsyncResultIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  gpointer  (* get_user_data)     (GAsyncResult *res);
  GObject * (* get_source_object) (GAsyncResult *res);

  gboolean  (* is_tagged)         (GAsyncResult *res,
				   gpointer      source_tag);
};
</STRUCT>
<FUNCTION>
<NAME>g_async_result_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_async_result_get_user_data</NAME>
<RETURNS>gpointer  </RETURNS>
GAsyncResult *res
</FUNCTION>
<FUNCTION>
<NAME>g_async_result_get_source_object</NAME>
<RETURNS>GObject  *</RETURNS>
GAsyncResult *res
</FUNCTION>
<FUNCTION>
<NAME>g_async_result_legacy_propagate_error</NAME>
<RETURNS>gboolean  </RETURNS>
GAsyncResult  *res, GError       **error
</FUNCTION>
<FUNCTION>
<NAME>g_async_result_is_tagged</NAME>
<RETURNS>gboolean  </RETURNS>
GAsyncResult  *res, gpointer       source_tag
</FUNCTION>
<MACRO>
<NAME>G_TYPE_BUFFERED_INPUT_STREAM</NAME>
#define G_TYPE_BUFFERED_INPUT_STREAM         (g_buffered_input_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_BUFFERED_INPUT_STREAM</NAME>
#define G_BUFFERED_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_BUFFERED_INPUT_STREAM, GBufferedInputStream))
</MACRO>
<MACRO>
<NAME>G_BUFFERED_INPUT_STREAM_CLASS</NAME>
#define G_BUFFERED_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_BUFFERED_INPUT_STREAM, GBufferedInputStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_BUFFERED_INPUT_STREAM</NAME>
#define G_IS_BUFFERED_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_BUFFERED_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_BUFFERED_INPUT_STREAM_CLASS</NAME>
#define G_IS_BUFFERED_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_BUFFERED_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_BUFFERED_INPUT_STREAM_GET_CLASS</NAME>
#define G_BUFFERED_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_BUFFERED_INPUT_STREAM, GBufferedInputStreamClass))
</MACRO>
<STRUCT>
<NAME>GBufferedInputStream</NAME>
struct _GBufferedInputStream
{
  GFilterInputStream parent_instance;

  /*< private >*/
  GBufferedInputStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GBufferedInputStreamClass</NAME>
struct _GBufferedInputStreamClass
{
  GFilterInputStreamClass parent_class;

  gssize   (* fill)        (GBufferedInputStream *stream,
			    gssize                count,
			    GCancellable         *cancellable,
			    GError              **error);

  /* Async ops: (optional in derived classes) */
  void     (* fill_async)  (GBufferedInputStream *stream,
			    gssize                count,
			    int                   io_priority,
			    GCancellable         *cancellable,
			    GAsyncReadyCallback   callback,
			    gpointer              user_data);
  gssize   (* fill_finish) (GBufferedInputStream *stream,
			    GAsyncResult         *result,
			    GError              **error);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_buffered_input_stream_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_input_stream_new</NAME>
<RETURNS>GInputStream * </RETURNS>
GInputStream          *base_stream
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_input_stream_new_sized</NAME>
<RETURNS>GInputStream * </RETURNS>
GInputStream          *base_stream, gsize                  size
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_input_stream_get_buffer_size</NAME>
<RETURNS>gsize          </RETURNS>
GBufferedInputStream  *stream
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_input_stream_set_buffer_size</NAME>
<RETURNS>void           </RETURNS>
GBufferedInputStream  *stream, gsize                  size
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_input_stream_get_available</NAME>
<RETURNS>gsize          </RETURNS>
GBufferedInputStream  *stream
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_input_stream_peek</NAME>
<RETURNS>gsize          </RETURNS>
GBufferedInputStream  *stream, void                  *buffer, gsize                  offset, gsize                  count
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_input_stream_peek_buffer</NAME>
<RETURNS>const void *   </RETURNS>
GBufferedInputStream  *stream, gsize                 *count
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_input_stream_fill</NAME>
<RETURNS>gssize         </RETURNS>
GBufferedInputStream  *stream, gssize                 count, GCancellable          *cancellable, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_input_stream_fill_async</NAME>
<RETURNS>void           </RETURNS>
GBufferedInputStream  *stream, gssize                 count, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_input_stream_fill_finish</NAME>
<RETURNS>gssize         </RETURNS>
GBufferedInputStream  *stream, GAsyncResult          *result, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_input_stream_read_byte</NAME>
<RETURNS>int            </RETURNS>
GBufferedInputStream  *stream, GCancellable          *cancellable, GError               **error
</FUNCTION>
<STRUCT>
<NAME>GBufferedInputStreamPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_BUFFERED_OUTPUT_STREAM</NAME>
#define G_TYPE_BUFFERED_OUTPUT_STREAM         (g_buffered_output_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_BUFFERED_OUTPUT_STREAM</NAME>
#define G_BUFFERED_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_BUFFERED_OUTPUT_STREAM, GBufferedOutputStream))
</MACRO>
<MACRO>
<NAME>G_BUFFERED_OUTPUT_STREAM_CLASS</NAME>
#define G_BUFFERED_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_BUFFERED_OUTPUT_STREAM, GBufferedOutputStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_BUFFERED_OUTPUT_STREAM</NAME>
#define G_IS_BUFFERED_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_BUFFERED_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_BUFFERED_OUTPUT_STREAM_CLASS</NAME>
#define G_IS_BUFFERED_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_BUFFERED_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_BUFFERED_OUTPUT_STREAM_GET_CLASS</NAME>
#define G_BUFFERED_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_BUFFERED_OUTPUT_STREAM, GBufferedOutputStreamClass))
</MACRO>
<STRUCT>
<NAME>GBufferedOutputStream</NAME>
struct _GBufferedOutputStream
{
  GFilterOutputStream parent_instance;

  /*< protected >*/
  GBufferedOutputStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GBufferedOutputStreamClass</NAME>
struct _GBufferedOutputStreamClass
{
  GFilterOutputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_buffered_output_stream_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_output_stream_new</NAME>
<RETURNS>GOutputStream * </RETURNS>
GOutputStream         *base_stream
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_output_stream_new_sized</NAME>
<RETURNS>GOutputStream * </RETURNS>
GOutputStream         *base_stream, gsize                  size
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_output_stream_get_buffer_size</NAME>
<RETURNS>gsize           </RETURNS>
GBufferedOutputStream *stream
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_output_stream_set_buffer_size</NAME>
<RETURNS>void            </RETURNS>
GBufferedOutputStream *stream, gsize                  size
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_output_stream_get_auto_grow</NAME>
<RETURNS>gboolean        </RETURNS>
GBufferedOutputStream *stream
</FUNCTION>
<FUNCTION>
<NAME>g_buffered_output_stream_set_auto_grow</NAME>
<RETURNS>void            </RETURNS>
GBufferedOutputStream *stream, gboolean               auto_grow
</FUNCTION>
<STRUCT>
<NAME>GBufferedOutputStreamPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_BYTES_ICON</NAME>
#define G_TYPE_BYTES_ICON         (g_bytes_icon_get_type ())
</MACRO>
<MACRO>
<NAME>G_BYTES_ICON</NAME>
#define G_BYTES_ICON(inst)        (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_BYTES_ICON, GBytesIcon))
</MACRO>
<MACRO>
<NAME>G_IS_BYTES_ICON</NAME>
#define G_IS_BYTES_ICON(inst)     (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_BYTES_ICON))
</MACRO>
<FUNCTION>
<NAME>g_bytes_icon_get_type</NAME>
<RETURNS>GType    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_bytes_icon_new</NAME>
<RETURNS>GIcon  * </RETURNS>
GBytes     *bytes
</FUNCTION>
<FUNCTION>
<NAME>g_bytes_icon_get_bytes</NAME>
<RETURNS>GBytes  * </RETURNS>
GBytesIcon *icon
</FUNCTION>
<MACRO>
<NAME>G_TYPE_CANCELLABLE</NAME>
#define G_TYPE_CANCELLABLE         (g_cancellable_get_type ())
</MACRO>
<MACRO>
<NAME>G_CANCELLABLE</NAME>
#define G_CANCELLABLE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_CANCELLABLE, GCancellable))
</MACRO>
<MACRO>
<NAME>G_CANCELLABLE_CLASS</NAME>
#define G_CANCELLABLE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_CANCELLABLE, GCancellableClass))
</MACRO>
<MACRO>
<NAME>G_IS_CANCELLABLE</NAME>
#define G_IS_CANCELLABLE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_CANCELLABLE))
</MACRO>
<MACRO>
<NAME>G_IS_CANCELLABLE_CLASS</NAME>
#define G_IS_CANCELLABLE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_CANCELLABLE))
</MACRO>
<MACRO>
<NAME>G_CANCELLABLE_GET_CLASS</NAME>
#define G_CANCELLABLE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_CANCELLABLE, GCancellableClass))
</MACRO>
<STRUCT>
<NAME>GCancellable</NAME>
struct _GCancellable
{
  GObject parent_instance;

  /*< private >*/
  GCancellablePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GCancellableClass</NAME>
struct _GCancellableClass
{
  GObjectClass parent_class;

  void (* cancelled) (GCancellable *cancellable);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_cancellable_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_cancellable_new</NAME>
<RETURNS>GCancellable  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_cancellable_is_cancelled</NAME>
<RETURNS>gboolean       </RETURNS>
GCancellable  *cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_cancellable_set_error_if_cancelled</NAME>
<RETURNS>gboolean       </RETURNS>
GCancellable  *cancellable, GError       **error
</FUNCTION>
<FUNCTION>
<NAME>g_cancellable_get_fd</NAME>
<RETURNS>int            </RETURNS>
GCancellable  *cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_cancellable_make_pollfd</NAME>
<RETURNS>gboolean       </RETURNS>
GCancellable  *cancellable, GPollFD       *pollfd
</FUNCTION>
<FUNCTION>
<NAME>g_cancellable_release_fd</NAME>
<RETURNS>void           </RETURNS>
GCancellable  *cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_cancellable_source_new</NAME>
<RETURNS>GSource  *     </RETURNS>
GCancellable  *cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_cancellable_get_current</NAME>
<RETURNS>GCancellable  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_cancellable_push_current</NAME>
<RETURNS>void           </RETURNS>
GCancellable  *cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_cancellable_pop_current</NAME>
<RETURNS>void           </RETURNS>
GCancellable  *cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_cancellable_reset</NAME>
<RETURNS>void           </RETURNS>
GCancellable  *cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_cancellable_connect</NAME>
<RETURNS>gulong         </RETURNS>
GCancellable  *cancellable, GCallback      callback, gpointer       data, GDestroyNotify data_destroy_func
</FUNCTION>
<FUNCTION>
<NAME>g_cancellable_disconnect</NAME>
<RETURNS>void           </RETURNS>
GCancellable  *cancellable, gulong         handler_id
</FUNCTION>
<FUNCTION>
<NAME>g_cancellable_cancel</NAME>
<RETURNS>void           </RETURNS>
GCancellable  *cancellable
</FUNCTION>
<STRUCT>
<NAME>GCancellablePrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_CHARSET_CONVERTER</NAME>
#define G_TYPE_CHARSET_CONVERTER         (g_charset_converter_get_type ())
</MACRO>
<MACRO>
<NAME>G_CHARSET_CONVERTER</NAME>
#define G_CHARSET_CONVERTER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_CHARSET_CONVERTER, GCharsetConverter))
</MACRO>
<MACRO>
<NAME>G_CHARSET_CONVERTER_CLASS</NAME>
#define G_CHARSET_CONVERTER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_CHARSET_CONVERTER, GCharsetConverterClass))
</MACRO>
<MACRO>
<NAME>G_IS_CHARSET_CONVERTER</NAME>
#define G_IS_CHARSET_CONVERTER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_CHARSET_CONVERTER))
</MACRO>
<MACRO>
<NAME>G_IS_CHARSET_CONVERTER_CLASS</NAME>
#define G_IS_CHARSET_CONVERTER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_CHARSET_CONVERTER))
</MACRO>
<MACRO>
<NAME>G_CHARSET_CONVERTER_GET_CLASS</NAME>
#define G_CHARSET_CONVERTER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_CHARSET_CONVERTER, GCharsetConverterClass))
</MACRO>
<STRUCT>
<NAME>GCharsetConverterClass</NAME>
struct _GCharsetConverterClass
{
  GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>g_charset_converter_get_type</NAME>
<RETURNS>GType               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_charset_converter_new</NAME>
<RETURNS>GCharsetConverter  *</RETURNS>
const gchar  *to_charset, const gchar  *from_charset, GError **error
</FUNCTION>
<FUNCTION>
<NAME>g_charset_converter_set_use_fallback</NAME>
<RETURNS>void                </RETURNS>
GCharsetConverter *converter, gboolean use_fallback
</FUNCTION>
<FUNCTION>
<NAME>g_charset_converter_get_use_fallback</NAME>
<RETURNS>gboolean            </RETURNS>
GCharsetConverter *converter
</FUNCTION>
<FUNCTION>
<NAME>g_charset_converter_get_num_fallbacks</NAME>
<RETURNS>guint               </RETURNS>
GCharsetConverter *converter
</FUNCTION>
<FUNCTION>
<NAME>g_content_type_equals</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *type1, const gchar  *type2
</FUNCTION>
<FUNCTION>
<NAME>g_content_type_is_a</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *type, const gchar  *supertype
</FUNCTION>
<FUNCTION>
<NAME>g_content_type_is_mime_type</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *type, const gchar *mime_type
</FUNCTION>
<FUNCTION>
<NAME>g_content_type_is_unknown</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *type
</FUNCTION>
<FUNCTION>
<NAME>g_content_type_get_description</NAME>
<RETURNS>gchar  *  </RETURNS>
const gchar  *type
</FUNCTION>
<FUNCTION>
<NAME>g_content_type_get_mime_type</NAME>
<RETURNS>gchar  *  </RETURNS>
const gchar  *type
</FUNCTION>
<FUNCTION>
<NAME>g_content_type_get_icon</NAME>
<RETURNS>GIcon  *  </RETURNS>
const gchar  *type
</FUNCTION>
<FUNCTION>
<NAME>g_content_type_get_symbolic_icon</NAME>
<RETURNS>GIcon  *  </RETURNS>
const gchar  *type
</FUNCTION>
<FUNCTION>
<NAME>g_content_type_get_generic_icon_name</NAME>
<RETURNS>gchar  *  </RETURNS>
const gchar  *type
</FUNCTION>
<FUNCTION>
<NAME>g_content_type_can_be_executable</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *type
</FUNCTION>
<FUNCTION>
<NAME>g_content_type_from_mime_type</NAME>
<RETURNS>gchar  *  </RETURNS>
const gchar  *mime_type
</FUNCTION>
<FUNCTION>
<NAME>g_content_type_guess</NAME>
<RETURNS>gchar  *  </RETURNS>
const gchar  *filename, const guchar *data, gsize         data_size, gboolean     *result_uncertain
</FUNCTION>
<FUNCTION>
<NAME>g_content_type_guess_for_tree</NAME>
<RETURNS>gchar  ** </RETURNS>
GFile        *root
</FUNCTION>
<FUNCTION>
<NAME>g_content_types_get_registered</NAME>
<RETURNS>GList  *  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_CONVERTER</NAME>
#define G_TYPE_CONVERTER            (g_converter_get_type ())
</MACRO>
<MACRO>
<NAME>G_CONVERTER</NAME>
#define G_CONVERTER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_CONVERTER, GConverter))
</MACRO>
<MACRO>
<NAME>G_IS_CONVERTER</NAME>
#define G_IS_CONVERTER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_CONVERTER))
</MACRO>
<MACRO>
<NAME>G_CONVERTER_GET_IFACE</NAME>
#define G_CONVERTER_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_CONVERTER, GConverterIface))
</MACRO>
<STRUCT>
<NAME>GConverterIface</NAME>
struct _GConverterIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  GConverterResult (* convert) (GConverter *converter,
				const void *inbuf,
				gsize       inbuf_size,
				void       *outbuf,
				gsize       outbuf_size,
				GConverterFlags flags,
				gsize      *bytes_read,
				gsize      *bytes_written,
				GError    **error);
  void  (* reset)   (GConverter *converter);
};
</STRUCT>
<FUNCTION>
<NAME>g_converter_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_converter_convert</NAME>
<RETURNS>GConverterResult  </RETURNS>
GConverter       *converter, const void       *inbuf, gsize             inbuf_size, void             *outbuf, gsize             outbuf_size, GConverterFlags   flags, gsize            *bytes_read, gsize            *bytes_written, GError          **error
</FUNCTION>
<FUNCTION>
<NAME>g_converter_reset</NAME>
<RETURNS>void              </RETURNS>
GConverter       *converter
</FUNCTION>
<MACRO>
<NAME>G_TYPE_CONVERTER_INPUT_STREAM</NAME>
#define G_TYPE_CONVERTER_INPUT_STREAM         (g_converter_input_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_CONVERTER_INPUT_STREAM</NAME>
#define G_CONVERTER_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_CONVERTER_INPUT_STREAM, GConverterInputStream))
</MACRO>
<MACRO>
<NAME>G_CONVERTER_INPUT_STREAM_CLASS</NAME>
#define G_CONVERTER_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_CONVERTER_INPUT_STREAM, GConverterInputStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_CONVERTER_INPUT_STREAM</NAME>
#define G_IS_CONVERTER_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_CONVERTER_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_CONVERTER_INPUT_STREAM_CLASS</NAME>
#define G_IS_CONVERTER_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_CONVERTER_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_CONVERTER_INPUT_STREAM_GET_CLASS</NAME>
#define G_CONVERTER_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_CONVERTER_INPUT_STREAM, GConverterInputStreamClass))
</MACRO>
<STRUCT>
<NAME>GConverterInputStream</NAME>
struct _GConverterInputStream
{
  GFilterInputStream parent_instance;

  /*< private >*/
  GConverterInputStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GConverterInputStreamClass</NAME>
struct _GConverterInputStreamClass
{
  GFilterInputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_converter_input_stream_get_type</NAME>
<RETURNS>GType                   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_converter_input_stream_new</NAME>
<RETURNS>GInputStream           *</RETURNS>
GInputStream          *base_stream, GConverter            *converter
</FUNCTION>
<FUNCTION>
<NAME>g_converter_input_stream_get_converter</NAME>
<RETURNS>GConverter             *</RETURNS>
GConverterInputStream *converter_stream
</FUNCTION>
<STRUCT>
<NAME>GConverterInputStreamPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_CONVERTER_OUTPUT_STREAM</NAME>
#define G_TYPE_CONVERTER_OUTPUT_STREAM         (g_converter_output_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_CONVERTER_OUTPUT_STREAM</NAME>
#define G_CONVERTER_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_CONVERTER_OUTPUT_STREAM, GConverterOutputStream))
</MACRO>
<MACRO>
<NAME>G_CONVERTER_OUTPUT_STREAM_CLASS</NAME>
#define G_CONVERTER_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_CONVERTER_OUTPUT_STREAM, GConverterOutputStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_CONVERTER_OUTPUT_STREAM</NAME>
#define G_IS_CONVERTER_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_CONVERTER_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_CONVERTER_OUTPUT_STREAM_CLASS</NAME>
#define G_IS_CONVERTER_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_CONVERTER_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_CONVERTER_OUTPUT_STREAM_GET_CLASS</NAME>
#define G_CONVERTER_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_CONVERTER_OUTPUT_STREAM, GConverterOutputStreamClass))
</MACRO>
<STRUCT>
<NAME>GConverterOutputStream</NAME>
struct _GConverterOutputStream
{
  GFilterOutputStream parent_instance;

  /*< private >*/
  GConverterOutputStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GConverterOutputStreamClass</NAME>
struct _GConverterOutputStreamClass
{
  GFilterOutputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_converter_output_stream_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_converter_output_stream_new</NAME>
<RETURNS>GOutputStream           *</RETURNS>
GOutputStream         *base_stream, GConverter            *converter
</FUNCTION>
<FUNCTION>
<NAME>g_converter_output_stream_get_converter</NAME>
<RETURNS>GConverter              *</RETURNS>
GConverterOutputStream *converter_stream
</FUNCTION>
<STRUCT>
<NAME>GConverterOutputStreamPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_CREDENTIALS</NAME>
#define G_TYPE_CREDENTIALS         (g_credentials_get_type ())
</MACRO>
<MACRO>
<NAME>G_CREDENTIALS</NAME>
#define G_CREDENTIALS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_CREDENTIALS, GCredentials))
</MACRO>
<MACRO>
<NAME>G_CREDENTIALS_CLASS</NAME>
#define G_CREDENTIALS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_CREDENTIALS, GCredentialsClass))
</MACRO>
<MACRO>
<NAME>G_CREDENTIALS_GET_CLASS</NAME>
#define G_CREDENTIALS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_CREDENTIALS, GCredentialsClass))
</MACRO>
<MACRO>
<NAME>G_IS_CREDENTIALS</NAME>
#define G_IS_CREDENTIALS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_CREDENTIALS))
</MACRO>
<MACRO>
<NAME>G_IS_CREDENTIALS_CLASS</NAME>
#define G_IS_CREDENTIALS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_CREDENTIALS))
</MACRO>
<FUNCTION>
<NAME>g_credentials_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_credentials_new</NAME>
<RETURNS>GCredentials     *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_credentials_to_string</NAME>
<RETURNS>gchar            *</RETURNS>
GCredentials    *credentials
</FUNCTION>
<FUNCTION>
<NAME>g_credentials_get_native</NAME>
<RETURNS>gpointer          </RETURNS>
GCredentials    *credentials, GCredentialsType native_type
</FUNCTION>
<FUNCTION>
<NAME>g_credentials_set_native</NAME>
<RETURNS>void              </RETURNS>
GCredentials    *credentials, GCredentialsType native_type, gpointer         native
</FUNCTION>
<FUNCTION>
<NAME>g_credentials_is_same_user</NAME>
<RETURNS>gboolean          </RETURNS>
GCredentials    *credentials, GCredentials    *other_credentials, GError         **error
</FUNCTION>
<FUNCTION>
<NAME>g_credentials_get_unix_pid</NAME>
<RETURNS>pid_t             </RETURNS>
GCredentials    *credentials, GError         **error
</FUNCTION>
<FUNCTION>
<NAME>g_credentials_get_unix_user</NAME>
<RETURNS>uid_t             </RETURNS>
GCredentials    *credentials, GError         **error
</FUNCTION>
<FUNCTION>
<NAME>g_credentials_set_unix_user</NAME>
<RETURNS>gboolean          </RETURNS>
GCredentials    *credentials, uid_t           uid, GError         **error
</FUNCTION>
<STRUCT>
<NAME>GCredentialsClass</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_DATAGRAM_BASED</NAME>
#define G_TYPE_DATAGRAM_BASED             (g_datagram_based_get_type ())
</MACRO>
<MACRO>
<NAME>G_DATAGRAM_BASED</NAME>
#define G_DATAGRAM_BASED(inst)            (G_TYPE_CHECK_INSTANCE_CAST ((inst), \
                                           G_TYPE_DATAGRAM_BASED, GDatagramBased))
</MACRO>
<MACRO>
<NAME>G_IS_DATAGRAM_BASED</NAME>
#define G_IS_DATAGRAM_BASED(inst)         (G_TYPE_CHECK_INSTANCE_TYPE ((inst), \
                                           G_TYPE_DATAGRAM_BASED))
</MACRO>
<MACRO>
<NAME>G_DATAGRAM_BASED_GET_IFACE</NAME>
#define G_DATAGRAM_BASED_GET_IFACE(inst)  (G_TYPE_INSTANCE_GET_INTERFACE ((inst), \
                                           G_TYPE_DATAGRAM_BASED, \
                                           GDatagramBasedInterface))
</MACRO>
<MACRO>
<NAME>G_TYPE_IS_DATAGRAM_BASED</NAME>
#define G_TYPE_IS_DATAGRAM_BASED(type)    (g_type_is_a ((type), \
                                           G_TYPE_DATAGRAM_BASED))
</MACRO>
<STRUCT>
<NAME>GDatagramBasedInterface</NAME>
struct _GDatagramBasedInterface
{
  GTypeInterface g_iface;

  /* Virtual table */
  gint          (*receive_messages)     (GDatagramBased       *datagram_based,
                                         GInputMessage        *messages,
                                         guint                 num_messages,
                                         gint                  flags,
                                         gint64                timeout,
                                         GCancellable         *cancellable,
                                         GError              **error);
  gint          (*send_messages)        (GDatagramBased       *datagram_based,
                                         GOutputMessage       *messages,
                                         guint                 num_messages,
                                         gint                  flags,
                                         gint64                timeout,
                                         GCancellable         *cancellable,
                                         GError              **error);

  GSource      *(*create_source)        (GDatagramBased       *datagram_based,
                                         GIOCondition          condition,
                                         GCancellable         *cancellable);
  GIOCondition  (*condition_check)      (GDatagramBased       *datagram_based,
                                         GIOCondition          condition);
  gboolean      (*condition_wait)       (GDatagramBased       *datagram_based,
                                         GIOCondition          condition,
                                         gint64                timeout,
                                         GCancellable         *cancellable,
                                         GError              **error);
};
</STRUCT>
<FUNCTION>
<NAME>g_datagram_based_get_type</NAME>
<RETURNS>GType</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_datagram_based_receive_messages</NAME>
<RETURNS>gint</RETURNS>
GDatagramBased       *datagram_based, GInputMessage        *messages, guint                 num_messages, gint                  flags, gint64                timeout, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_datagram_based_send_messages</NAME>
<RETURNS>gint</RETURNS>
GDatagramBased       *datagram_based, GOutputMessage       *messages, guint                 num_messages, gint                  flags, gint64                timeout, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_datagram_based_create_source</NAME>
<RETURNS>GSource  *</RETURNS>
GDatagramBased       *datagram_based, GIOCondition          condition, GCancellable         *cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_datagram_based_condition_check</NAME>
<RETURNS>GIOCondition</RETURNS>
GDatagramBased       *datagram_based, GIOCondition          condition
</FUNCTION>
<FUNCTION>
<NAME>g_datagram_based_condition_wait</NAME>
<RETURNS>gboolean</RETURNS>
GDatagramBased       *datagram_based, GIOCondition          condition, gint64                timeout, GCancellable         *cancellable, GError              **error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DATA_INPUT_STREAM</NAME>
#define G_TYPE_DATA_INPUT_STREAM         (g_data_input_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_DATA_INPUT_STREAM</NAME>
#define G_DATA_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DATA_INPUT_STREAM, GDataInputStream))
</MACRO>
<MACRO>
<NAME>G_DATA_INPUT_STREAM_CLASS</NAME>
#define G_DATA_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DATA_INPUT_STREAM, GDataInputStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_DATA_INPUT_STREAM</NAME>
#define G_IS_DATA_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DATA_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_DATA_INPUT_STREAM_CLASS</NAME>
#define G_IS_DATA_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DATA_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_DATA_INPUT_STREAM_GET_CLASS</NAME>
#define G_DATA_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DATA_INPUT_STREAM, GDataInputStreamClass))
</MACRO>
<STRUCT>
<NAME>GDataInputStream</NAME>
struct _GDataInputStream
{
  GBufferedInputStream parent_instance;

  /*< private >*/
  GDataInputStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GDataInputStreamClass</NAME>
struct _GDataInputStreamClass
{
  GBufferedInputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_data_input_stream_get_type</NAME>
<RETURNS>GType                   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_new</NAME>
<RETURNS>GDataInputStream  *     </RETURNS>
GInputStream            *base_stream
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_set_byte_order</NAME>
<RETURNS>void                    </RETURNS>
GDataInputStream        *stream, GDataStreamByteOrder     order
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_get_byte_order</NAME>
<RETURNS>GDataStreamByteOrder    </RETURNS>
GDataInputStream        *stream
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_set_newline_type</NAME>
<RETURNS>void                    </RETURNS>
GDataInputStream        *stream, GDataStreamNewlineType   type
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_get_newline_type</NAME>
<RETURNS>GDataStreamNewlineType  </RETURNS>
GDataInputStream        *stream
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_byte</NAME>
<RETURNS>guchar                  </RETURNS>
GDataInputStream        *stream, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_int16</NAME>
<RETURNS>gint16                  </RETURNS>
GDataInputStream        *stream, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_uint16</NAME>
<RETURNS>guint16                 </RETURNS>
GDataInputStream        *stream, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_int32</NAME>
<RETURNS>gint32                  </RETURNS>
GDataInputStream        *stream, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_uint32</NAME>
<RETURNS>guint32                 </RETURNS>
GDataInputStream        *stream, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_int64</NAME>
<RETURNS>gint64                  </RETURNS>
GDataInputStream        *stream, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_uint64</NAME>
<RETURNS>guint64                 </RETURNS>
GDataInputStream        *stream, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_line</NAME>
<RETURNS>char  *                 </RETURNS>
GDataInputStream        *stream, gsize                   *length, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_line_utf8</NAME>
<RETURNS>char  *                 </RETURNS>
GDataInputStream        *stream, gsize                   *length, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_line_async</NAME>
<RETURNS>void                    </RETURNS>
GDataInputStream        *stream, gint                     io_priority, GCancellable            *cancellable, GAsyncReadyCallback      callback, gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_line_finish</NAME>
<RETURNS>char  *                 </RETURNS>
GDataInputStream        *stream, GAsyncResult            *result, gsize                   *length, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_line_finish_utf8</NAME>
<RETURNS>char  *                 </RETURNS>
GDataInputStream        *stream, GAsyncResult            *result, gsize                   *length, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_until</NAME>
<DEPRECATED/>
<RETURNS>char  *                 </RETURNS>
GDataInputStream        *stream, const gchar             *stop_chars, gsize                   *length, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_until_async</NAME>
<DEPRECATED/>
<RETURNS>void                    </RETURNS>
GDataInputStream        *stream, const gchar             *stop_chars, gint                     io_priority, GCancellable            *cancellable, GAsyncReadyCallback      callback, gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_until_finish</NAME>
<DEPRECATED/>
<RETURNS>char  *                 </RETURNS>
GDataInputStream        *stream, GAsyncResult            *result, gsize                   *length, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_upto</NAME>
<RETURNS>char  *                 </RETURNS>
GDataInputStream        *stream, const gchar             *stop_chars, gssize                   stop_chars_len, gsize                   *length, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_upto_async</NAME>
<RETURNS>void                    </RETURNS>
GDataInputStream        *stream, const gchar             *stop_chars, gssize                   stop_chars_len, gint                     io_priority, GCancellable            *cancellable, GAsyncReadyCallback      callback, gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>g_data_input_stream_read_upto_finish</NAME>
<RETURNS>char  *                 </RETURNS>
GDataInputStream        *stream, GAsyncResult            *result, gsize                   *length, GError                 **error
</FUNCTION>
<STRUCT>
<NAME>GDataInputStreamPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_DATA_OUTPUT_STREAM</NAME>
#define G_TYPE_DATA_OUTPUT_STREAM         (g_data_output_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_DATA_OUTPUT_STREAM</NAME>
#define G_DATA_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DATA_OUTPUT_STREAM, GDataOutputStream))
</MACRO>
<MACRO>
<NAME>G_DATA_OUTPUT_STREAM_CLASS</NAME>
#define G_DATA_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DATA_OUTPUT_STREAM, GDataOutputStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_DATA_OUTPUT_STREAM</NAME>
#define G_IS_DATA_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DATA_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_DATA_OUTPUT_STREAM_CLASS</NAME>
#define G_IS_DATA_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DATA_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_DATA_OUTPUT_STREAM_GET_CLASS</NAME>
#define G_DATA_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DATA_OUTPUT_STREAM, GDataOutputStreamClass))
</MACRO>
<STRUCT>
<NAME>GDataOutputStream</NAME>
struct _GDataOutputStream
{
  GFilterOutputStream parent_instance;

  /*< private >*/
  GDataOutputStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GDataOutputStreamClass</NAME>
struct _GDataOutputStreamClass
{
  GFilterOutputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_data_output_stream_get_type</NAME>
<RETURNS>GType                 </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_data_output_stream_new</NAME>
<RETURNS>GDataOutputStream  *  </RETURNS>
GOutputStream         *base_stream
</FUNCTION>
<FUNCTION>
<NAME>g_data_output_stream_set_byte_order</NAME>
<RETURNS>void                  </RETURNS>
GDataOutputStream     *stream, GDataStreamByteOrder   order
</FUNCTION>
<FUNCTION>
<NAME>g_data_output_stream_get_byte_order</NAME>
<RETURNS>GDataStreamByteOrder  </RETURNS>
GDataOutputStream     *stream
</FUNCTION>
<FUNCTION>
<NAME>g_data_output_stream_put_byte</NAME>
<RETURNS>gboolean              </RETURNS>
GDataOutputStream     *stream, guchar                 data, GCancellable          *cancellable, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_output_stream_put_int16</NAME>
<RETURNS>gboolean              </RETURNS>
GDataOutputStream     *stream, gint16                 data, GCancellable          *cancellable, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_output_stream_put_uint16</NAME>
<RETURNS>gboolean              </RETURNS>
GDataOutputStream     *stream, guint16                data, GCancellable          *cancellable, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_output_stream_put_int32</NAME>
<RETURNS>gboolean              </RETURNS>
GDataOutputStream     *stream, gint32                 data, GCancellable          *cancellable, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_output_stream_put_uint32</NAME>
<RETURNS>gboolean              </RETURNS>
GDataOutputStream     *stream, guint32                data, GCancellable          *cancellable, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_output_stream_put_int64</NAME>
<RETURNS>gboolean              </RETURNS>
GDataOutputStream     *stream, gint64                 data, GCancellable          *cancellable, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_output_stream_put_uint64</NAME>
<RETURNS>gboolean              </RETURNS>
GDataOutputStream     *stream, guint64                data, GCancellable          *cancellable, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_data_output_stream_put_string</NAME>
<RETURNS>gboolean              </RETURNS>
GDataOutputStream     *stream, const char            *str, GCancellable          *cancellable, GError               **error
</FUNCTION>
<STRUCT>
<NAME>GDataOutputStreamPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_DBUS_ACTION_GROUP</NAME>
#define G_TYPE_DBUS_ACTION_GROUP                            (g_dbus_action_group_get_type ())
</MACRO>
<MACRO>
<NAME>G_DBUS_ACTION_GROUP</NAME>
#define G_DBUS_ACTION_GROUP(inst)                           (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_DBUS_ACTION_GROUP, GDBusActionGroup))
</MACRO>
<MACRO>
<NAME>G_DBUS_ACTION_GROUP_CLASS</NAME>
#define G_DBUS_ACTION_GROUP_CLASS(class)                    (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_DBUS_ACTION_GROUP, GDBusActionGroupClass))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_ACTION_GROUP</NAME>
#define G_IS_DBUS_ACTION_GROUP(inst)                        (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_DBUS_ACTION_GROUP))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_ACTION_GROUP_CLASS</NAME>
#define G_IS_DBUS_ACTION_GROUP_CLASS(class)                 (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_DBUS_ACTION_GROUP))
</MACRO>
<MACRO>
<NAME>G_DBUS_ACTION_GROUP_GET_CLASS</NAME>
#define G_DBUS_ACTION_GROUP_GET_CLASS(inst)                 (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_DBUS_ACTION_GROUP, GDBusActionGroupClass))
</MACRO>
<FUNCTION>
<NAME>g_dbus_action_group_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_action_group_get</NAME>
<RETURNS>GDBusActionGroup  *      </RETURNS>
GDBusConnection        *connection, const gchar            *bus_name, const gchar            *object_path
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_address_escape_value</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *string
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_is_address</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *string
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_is_supported_address</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *string, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_address_get_stream</NAME>
<RETURNS>void                  </RETURNS>
const gchar          *address, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_address_get_stream_finish</NAME>
<RETURNS>GIOStream            *</RETURNS>
GAsyncResult         *res, gchar               **out_guid, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_address_get_stream_sync</NAME>
<RETURNS>GIOStream            *</RETURNS>
const gchar          *address, gchar               **out_guid, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_address_get_for_bus_sync</NAME>
<RETURNS>gchar                *</RETURNS>
GBusType              bus_type, GCancellable  *cancellable, GError              **error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_AUTH_OBSERVER</NAME>
#define G_TYPE_DBUS_AUTH_OBSERVER         (g_dbus_auth_observer_get_type ())
</MACRO>
<MACRO>
<NAME>G_DBUS_AUTH_OBSERVER</NAME>
#define G_DBUS_AUTH_OBSERVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_AUTH_OBSERVER, GDBusAuthObserver))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_AUTH_OBSERVER</NAME>
#define G_IS_DBUS_AUTH_OBSERVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_AUTH_OBSERVER))
</MACRO>
<FUNCTION>
<NAME>g_dbus_auth_observer_get_type</NAME>
<RETURNS>GType               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_auth_observer_new</NAME>
<RETURNS>GDBusAuthObserver  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_auth_observer_authorize_authenticated_peer</NAME>
<RETURNS>gboolean            </RETURNS>
GDBusAuthObserver  *observer, GIOStream          *stream, GCredentials       *credentials
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_auth_observer_allow_mechanism</NAME>
<RETURNS>gboolean            </RETURNS>
GDBusAuthObserver  *observer, const gchar        *mechanism
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_CONNECTION</NAME>
#define G_TYPE_DBUS_CONNECTION         (g_dbus_connection_get_type ())
</MACRO>
<MACRO>
<NAME>G_DBUS_CONNECTION</NAME>
#define G_DBUS_CONNECTION(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_CONNECTION, GDBusConnection))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_CONNECTION</NAME>
#define G_IS_DBUS_CONNECTION(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_CONNECTION))
</MACRO>
<FUNCTION>
<NAME>g_dbus_connection_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_bus_get</NAME>
<RETURNS>void               </RETURNS>
GBusType             bus_type, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_bus_get_finish</NAME>
<RETURNS>GDBusConnection   *</RETURNS>
GAsyncResult        *res, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_bus_get_sync</NAME>
<RETURNS>GDBusConnection   *</RETURNS>
GBusType            bus_type, GCancellable       *cancellable, GError            **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_new</NAME>
<RETURNS>void              </RETURNS>
GIOStream              *stream, const gchar            *guid, GDBusConnectionFlags    flags, GDBusAuthObserver      *observer, GCancellable           *cancellable, GAsyncReadyCallback     callback, gpointer                user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_new_finish</NAME>
<RETURNS>GDBusConnection  *</RETURNS>
GAsyncResult           *res, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_new_sync</NAME>
<RETURNS>GDBusConnection  *</RETURNS>
GIOStream              *stream, const gchar            *guid, GDBusConnectionFlags    flags, GDBusAuthObserver      *observer, GCancellable           *cancellable, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_new_for_address</NAME>
<RETURNS>void              </RETURNS>
const gchar            *address, GDBusConnectionFlags    flags, GDBusAuthObserver      *observer, GCancellable           *cancellable, GAsyncReadyCallback     callback, gpointer                user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_new_for_address_finish</NAME>
<RETURNS>GDBusConnection  *</RETURNS>
GAsyncResult           *res, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_new_for_address_sync</NAME>
<RETURNS>GDBusConnection  *</RETURNS>
const gchar            *address, GDBusConnectionFlags    flags, GDBusAuthObserver      *observer, GCancellable           *cancellable, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_start_message_processing</NAME>
<RETURNS>void              </RETURNS>
GDBusConnection    *connection
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_is_closed</NAME>
<RETURNS>gboolean          </RETURNS>
GDBusConnection    *connection
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_get_stream</NAME>
<RETURNS>GIOStream        *</RETURNS>
GDBusConnection    *connection
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_get_guid</NAME>
<RETURNS>const gchar      *</RETURNS>
GDBusConnection    *connection
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_get_unique_name</NAME>
<RETURNS>const gchar      *</RETURNS>
GDBusConnection    *connection
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_get_peer_credentials</NAME>
<RETURNS>GCredentials     *</RETURNS>
GDBusConnection    *connection
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_get_last_serial</NAME>
<RETURNS>guint32           </RETURNS>
GDBusConnection    *connection
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_get_exit_on_close</NAME>
<RETURNS>gboolean          </RETURNS>
GDBusConnection    *connection
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_set_exit_on_close</NAME>
<RETURNS>void              </RETURNS>
GDBusConnection    *connection, gboolean            exit_on_close
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_get_capabilities</NAME>
<RETURNS>GDBusCapabilityFlags   </RETURNS>
GDBusConnection    *connection
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_close</NAME>
<RETURNS>void              </RETURNS>
GDBusConnection     *connection, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_close_finish</NAME>
<RETURNS>gboolean          </RETURNS>
GDBusConnection     *connection, GAsyncResult        *res, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_close_sync</NAME>
<RETURNS>gboolean          </RETURNS>
GDBusConnection     *connection, GCancellable        *cancellable, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_flush</NAME>
<RETURNS>void              </RETURNS>
GDBusConnection     *connection, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_flush_finish</NAME>
<RETURNS>gboolean          </RETURNS>
GDBusConnection     *connection, GAsyncResult        *res, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_flush_sync</NAME>
<RETURNS>gboolean          </RETURNS>
GDBusConnection     *connection, GCancellable        *cancellable, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_send_message</NAME>
<RETURNS>gboolean          </RETURNS>
GDBusConnection     *connection, GDBusMessage        *message, GDBusSendMessageFlags flags, volatile guint32    *out_serial, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_send_message_with_reply</NAME>
<RETURNS>void              </RETURNS>
GDBusConnection     *connection, GDBusMessage        *message, GDBusSendMessageFlags flags, gint                 timeout_msec, volatile guint32    *out_serial, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_send_message_with_reply_finish</NAME>
<RETURNS>GDBusMessage     *</RETURNS>
GDBusConnection     *connection, GAsyncResult        *res, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_send_message_with_reply_sync</NAME>
<RETURNS>GDBusMessage     *</RETURNS>
GDBusConnection     *connection, GDBusMessage        *message, GDBusSendMessageFlags flags, gint                 timeout_msec, volatile guint32    *out_serial, GCancellable        *cancellable, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_emit_signal</NAME>
<RETURNS>gboolean   </RETURNS>
GDBusConnection    *connection, const gchar        *destination_bus_name, const gchar        *object_path, const gchar        *interface_name, const gchar        *signal_name, GVariant           *parameters, GError            **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_call</NAME>
<RETURNS>void       </RETURNS>
GDBusConnection    *connection, const gchar        *bus_name, const gchar        *object_path, const gchar        *interface_name, const gchar        *method_name, GVariant           *parameters, const GVariantType *reply_type, GDBusCallFlags      flags, gint                timeout_msec, GCancellable       *cancellable, GAsyncReadyCallback callback, gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_call_finish</NAME>
<RETURNS>GVariant  *</RETURNS>
GDBusConnection    *connection, GAsyncResult       *res, GError            **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_call_sync</NAME>
<RETURNS>GVariant  *</RETURNS>
GDBusConnection    *connection, const gchar        *bus_name, const gchar        *object_path, const gchar        *interface_name, const gchar        *method_name, GVariant           *parameters, const GVariantType *reply_type, GDBusCallFlags      flags, gint                timeout_msec, GCancellable       *cancellable, GError            **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_call_with_unix_fd_list</NAME>
<RETURNS>void       </RETURNS>
GDBusConnection    *connection, const gchar        *bus_name, const gchar        *object_path, const gchar        *interface_name, const gchar        *method_name, GVariant           *parameters, const GVariantType *reply_type, GDBusCallFlags      flags, gint                timeout_msec, GUnixFDList        *fd_list, GCancellable       *cancellable, GAsyncReadyCallback callback, gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_call_with_unix_fd_list_finish</NAME>
<RETURNS>GVariant  *</RETURNS>
GDBusConnection    *connection, GUnixFDList       **out_fd_list, GAsyncResult       *res, GError            **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_call_with_unix_fd_list_sync</NAME>
<RETURNS>GVariant  *</RETURNS>
GDBusConnection    *connection, const gchar        *bus_name, const gchar        *object_path, const gchar        *interface_name, const gchar        *method_name, GVariant           *parameters, const GVariantType *reply_type, GDBusCallFlags      flags, gint                timeout_msec, GUnixFDList        *fd_list, GUnixFDList       **out_fd_list, GCancellable       *cancellable, GError            **error
</FUNCTION>
<USER_FUNCTION>
<NAME>GDBusInterfaceMethodCallFunc</NAME>
<RETURNS>void </RETURNS>
GDBusConnection       *connection,
                                              const gchar           *sender,
                                              const gchar           *object_path,
                                              const gchar           *interface_name,
                                              const gchar           *method_name,
                                              GVariant              *parameters,
                                              GDBusMethodInvocation *invocation,
                                              gpointer               user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GDBusInterfaceGetPropertyFunc</NAME>
<RETURNS>GVariant *</RETURNS>
GDBusConnection       *connection,
                                                    const gchar           *sender,
                                                    const gchar           *object_path,
                                                    const gchar           *interface_name,
                                                    const gchar           *property_name,
                                                    GError               **error,
                                                    gpointer               user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GDBusInterfaceSetPropertyFunc</NAME>
<RETURNS>gboolean </RETURNS>
GDBusConnection       *connection,
                                                    const gchar           *sender,
                                                    const gchar           *object_path,
                                                    const gchar           *interface_name,
                                                    const gchar           *property_name,
                                                    GVariant              *value,
                                                    GError               **error,
                                                    gpointer               user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GDBusInterfaceVTable</NAME>
struct _GDBusInterfaceVTable
{
  GDBusInterfaceMethodCallFunc  method_call;
  GDBusInterfaceGetPropertyFunc get_property;
  GDBusInterfaceSetPropertyFunc set_property;

  /*< private >*/
  /* Padding for future expansion - also remember to update
   * gdbusconnection.c:_g_dbus_interface_vtable_copy() when
   * changing this.
   */
  gpointer padding[8];
};
</STRUCT>
<FUNCTION>
<NAME>g_dbus_connection_register_object</NAME>
<RETURNS>guint             </RETURNS>
GDBusConnection            *connection, const gchar                *object_path, GDBusInterfaceInfo         *interface_info, const GDBusInterfaceVTable *vtable, gpointer                    user_data, GDestroyNotify              user_data_free_func, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_register_object_with_closures</NAME>
<RETURNS>guint             </RETURNS>
GDBusConnection         *connection, const gchar             *object_path, GDBusInterfaceInfo      *interface_info, GClosure                *method_call_closure, GClosure                *get_property_closure, GClosure                *set_property_closure, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_unregister_object</NAME>
<RETURNS>gboolean          </RETURNS>
GDBusConnection            *connection, guint                       registration_id
</FUNCTION>
<USER_FUNCTION>
<NAME>GDBusSubtreeEnumerateFunc</NAME>
<RETURNS>gchar **</RETURNS>
GDBusConnection       *connection,
                                              const gchar           *sender,
                                              const gchar           *object_path,
                                              gpointer               user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GDBusSubtreeIntrospectFunc</NAME>
<RETURNS>GDBusInterfaceInfo **</RETURNS>
GDBusConnection       *connection,
                                                             const gchar           *sender,
                                                             const gchar           *object_path,
                                                             const gchar           *node,
                                                             gpointer               user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GDBusSubtreeDispatchFunc</NAME>
<RETURNS>const GDBusInterfaceVTable *</RETURNS>
GDBusConnection             *connection,
                                                                  const gchar                 *sender,
                                                                  const gchar                 *object_path,
                                                                  const gchar                 *interface_name,
                                                                  const gchar                 *node,
                                                                  gpointer                    *out_user_data,
                                                                  gpointer                     user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GDBusSubtreeVTable</NAME>
struct _GDBusSubtreeVTable
{
  GDBusSubtreeEnumerateFunc  enumerate;
  GDBusSubtreeIntrospectFunc introspect;
  GDBusSubtreeDispatchFunc   dispatch;

  /*< private >*/
  /* Padding for future expansion - also remember to update
   * gdbusconnection.c:_g_dbus_subtree_vtable_copy() when
   * changing this.
   */
  gpointer padding[8];
};
</STRUCT>
<FUNCTION>
<NAME>g_dbus_connection_register_subtree</NAME>
<RETURNS>guint             </RETURNS>
GDBusConnection            *connection, const gchar                *object_path, const GDBusSubtreeVTable   *vtable, GDBusSubtreeFlags           flags, gpointer                    user_data, GDestroyNotify              user_data_free_func, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_unregister_subtree</NAME>
<RETURNS>gboolean          </RETURNS>
GDBusConnection            *connection, guint                       registration_id
</FUNCTION>
<USER_FUNCTION>
<NAME>GDBusSignalCallback</NAME>
<RETURNS>void </RETURNS>
GDBusConnection  *connection,
                                     const gchar      *sender_name,
                                     const gchar      *object_path,
                                     const gchar      *interface_name,
                                     const gchar      *signal_name,
                                     GVariant         *parameters,
                                     gpointer          user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_signal_subscribe</NAME>
<RETURNS>guint             </RETURNS>
GDBusConnection     *connection, const gchar         *sender, const gchar         *interface_name, const gchar         *member, const gchar         *object_path, const gchar         *arg0, GDBusSignalFlags     flags, GDBusSignalCallback  callback, gpointer             user_data, GDestroyNotify       user_data_free_func
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_signal_unsubscribe</NAME>
<RETURNS>void              </RETURNS>
GDBusConnection     *connection, guint                subscription_id
</FUNCTION>
<USER_FUNCTION>
<NAME>GDBusMessageFilterFunction</NAME>
<RETURNS>GDBusMessage *</RETURNS>
GDBusConnection *connection,
                                                     GDBusMessage    *message,
                                                     gboolean         incoming,
                                                     gpointer         user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_add_filter</NAME>
<RETURNS>guint  </RETURNS>
GDBusConnection            *connection, GDBusMessageFilterFunction  filter_function, gpointer                    user_data, GDestroyNotify              user_data_free_func
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_remove_filter</NAME>
<RETURNS>void   </RETURNS>
GDBusConnection    *connection, guint               filter_id
</FUNCTION>
<MACRO>
<NAME>G_DBUS_ERROR</NAME>
#define G_DBUS_ERROR g_dbus_error_quark()
</MACRO>
<FUNCTION>
<NAME>g_dbus_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_error_is_remote_error</NAME>
<RETURNS>gboolean  </RETURNS>
const GError    *error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_error_get_remote_error</NAME>
<RETURNS>gchar    *</RETURNS>
const GError    *error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_error_strip_remote_error</NAME>
<RETURNS>gboolean  </RETURNS>
GError          *error
</FUNCTION>
<STRUCT>
<NAME>GDBusErrorEntry</NAME>
struct _GDBusErrorEntry
{
  gint         error_code;
  const gchar *dbus_error_name;
};
</STRUCT>
<FUNCTION>
<NAME>g_dbus_error_register_error</NAME>
<RETURNS>gboolean  </RETURNS>
GQuark                 error_domain, gint                   error_code, const gchar           *dbus_error_name
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_error_unregister_error</NAME>
<RETURNS>gboolean  </RETURNS>
GQuark                 error_domain, gint                   error_code, const gchar           *dbus_error_name
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_error_register_error_domain</NAME>
<RETURNS>void      </RETURNS>
const gchar           *error_domain_quark_name, volatile gsize        *quark_volatile, const GDBusErrorEntry *entries, guint                  num_entries
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_error_new_for_dbus_error</NAME>
<RETURNS>GError   *</RETURNS>
const gchar     *dbus_error_name, const gchar     *dbus_error_message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_error_set_dbus_error</NAME>
<RETURNS>void      </RETURNS>
GError         **error, const gchar     *dbus_error_name, const gchar     *dbus_error_message, const gchar     *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_error_set_dbus_error_valist</NAME>
<RETURNS>void      </RETURNS>
GError         **error, const gchar     *dbus_error_name, const gchar     *dbus_error_message, const gchar     *format, va_list          var_args
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_error_encode_gerror</NAME>
<RETURNS>gchar    *</RETURNS>
const GError    *error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_INTERFACE</NAME>
#define G_TYPE_DBUS_INTERFACE         (g_dbus_interface_get_type())
</MACRO>
<MACRO>
<NAME>G_DBUS_INTERFACE</NAME>
#define G_DBUS_INTERFACE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_INTERFACE, GDBusInterface))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_INTERFACE</NAME>
#define G_IS_DBUS_INTERFACE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_INTERFACE))
</MACRO>
<MACRO>
<NAME>G_DBUS_INTERFACE_GET_IFACE</NAME>
#define G_DBUS_INTERFACE_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE((o), G_TYPE_DBUS_INTERFACE, GDBusInterfaceIface))
</MACRO>
<STRUCT>
<NAME>GDBusInterfaceIface</NAME>
struct _GDBusInterfaceIface
{
  GTypeInterface parent_iface;

  /* Virtual Functions */
  GDBusInterfaceInfo   *(*get_info)   (GDBusInterface      *interface_);
  GDBusObject          *(*get_object) (GDBusInterface      *interface_);
  void                  (*set_object) (GDBusInterface      *interface_,
                                       GDBusObject         *object);
  GDBusObject          *(*dup_object) (GDBusInterface      *interface_);
};
</STRUCT>
<FUNCTION>
<NAME>g_dbus_interface_get_type</NAME>
<RETURNS>GType                  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_get_info</NAME>
<RETURNS>GDBusInterfaceInfo    *</RETURNS>
GDBusInterface      *interface_
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_get_object</NAME>
<RETURNS>GDBusObject           *</RETURNS>
GDBusInterface      *interface_
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_set_object</NAME>
<RETURNS>void                   </RETURNS>
GDBusInterface      *interface_, GDBusObject         *object
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_dup_object</NAME>
<RETURNS>GDBusObject           *</RETURNS>
GDBusInterface      *interface_
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_INTERFACE_SKELETON</NAME>
#define G_TYPE_DBUS_INTERFACE_SKELETON         (g_dbus_interface_skeleton_get_type ())
</MACRO>
<MACRO>
<NAME>G_DBUS_INTERFACE_SKELETON</NAME>
#define G_DBUS_INTERFACE_SKELETON(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_INTERFACE_SKELETON, GDBusInterfaceSkeleton))
</MACRO>
<MACRO>
<NAME>G_DBUS_INTERFACE_SKELETON_CLASS</NAME>
#define G_DBUS_INTERFACE_SKELETON_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_INTERFACE_SKELETON, GDBusInterfaceSkeletonClass))
</MACRO>
<MACRO>
<NAME>G_DBUS_INTERFACE_SKELETON_GET_CLASS</NAME>
#define G_DBUS_INTERFACE_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_INTERFACE_SKELETON, GDBusInterfaceSkeletonClass))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_INTERFACE_SKELETON</NAME>
#define G_IS_DBUS_INTERFACE_SKELETON(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_INTERFACE_SKELETON))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_INTERFACE_SKELETON_CLASS</NAME>
#define G_IS_DBUS_INTERFACE_SKELETON_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_INTERFACE_SKELETON))
</MACRO>
<STRUCT>
<NAME>GDBusInterfaceSkeleton</NAME>
struct _GDBusInterfaceSkeleton
{
  /*< private >*/
  GObject parent_instance;
  GDBusInterfaceSkeletonPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GDBusInterfaceSkeletonClass</NAME>
struct _GDBusInterfaceSkeletonClass
{
  GObjectClass parent_class;

  /* Virtual Functions */
  GDBusInterfaceInfo   *(*get_info)       (GDBusInterfaceSkeleton  *interface_);
  GDBusInterfaceVTable *(*get_vtable)     (GDBusInterfaceSkeleton  *interface_);
  GVariant             *(*get_properties) (GDBusInterfaceSkeleton  *interface_);
  void                  (*flush)          (GDBusInterfaceSkeleton  *interface_);

  /*< private >*/
  gpointer vfunc_padding[8];
  /*< public >*/

  /* Signals */
  gboolean (*g_authorize_method) (GDBusInterfaceSkeleton  *interface_,
                                  GDBusMethodInvocation   *invocation);

  /*< private >*/
  gpointer signal_padding[8];
};
</STRUCT>
<FUNCTION>
<NAME>g_dbus_interface_skeleton_get_type</NAME>
<RETURNS>GType                         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_skeleton_get_flags</NAME>
<RETURNS>GDBusInterfaceSkeletonFlags   </RETURNS>
GDBusInterfaceSkeleton      *interface_
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_skeleton_set_flags</NAME>
<RETURNS>void                          </RETURNS>
GDBusInterfaceSkeleton      *interface_, GDBusInterfaceSkeletonFlags  flags
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_skeleton_get_info</NAME>
<RETURNS>GDBusInterfaceInfo           *</RETURNS>
GDBusInterfaceSkeleton      *interface_
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_skeleton_get_vtable</NAME>
<RETURNS>GDBusInterfaceVTable         *</RETURNS>
GDBusInterfaceSkeleton      *interface_
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_skeleton_get_properties</NAME>
<RETURNS>GVariant                     *</RETURNS>
GDBusInterfaceSkeleton      *interface_
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_skeleton_flush</NAME>
<RETURNS>void                          </RETURNS>
GDBusInterfaceSkeleton      *interface_
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_skeleton_export</NAME>
<RETURNS>gboolean                      </RETURNS>
GDBusInterfaceSkeleton      *interface_, GDBusConnection             *connection, const gchar                 *object_path, GError                     **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_skeleton_unexport</NAME>
<RETURNS>void                          </RETURNS>
GDBusInterfaceSkeleton      *interface_
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_skeleton_unexport_from_connection</NAME>
<RETURNS>void                 </RETURNS>
GDBusInterfaceSkeleton      *interface_, GDBusConnection             *connection
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_skeleton_get_connection</NAME>
<RETURNS>GDBusConnection              *</RETURNS>
GDBusInterfaceSkeleton      *interface_
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_skeleton_get_connections</NAME>
<RETURNS>GList                        *</RETURNS>
GDBusInterfaceSkeleton      *interface_
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_skeleton_has_connection</NAME>
<RETURNS>gboolean                      </RETURNS>
GDBusInterfaceSkeleton      *interface_, GDBusConnection             *connection
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_skeleton_get_object_path</NAME>
<RETURNS>const gchar                  *</RETURNS>
GDBusInterfaceSkeleton      *interface_
</FUNCTION>
<STRUCT>
<NAME>GDBusInterfaceSkeletonPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusAnnotationInfo</NAME>
struct _GDBusAnnotationInfo
{
  /*< public >*/
  volatile gint         ref_count;
  gchar                *key;
  gchar                *value;
  GDBusAnnotationInfo **annotations;
};
</STRUCT>
<STRUCT>
<NAME>GDBusArgInfo</NAME>
struct _GDBusArgInfo
{
  /*< public >*/
  volatile gint         ref_count;
  gchar                *name;
  gchar                *signature;
  GDBusAnnotationInfo **annotations;
};
</STRUCT>
<STRUCT>
<NAME>GDBusMethodInfo</NAME>
struct _GDBusMethodInfo
{
  /*< public >*/
  volatile gint         ref_count;
  gchar                *name;
  GDBusArgInfo        **in_args;
  GDBusArgInfo        **out_args;
  GDBusAnnotationInfo **annotations;
};
</STRUCT>
<STRUCT>
<NAME>GDBusSignalInfo</NAME>
struct _GDBusSignalInfo
{
  /*< public >*/
  volatile gint         ref_count;
  gchar                *name;
  GDBusArgInfo        **args;
  GDBusAnnotationInfo **annotations;
};
</STRUCT>
<STRUCT>
<NAME>GDBusPropertyInfo</NAME>
struct _GDBusPropertyInfo
{
  /*< public >*/
  volatile gint             ref_count;
  gchar                    *name;
  gchar                    *signature;
  GDBusPropertyInfoFlags    flags;
  GDBusAnnotationInfo     **annotations;
};
</STRUCT>
<STRUCT>
<NAME>GDBusInterfaceInfo</NAME>
struct _GDBusInterfaceInfo
{
  /*< public >*/
  volatile gint         ref_count;
  gchar                *name;
  GDBusMethodInfo     **methods;
  GDBusSignalInfo     **signals;
  GDBusPropertyInfo   **properties;
  GDBusAnnotationInfo **annotations;
};
</STRUCT>
<STRUCT>
<NAME>GDBusNodeInfo</NAME>
struct _GDBusNodeInfo
{
  /*< public >*/
  volatile gint         ref_count;
  gchar                *path;
  GDBusInterfaceInfo  **interfaces;
  GDBusNodeInfo       **nodes;
  GDBusAnnotationInfo **annotations;
};
</STRUCT>
<FUNCTION>
<NAME>g_dbus_annotation_info_lookup</NAME>
<RETURNS>const gchar         *</RETURNS>
GDBusAnnotationInfo **annotations, const gchar          *name
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_info_lookup_method</NAME>
<RETURNS>GDBusMethodInfo     *</RETURNS>
GDBusInterfaceInfo   *info, const gchar          *name
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_info_lookup_signal</NAME>
<RETURNS>GDBusSignalInfo     *</RETURNS>
GDBusInterfaceInfo   *info, const gchar          *name
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_info_lookup_property</NAME>
<RETURNS>GDBusPropertyInfo   *</RETURNS>
GDBusInterfaceInfo   *info, const gchar          *name
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_info_cache_build</NAME>
<RETURNS>void                 </RETURNS>
GDBusInterfaceInfo   *info
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_info_cache_release</NAME>
<RETURNS>void                 </RETURNS>
GDBusInterfaceInfo   *info
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_info_generate_xml</NAME>
<RETURNS>void                 </RETURNS>
GDBusInterfaceInfo   *info, guint                 indent, GString              *string_builder
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_node_info_new_for_xml</NAME>
<RETURNS>GDBusNodeInfo       *</RETURNS>
const gchar          *xml_data, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_node_info_lookup_interface</NAME>
<RETURNS>GDBusInterfaceInfo  *</RETURNS>
GDBusNodeInfo        *info, const gchar          *name
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_node_info_generate_xml</NAME>
<RETURNS>void                 </RETURNS>
GDBusNodeInfo        *info, guint                 indent, GString              *string_builder
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_node_info_ref</NAME>
<RETURNS>GDBusNodeInfo        *</RETURNS>
GDBusNodeInfo        *info
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_info_ref</NAME>
<RETURNS>GDBusInterfaceInfo   *</RETURNS>
GDBusInterfaceInfo   *info
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_info_ref</NAME>
<RETURNS>GDBusMethodInfo      *</RETURNS>
GDBusMethodInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_signal_info_ref</NAME>
<RETURNS>GDBusSignalInfo      *</RETURNS>
GDBusSignalInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_property_info_ref</NAME>
<RETURNS>GDBusPropertyInfo    *</RETURNS>
GDBusPropertyInfo    *info
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_arg_info_ref</NAME>
<RETURNS>GDBusArgInfo         *</RETURNS>
GDBusArgInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_annotation_info_ref</NAME>
<RETURNS>GDBusAnnotationInfo  *</RETURNS>
GDBusAnnotationInfo  *info
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_node_info_unref</NAME>
<RETURNS>void                  </RETURNS>
GDBusNodeInfo        *info
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_info_unref</NAME>
<RETURNS>void                  </RETURNS>
GDBusInterfaceInfo   *info
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_info_unref</NAME>
<RETURNS>void                  </RETURNS>
GDBusMethodInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_signal_info_unref</NAME>
<RETURNS>void                  </RETURNS>
GDBusSignalInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_property_info_unref</NAME>
<RETURNS>void                  </RETURNS>
GDBusPropertyInfo    *info
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_arg_info_unref</NAME>
<RETURNS>void                  </RETURNS>
GDBusArgInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_annotation_info_unref</NAME>
<RETURNS>void                  </RETURNS>
GDBusAnnotationInfo  *info
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_NODE_INFO</NAME>
#define G_TYPE_DBUS_NODE_INFO       (g_dbus_node_info_get_type ())
</MACRO>
<MACRO>
<NAME>G_TYPE_DBUS_INTERFACE_INFO</NAME>
#define G_TYPE_DBUS_INTERFACE_INFO  (g_dbus_interface_info_get_type ())
</MACRO>
<MACRO>
<NAME>G_TYPE_DBUS_METHOD_INFO</NAME>
#define G_TYPE_DBUS_METHOD_INFO     (g_dbus_method_info_get_type ())
</MACRO>
<MACRO>
<NAME>G_TYPE_DBUS_SIGNAL_INFO</NAME>
#define G_TYPE_DBUS_SIGNAL_INFO     (g_dbus_signal_info_get_type ())
</MACRO>
<MACRO>
<NAME>G_TYPE_DBUS_PROPERTY_INFO</NAME>
#define G_TYPE_DBUS_PROPERTY_INFO   (g_dbus_property_info_get_type ())
</MACRO>
<MACRO>
<NAME>G_TYPE_DBUS_ARG_INFO</NAME>
#define G_TYPE_DBUS_ARG_INFO        (g_dbus_arg_info_get_type ())
</MACRO>
<MACRO>
<NAME>G_TYPE_DBUS_ANNOTATION_INFO</NAME>
#define G_TYPE_DBUS_ANNOTATION_INFO (g_dbus_annotation_info_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_node_info_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_interface_info_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_info_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_signal_info_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_property_info_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_arg_info_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_annotation_info_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_MENU_MODEL</NAME>
#define G_TYPE_DBUS_MENU_MODEL          (g_dbus_menu_model_get_type ())
</MACRO>
<MACRO>
<NAME>G_DBUS_MENU_MODEL</NAME>
#define G_DBUS_MENU_MODEL(inst)         (G_TYPE_CHECK_INSTANCE_CAST ((inst),   \
                                         G_TYPE_DBUS_MENU_MODEL, GDBusMenuModel))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_MENU_MODEL</NAME>
#define G_IS_DBUS_MENU_MODEL(inst)      (G_TYPE_CHECK_INSTANCE_TYPE ((inst),   \
                                         G_TYPE_DBUS_MENU_MODEL))
</MACRO>
<FUNCTION>
<NAME>g_dbus_menu_model_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_menu_model_get</NAME>
<RETURNS>GDBusMenuModel  *        </RETURNS>
GDBusConnection *connection, const gchar     *bus_name, const gchar     *object_path
</FUNCTION>
<STRUCT>
<NAME>GDBusMenuModel</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_DBUS_MESSAGE</NAME>
#define G_TYPE_DBUS_MESSAGE         (g_dbus_message_get_type ())
</MACRO>
<MACRO>
<NAME>G_DBUS_MESSAGE</NAME>
#define G_DBUS_MESSAGE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_MESSAGE, GDBusMessage))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_MESSAGE</NAME>
#define G_IS_DBUS_MESSAGE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_MESSAGE))
</MACRO>
<FUNCTION>
<NAME>g_dbus_message_get_type</NAME>
<RETURNS>GType                      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_new</NAME>
<RETURNS>GDBusMessage              *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_new_signal</NAME>
<RETURNS>GDBusMessage              *</RETURNS>
const gchar              *path, const gchar              *interface_, const gchar              *signal
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_new_method_call</NAME>
<RETURNS>GDBusMessage              *</RETURNS>
const gchar              *name, const gchar              *path, const gchar              *interface_, const gchar              *method
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_new_method_reply</NAME>
<RETURNS>GDBusMessage              *</RETURNS>
GDBusMessage             *method_call_message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_new_method_error</NAME>
<RETURNS>GDBusMessage              *</RETURNS>
GDBusMessage             *method_call_message, const gchar              *error_name, const gchar              *error_message_format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_new_method_error_valist</NAME>
<RETURNS>GDBusMessage              *</RETURNS>
GDBusMessage             *method_call_message, const gchar              *error_name, const gchar              *error_message_format, va_list                   var_args
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_new_method_error_literal</NAME>
<RETURNS>GDBusMessage              *</RETURNS>
GDBusMessage             *method_call_message, const gchar              *error_name, const gchar              *error_message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_print</NAME>
<RETURNS>gchar                     *</RETURNS>
GDBusMessage             *message, guint                     indent
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_locked</NAME>
<RETURNS>gboolean                   </RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_lock</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_copy</NAME>
<RETURNS>GDBusMessage              *</RETURNS>
GDBusMessage             *message, GError                  **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_byte_order</NAME>
<RETURNS>GDBusMessageByteOrder      </RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_set_byte_order</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message, GDBusMessageByteOrder     byte_order
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_message_type</NAME>
<RETURNS>GDBusMessageType           </RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_set_message_type</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message, GDBusMessageType          type
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_flags</NAME>
<RETURNS>GDBusMessageFlags          </RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_set_flags</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message, GDBusMessageFlags         flags
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_serial</NAME>
<RETURNS>guint32                    </RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_set_serial</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message, guint32                   serial
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_header</NAME>
<RETURNS>GVariant                  *</RETURNS>
GDBusMessage             *message, GDBusMessageHeaderField   header_field
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_set_header</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message, GDBusMessageHeaderField   header_field, GVariant                 *value
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_header_fields</NAME>
<RETURNS>guchar                    *</RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_body</NAME>
<RETURNS>GVariant                  *</RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_set_body</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message, GVariant                 *body
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_unix_fd_list</NAME>
<RETURNS>GUnixFDList               *</RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_set_unix_fd_list</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message, GUnixFDList              *fd_list
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_reply_serial</NAME>
<RETURNS>guint32                    </RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_set_reply_serial</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message, guint32                   value
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_interface</NAME>
<RETURNS>const gchar               *</RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_set_interface</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message, const gchar              *value
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_member</NAME>
<RETURNS>const gchar               *</RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_set_member</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message, const gchar              *value
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_path</NAME>
<RETURNS>const gchar               *</RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_set_path</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message, const gchar              *value
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_sender</NAME>
<RETURNS>const gchar               *</RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_set_sender</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message, const gchar              *value
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_destination</NAME>
<RETURNS>const gchar               *</RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_set_destination</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message, const gchar              *value
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_error_name</NAME>
<RETURNS>const gchar               *</RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_set_error_name</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message, const gchar              *value
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_signature</NAME>
<RETURNS>const gchar               *</RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_set_signature</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message, const gchar              *value
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_num_unix_fds</NAME>
<RETURNS>guint32                    </RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_set_num_unix_fds</NAME>
<RETURNS>void                       </RETURNS>
GDBusMessage             *message, guint32                   value
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_get_arg0</NAME>
<RETURNS>const gchar               *</RETURNS>
GDBusMessage             *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_new_from_blob</NAME>
<RETURNS>GDBusMessage              *</RETURNS>
guchar                   *blob, gsize                     blob_len, GDBusCapabilityFlags      capabilities, GError                  **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_bytes_needed</NAME>
<RETURNS>gssize                     </RETURNS>
guchar                   *blob, gsize                     blob_len, GError                  **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_to_blob</NAME>
<RETURNS>guchar                    *</RETURNS>
GDBusMessage             *message, gsize                    *out_size, GDBusCapabilityFlags      capabilities, GError                  **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_message_to_gerror</NAME>
<RETURNS>gboolean                   </RETURNS>
GDBusMessage             *message, GError                  **error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_METHOD_INVOCATION</NAME>
#define G_TYPE_DBUS_METHOD_INVOCATION         (g_dbus_method_invocation_get_type ())
</MACRO>
<MACRO>
<NAME>G_DBUS_METHOD_INVOCATION</NAME>
#define G_DBUS_METHOD_INVOCATION(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_METHOD_INVOCATION, GDBusMethodInvocation))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_METHOD_INVOCATION</NAME>
#define G_IS_DBUS_METHOD_INVOCATION(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_METHOD_INVOCATION))
</MACRO>
<FUNCTION>
<NAME>g_dbus_method_invocation_get_type</NAME>
<RETURNS>GType                   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_get_sender</NAME>
<RETURNS>const gchar            *</RETURNS>
GDBusMethodInvocation *invocation
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_get_object_path</NAME>
<RETURNS>const gchar            *</RETURNS>
GDBusMethodInvocation *invocation
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_get_interface_name</NAME>
<RETURNS>const gchar            *</RETURNS>
GDBusMethodInvocation *invocation
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_get_method_name</NAME>
<RETURNS>const gchar            *</RETURNS>
GDBusMethodInvocation *invocation
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_get_method_info</NAME>
<RETURNS>const GDBusMethodInfo  *</RETURNS>
GDBusMethodInvocation *invocation
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_get_property_info</NAME>
<RETURNS>const GDBusPropertyInfo  *</RETURNS>
GDBusMethodInvocation *invocation
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_get_connection</NAME>
<RETURNS>GDBusConnection        *</RETURNS>
GDBusMethodInvocation *invocation
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_get_message</NAME>
<RETURNS>GDBusMessage           *</RETURNS>
GDBusMethodInvocation *invocation
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_get_parameters</NAME>
<RETURNS>GVariant               *</RETURNS>
GDBusMethodInvocation *invocation
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_get_user_data</NAME>
<RETURNS>gpointer                </RETURNS>
GDBusMethodInvocation *invocation
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_return_value</NAME>
<RETURNS>void                    </RETURNS>
GDBusMethodInvocation *invocation, GVariant              *parameters
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_return_value_with_unix_fd_list</NAME>
<RETURNS>void                    </RETURNS>
GDBusMethodInvocation *invocation, GVariant              *parameters, GUnixFDList           *fd_list
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_return_error</NAME>
<RETURNS>void                    </RETURNS>
GDBusMethodInvocation *invocation, GQuark                 domain, gint                   code, const gchar           *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_return_error_valist</NAME>
<RETURNS>void                    </RETURNS>
GDBusMethodInvocation *invocation, GQuark                 domain, gint                   code, const gchar           *format, va_list                var_args
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_return_error_literal</NAME>
<RETURNS>void                    </RETURNS>
GDBusMethodInvocation *invocation, GQuark                 domain, gint                   code, const gchar           *message
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_return_gerror</NAME>
<RETURNS>void                    </RETURNS>
GDBusMethodInvocation *invocation, const GError          *error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_take_error</NAME>
<RETURNS>void                    </RETURNS>
GDBusMethodInvocation *invocation, GError                *error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_method_invocation_return_dbus_error</NAME>
<RETURNS>void                    </RETURNS>
GDBusMethodInvocation *invocation, const gchar           *error_name, const gchar           *error_message
</FUNCTION>
<USER_FUNCTION>
<NAME>GBusAcquiredCallback</NAME>
<RETURNS>void </RETURNS>
GDBusConnection *connection,
                                      const gchar     *name,
                                      gpointer         user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GBusNameAcquiredCallback</NAME>
<RETURNS>void </RETURNS>
GDBusConnection *connection,
                                          const gchar     *name,
                                          gpointer         user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GBusNameLostCallback</NAME>
<RETURNS>void </RETURNS>
GDBusConnection *connection,
                                      const gchar     *name,
                                      gpointer         user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>g_bus_own_name</NAME>
<RETURNS>guint  </RETURNS>
GBusType                  bus_type, const gchar              *name, GBusNameOwnerFlags        flags, GBusAcquiredCallback      bus_acquired_handler, GBusNameAcquiredCallback  name_acquired_handler, GBusNameLostCallback      name_lost_handler, gpointer                  user_data, GDestroyNotify            user_data_free_func
</FUNCTION>
<FUNCTION>
<NAME>g_bus_own_name_on_connection</NAME>
<RETURNS>guint  </RETURNS>
GDBusConnection          *connection, const gchar              *name, GBusNameOwnerFlags        flags, GBusNameAcquiredCallback  name_acquired_handler, GBusNameLostCallback      name_lost_handler, gpointer                  user_data, GDestroyNotify            user_data_free_func
</FUNCTION>
<FUNCTION>
<NAME>g_bus_own_name_with_closures</NAME>
<RETURNS>guint  </RETURNS>
GBusType                  bus_type, const gchar              *name, GBusNameOwnerFlags        flags, GClosure                 *bus_acquired_closure, GClosure                 *name_acquired_closure, GClosure                 *name_lost_closure
</FUNCTION>
<FUNCTION>
<NAME>g_bus_own_name_on_connection_with_closures</NAME>
<RETURNS>guint  </RETURNS>
GDBusConnection          *connection, const gchar              *name, GBusNameOwnerFlags        flags, GClosure                 *name_acquired_closure, GClosure                 *name_lost_closure
</FUNCTION>
<FUNCTION>
<NAME>g_bus_unown_name</NAME>
<RETURNS>void   </RETURNS>
guint                     owner_id
</FUNCTION>
<USER_FUNCTION>
<NAME>GBusNameAppearedCallback</NAME>
<RETURNS>void </RETURNS>
GDBusConnection *connection,
                                          const gchar     *name,
                                          const gchar     *name_owner,
                                          gpointer         user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GBusNameVanishedCallback</NAME>
<RETURNS>void </RETURNS>
GDBusConnection *connection,
                                          const gchar     *name,
                                          gpointer         user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>g_bus_watch_name</NAME>
<RETURNS>guint  </RETURNS>
GBusType                  bus_type, const gchar              *name, GBusNameWatcherFlags      flags, GBusNameAppearedCallback  name_appeared_handler, GBusNameVanishedCallback  name_vanished_handler, gpointer                  user_data, GDestroyNotify            user_data_free_func
</FUNCTION>
<FUNCTION>
<NAME>g_bus_watch_name_on_connection</NAME>
<RETURNS>guint  </RETURNS>
GDBusConnection          *connection, const gchar              *name, GBusNameWatcherFlags      flags, GBusNameAppearedCallback  name_appeared_handler, GBusNameVanishedCallback  name_vanished_handler, gpointer                  user_data, GDestroyNotify            user_data_free_func
</FUNCTION>
<FUNCTION>
<NAME>g_bus_watch_name_with_closures</NAME>
<RETURNS>guint  </RETURNS>
GBusType                  bus_type, const gchar              *name, GBusNameWatcherFlags      flags, GClosure                 *name_appeared_closure, GClosure                 *name_vanished_closure
</FUNCTION>
<FUNCTION>
<NAME>g_bus_watch_name_on_connection_with_closures</NAME>
<RETURNS>guint  </RETURNS>
GDBusConnection          *connection, const gchar              *name, GBusNameWatcherFlags      flags, GClosure                 *name_appeared_closure, GClosure                 *name_vanished_closure
</FUNCTION>
<FUNCTION>
<NAME>g_bus_unwatch_name</NAME>
<RETURNS>void   </RETURNS>
guint                     watcher_id
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_OBJECT</NAME>
#define G_TYPE_DBUS_OBJECT         (g_dbus_object_get_type())
</MACRO>
<MACRO>
<NAME>G_DBUS_OBJECT</NAME>
#define G_DBUS_OBJECT(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT, GDBusObject))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_OBJECT</NAME>
#define G_IS_DBUS_OBJECT(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT))
</MACRO>
<MACRO>
<NAME>G_DBUS_OBJECT_GET_IFACE</NAME>
#define G_DBUS_OBJECT_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE((o), G_TYPE_DBUS_OBJECT, GDBusObjectIface))
</MACRO>
<STRUCT>
<NAME>GDBusObjectIface</NAME>
struct _GDBusObjectIface
{
  GTypeInterface parent_iface;

  /* Virtual Functions */
  const gchar     *(*get_object_path) (GDBusObject  *object);
  GList           *(*get_interfaces)  (GDBusObject  *object);
  GDBusInterface  *(*get_interface)   (GDBusObject  *object,
                                       const gchar  *interface_name);

  /* Signals */
  void (*interface_added)   (GDBusObject     *object,
                             GDBusInterface  *interface_);
  void (*interface_removed) (GDBusObject     *object,
                             GDBusInterface  *interface_);

};
</STRUCT>
<FUNCTION>
<NAME>g_dbus_object_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_get_object_path</NAME>
<RETURNS>const gchar      *</RETURNS>
GDBusObject  *object
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_get_interfaces</NAME>
<RETURNS>GList            *</RETURNS>
GDBusObject  *object
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_get_interface</NAME>
<RETURNS>GDBusInterface   *</RETURNS>
GDBusObject  *object, const gchar  *interface_name
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_OBJECT_MANAGER</NAME>
#define G_TYPE_DBUS_OBJECT_MANAGER         (g_dbus_object_manager_get_type())
</MACRO>
<MACRO>
<NAME>G_DBUS_OBJECT_MANAGER</NAME>
#define G_DBUS_OBJECT_MANAGER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT_MANAGER, GDBusObjectManager))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_OBJECT_MANAGER</NAME>
#define G_IS_DBUS_OBJECT_MANAGER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT_MANAGER))
</MACRO>
<MACRO>
<NAME>G_DBUS_OBJECT_MANAGER_GET_IFACE</NAME>
#define G_DBUS_OBJECT_MANAGER_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE((o), G_TYPE_DBUS_OBJECT_MANAGER, GDBusObjectManagerIface))
</MACRO>
<STRUCT>
<NAME>GDBusObjectManagerIface</NAME>
struct _GDBusObjectManagerIface
{
  GTypeInterface parent_iface;

  /* Virtual Functions */
  const gchar     *(*get_object_path) (GDBusObjectManager    *manager);
  GList           *(*get_objects)     (GDBusObjectManager    *manager);
  GDBusObject     *(*get_object)      (GDBusObjectManager    *manager,
                                       const gchar           *object_path);
  GDBusInterface  *(*get_interface)   (GDBusObjectManager    *manager,
                                       const gchar           *object_path,
                                       const gchar           *interface_name);

  /* Signals */
  void    (*object_added)                 (GDBusObjectManager   *manager,
                                           GDBusObject          *object);
  void    (*object_removed)               (GDBusObjectManager   *manager,
                                           GDBusObject          *object);

  void    (*interface_added)              (GDBusObjectManager   *manager,
                                           GDBusObject          *object,
                                           GDBusInterface       *interface_);
  void    (*interface_removed)            (GDBusObjectManager   *manager,
                                           GDBusObject          *object,
                                           GDBusInterface       *interface_);
};
</STRUCT>
<FUNCTION>
<NAME>g_dbus_object_manager_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_get_object_path</NAME>
<RETURNS>const gchar      *</RETURNS>
GDBusObjectManager    *manager
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_get_objects</NAME>
<RETURNS>GList            *</RETURNS>
GDBusObjectManager    *manager
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_get_object</NAME>
<RETURNS>GDBusObject      *</RETURNS>
GDBusObjectManager    *manager, const gchar           *object_path
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_get_interface</NAME>
<RETURNS>GDBusInterface   *</RETURNS>
GDBusObjectManager    *manager, const gchar           *object_path, const gchar           *interface_name
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_OBJECT_MANAGER_CLIENT</NAME>
#define G_TYPE_DBUS_OBJECT_MANAGER_CLIENT         (g_dbus_object_manager_client_get_type ())
</MACRO>
<MACRO>
<NAME>G_DBUS_OBJECT_MANAGER_CLIENT</NAME>
#define G_DBUS_OBJECT_MANAGER_CLIENT(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT_MANAGER_CLIENT, GDBusObjectManagerClient))
</MACRO>
<MACRO>
<NAME>G_DBUS_OBJECT_MANAGER_CLIENT_CLASS</NAME>
#define G_DBUS_OBJECT_MANAGER_CLIENT_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_OBJECT_MANAGER_CLIENT, GDBusObjectManagerClientClass))
</MACRO>
<MACRO>
<NAME>G_DBUS_OBJECT_MANAGER_CLIENT_GET_CLASS</NAME>
#define G_DBUS_OBJECT_MANAGER_CLIENT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_OBJECT_MANAGER_CLIENT, GDBusObjectManagerClientClass))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_OBJECT_MANAGER_CLIENT</NAME>
#define G_IS_DBUS_OBJECT_MANAGER_CLIENT(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT_MANAGER_CLIENT))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_OBJECT_MANAGER_CLIENT_CLASS</NAME>
#define G_IS_DBUS_OBJECT_MANAGER_CLIENT_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_OBJECT_MANAGER_CLIENT))
</MACRO>
<STRUCT>
<NAME>GDBusObjectManagerClient</NAME>
struct _GDBusObjectManagerClient
{
  /*< private >*/
  GObject parent_instance;
  GDBusObjectManagerClientPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GDBusObjectManagerClientClass</NAME>
struct _GDBusObjectManagerClientClass
{
  GObjectClass parent_class;

  /* signals */
  void    (*interface_proxy_signal)             (GDBusObjectManagerClient *manager,
                                                 GDBusObjectProxy         *object_proxy,
                                                 GDBusProxy               *interface_proxy,
                                                 const gchar              *sender_name,
                                                 const gchar              *signal_name,
                                                 GVariant                 *parameters);

  void    (*interface_proxy_properties_changed) (GDBusObjectManagerClient   *manager,
                                                 GDBusObjectProxy           *object_proxy,
                                                 GDBusProxy                 *interface_proxy,
                                                 GVariant                   *changed_properties,
                                                 const gchar* const         *invalidated_properties);

  /*< private >*/
  gpointer padding[8];
};
</STRUCT>
<FUNCTION>
<NAME>g_dbus_object_manager_client_get_type</NAME>
<RETURNS>GType                          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_client_new</NAME>
<RETURNS>void                           </RETURNS>
GDBusConnection               *connection, GDBusObjectManagerClientFlags  flags, const gchar                   *name, const gchar                   *object_path, GDBusProxyTypeFunc             get_proxy_type_func, gpointer                       get_proxy_type_user_data, GDestroyNotify                 get_proxy_type_destroy_notify, GCancellable                  *cancellable, GAsyncReadyCallback            callback, gpointer                       user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_client_new_finish</NAME>
<RETURNS>GDBusObjectManager            *</RETURNS>
GAsyncResult                  *res, GError                       **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_client_new_sync</NAME>
<RETURNS>GDBusObjectManager            *</RETURNS>
GDBusConnection               *connection, GDBusObjectManagerClientFlags  flags, const gchar                   *name, const gchar                   *object_path, GDBusProxyTypeFunc             get_proxy_type_func, gpointer                       get_proxy_type_user_data, GDestroyNotify                 get_proxy_type_destroy_notify, GCancellable                  *cancellable, GError                       **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_client_new_for_bus</NAME>
<RETURNS>void                           </RETURNS>
GBusType                       bus_type, GDBusObjectManagerClientFlags  flags, const gchar                   *name, const gchar                   *object_path, GDBusProxyTypeFunc             get_proxy_type_func, gpointer                       get_proxy_type_user_data, GDestroyNotify                 get_proxy_type_destroy_notify, GCancellable                  *cancellable, GAsyncReadyCallback            callback, gpointer                       user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_client_new_for_bus_finish</NAME>
<RETURNS>GDBusObjectManager            *</RETURNS>
GAsyncResult                  *res, GError                       **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_client_new_for_bus_sync</NAME>
<RETURNS>GDBusObjectManager            *</RETURNS>
GBusType                       bus_type, GDBusObjectManagerClientFlags  flags, const gchar                   *name, const gchar                   *object_path, GDBusProxyTypeFunc             get_proxy_type_func, gpointer                       get_proxy_type_user_data, GDestroyNotify                 get_proxy_type_destroy_notify, GCancellable                  *cancellable, GError                       **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_client_get_connection</NAME>
<RETURNS>GDBusConnection               *</RETURNS>
GDBusObjectManagerClient      *manager
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_client_get_flags</NAME>
<RETURNS>GDBusObjectManagerClientFlags  </RETURNS>
GDBusObjectManagerClient      *manager
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_client_get_name</NAME>
<RETURNS>const gchar                   *</RETURNS>
GDBusObjectManagerClient      *manager
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_client_get_name_owner</NAME>
<RETURNS>gchar                         *</RETURNS>
GDBusObjectManagerClient      *manager
</FUNCTION>
<STRUCT>
<NAME>GDBusObjectManagerClientPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_DBUS_OBJECT_MANAGER_SERVER</NAME>
#define G_TYPE_DBUS_OBJECT_MANAGER_SERVER         (g_dbus_object_manager_server_get_type ())
</MACRO>
<MACRO>
<NAME>G_DBUS_OBJECT_MANAGER_SERVER</NAME>
#define G_DBUS_OBJECT_MANAGER_SERVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT_MANAGER_SERVER, GDBusObjectManagerServer))
</MACRO>
<MACRO>
<NAME>G_DBUS_OBJECT_MANAGER_SERVER_CLASS</NAME>
#define G_DBUS_OBJECT_MANAGER_SERVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_OBJECT_MANAGER_SERVER, GDBusObjectManagerServerClass))
</MACRO>
<MACRO>
<NAME>G_DBUS_OBJECT_MANAGER_SERVER_GET_CLASS</NAME>
#define G_DBUS_OBJECT_MANAGER_SERVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_OBJECT_MANAGER_SERVER, GDBusObjectManagerServerClass))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_OBJECT_MANAGER_SERVER</NAME>
#define G_IS_DBUS_OBJECT_MANAGER_SERVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT_MANAGER_SERVER))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_OBJECT_MANAGER_SERVER_CLASS</NAME>
#define G_IS_DBUS_OBJECT_MANAGER_SERVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_OBJECT_MANAGER_SERVER))
</MACRO>
<STRUCT>
<NAME>GDBusObjectManagerServer</NAME>
struct _GDBusObjectManagerServer
{
  /*< private >*/
  GObject parent_instance;
  GDBusObjectManagerServerPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GDBusObjectManagerServerClass</NAME>
struct _GDBusObjectManagerServerClass
{
  GObjectClass parent_class;

  /*< private >*/
  gpointer padding[8];
};
</STRUCT>
<FUNCTION>
<NAME>g_dbus_object_manager_server_get_type</NAME>
<RETURNS>GType                      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_server_new</NAME>
<RETURNS>GDBusObjectManagerServer  *</RETURNS>
const gchar               *object_path
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_server_get_connection</NAME>
<RETURNS>GDBusConnection           *</RETURNS>
GDBusObjectManagerServer  *manager
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_server_set_connection</NAME>
<RETURNS>void                       </RETURNS>
GDBusObjectManagerServer  *manager, GDBusConnection           *connection
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_server_export</NAME>
<RETURNS>void                       </RETURNS>
GDBusObjectManagerServer  *manager, GDBusObjectSkeleton       *object
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_server_export_uniquely</NAME>
<RETURNS>void                       </RETURNS>
GDBusObjectManagerServer  *manager, GDBusObjectSkeleton       *object
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_server_is_exported</NAME>
<RETURNS>gboolean                   </RETURNS>
GDBusObjectManagerServer  *manager, GDBusObjectSkeleton       *object
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_manager_server_unexport</NAME>
<RETURNS>gboolean                   </RETURNS>
GDBusObjectManagerServer  *manager, const gchar               *object_path
</FUNCTION>
<STRUCT>
<NAME>GDBusObjectManagerServerPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_DBUS_OBJECT_PROXY</NAME>
#define G_TYPE_DBUS_OBJECT_PROXY         (g_dbus_object_proxy_get_type ())
</MACRO>
<MACRO>
<NAME>G_DBUS_OBJECT_PROXY</NAME>
#define G_DBUS_OBJECT_PROXY(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT_PROXY, GDBusObjectProxy))
</MACRO>
<MACRO>
<NAME>G_DBUS_OBJECT_PROXY_CLASS</NAME>
#define G_DBUS_OBJECT_PROXY_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_OBJECT_PROXY, GDBusObjectProxyClass))
</MACRO>
<MACRO>
<NAME>G_DBUS_OBJECT_PROXY_GET_CLASS</NAME>
#define G_DBUS_OBJECT_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_OBJECT_PROXY, GDBusObjectProxyClass))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_OBJECT_PROXY</NAME>
#define G_IS_DBUS_OBJECT_PROXY(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT_PROXY))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_OBJECT_PROXY_CLASS</NAME>
#define G_IS_DBUS_OBJECT_PROXY_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_OBJECT_PROXY))
</MACRO>
<STRUCT>
<NAME>GDBusObjectProxy</NAME>
struct _GDBusObjectProxy
{
  /*< private >*/
  GObject parent_instance;
  GDBusObjectProxyPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GDBusObjectProxyClass</NAME>
struct _GDBusObjectProxyClass
{
  GObjectClass parent_class;

  /*< private >*/
  gpointer padding[8];
};
</STRUCT>
<FUNCTION>
<NAME>g_dbus_object_proxy_get_type</NAME>
<RETURNS>GType              </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_proxy_new</NAME>
<RETURNS>GDBusObjectProxy  *</RETURNS>
GDBusConnection   *connection, const gchar       *object_path
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_proxy_get_connection</NAME>
<RETURNS>GDBusConnection   *</RETURNS>
GDBusObjectProxy  *proxy
</FUNCTION>
<STRUCT>
<NAME>GDBusObjectProxyPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_DBUS_OBJECT_SKELETON</NAME>
#define G_TYPE_DBUS_OBJECT_SKELETON         (g_dbus_object_skeleton_get_type ())
</MACRO>
<MACRO>
<NAME>G_DBUS_OBJECT_SKELETON</NAME>
#define G_DBUS_OBJECT_SKELETON(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT_SKELETON, GDBusObjectSkeleton))
</MACRO>
<MACRO>
<NAME>G_DBUS_OBJECT_SKELETON_CLASS</NAME>
#define G_DBUS_OBJECT_SKELETON_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_OBJECT_SKELETON, GDBusObjectSkeletonClass))
</MACRO>
<MACRO>
<NAME>G_DBUS_OBJECT_SKELETON_GET_CLASS</NAME>
#define G_DBUS_OBJECT_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_OBJECT_SKELETON, GDBusObjectSkeletonClass))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_OBJECT_SKELETON</NAME>
#define G_IS_DBUS_OBJECT_SKELETON(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT_SKELETON))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_OBJECT_SKELETON_CLASS</NAME>
#define G_IS_DBUS_OBJECT_SKELETON_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_OBJECT_SKELETON))
</MACRO>
<STRUCT>
<NAME>GDBusObjectSkeleton</NAME>
struct _GDBusObjectSkeleton
{
  /*< private >*/
  GObject parent_instance;
  GDBusObjectSkeletonPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GDBusObjectSkeletonClass</NAME>
struct _GDBusObjectSkeletonClass
{
  GObjectClass parent_class;

  /* Signals */
  gboolean (*authorize_method) (GDBusObjectSkeleton       *object,
                                GDBusInterfaceSkeleton    *interface_,
                                GDBusMethodInvocation *invocation);

  /*< private >*/
  gpointer padding[8];
};
</STRUCT>
<FUNCTION>
<NAME>g_dbus_object_skeleton_get_type</NAME>
<RETURNS>GType                 </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_skeleton_new</NAME>
<RETURNS>GDBusObjectSkeleton  *</RETURNS>
const gchar            *object_path
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_skeleton_flush</NAME>
<RETURNS>void                  </RETURNS>
GDBusObjectSkeleton    *object
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_skeleton_add_interface</NAME>
<RETURNS>void                  </RETURNS>
GDBusObjectSkeleton    *object, GDBusInterfaceSkeleton *interface_
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_skeleton_remove_interface</NAME>
<RETURNS>void                  </RETURNS>
GDBusObjectSkeleton    *object, GDBusInterfaceSkeleton *interface_
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_skeleton_remove_interface_by_name</NAME>
<RETURNS>void                  </RETURNS>
GDBusObjectSkeleton    *object, const gchar            *interface_name
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_object_skeleton_set_object_path</NAME>
<RETURNS>void                  </RETURNS>
GDBusObjectSkeleton    *object, const gchar            *object_path
</FUNCTION>
<STRUCT>
<NAME>GDBusObjectSkeletonPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_DBUS_PROXY</NAME>
#define G_TYPE_DBUS_PROXY         (g_dbus_proxy_get_type ())
</MACRO>
<MACRO>
<NAME>G_DBUS_PROXY</NAME>
#define G_DBUS_PROXY(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_PROXY, GDBusProxy))
</MACRO>
<MACRO>
<NAME>G_DBUS_PROXY_CLASS</NAME>
#define G_DBUS_PROXY_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_PROXY, GDBusProxyClass))
</MACRO>
<MACRO>
<NAME>G_DBUS_PROXY_GET_CLASS</NAME>
#define G_DBUS_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_PROXY, GDBusProxyClass))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_PROXY</NAME>
#define G_IS_DBUS_PROXY(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_PROXY))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_PROXY_CLASS</NAME>
#define G_IS_DBUS_PROXY_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_PROXY))
</MACRO>
<STRUCT>
<NAME>GDBusProxy</NAME>
struct _GDBusProxy
{
  /*< private >*/
  GObject parent_instance;
  GDBusProxyPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GDBusProxyClass</NAME>
struct _GDBusProxyClass
{
  /*< private >*/
  GObjectClass parent_class;

  /*< public >*/
  /* Signals */
  void (*g_properties_changed) (GDBusProxy          *proxy,
                                GVariant            *changed_properties,
                                const gchar* const  *invalidated_properties);
  void (*g_signal)             (GDBusProxy          *proxy,
                                const gchar         *sender_name,
                                const gchar         *signal_name,
                                GVariant            *parameters);

  /*< private >*/
  /* Padding for future expansion */
  gpointer padding[32];
};
</STRUCT>
<FUNCTION>
<NAME>g_dbus_proxy_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_new</NAME>
<RETURNS>void              </RETURNS>
GDBusConnection     *connection, GDBusProxyFlags      flags, GDBusInterfaceInfo *info, const gchar         *name, const gchar         *object_path, const gchar         *interface_name, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_new_finish</NAME>
<RETURNS>GDBusProxy       *</RETURNS>
GAsyncResult        *res, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_new_sync</NAME>
<RETURNS>GDBusProxy       *</RETURNS>
GDBusConnection     *connection, GDBusProxyFlags      flags, GDBusInterfaceInfo *info, const gchar         *name, const gchar         *object_path, const gchar         *interface_name, GCancellable        *cancellable, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_new_for_bus</NAME>
<RETURNS>void              </RETURNS>
GBusType             bus_type, GDBusProxyFlags      flags, GDBusInterfaceInfo *info, const gchar         *name, const gchar         *object_path, const gchar         *interface_name, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_new_for_bus_finish</NAME>
<RETURNS>GDBusProxy       *</RETURNS>
GAsyncResult        *res, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_new_for_bus_sync</NAME>
<RETURNS>GDBusProxy       *</RETURNS>
GBusType             bus_type, GDBusProxyFlags      flags, GDBusInterfaceInfo *info, const gchar         *name, const gchar         *object_path, const gchar         *interface_name, GCancellable        *cancellable, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_get_connection</NAME>
<RETURNS>GDBusConnection  *</RETURNS>
GDBusProxy          *proxy
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_get_flags</NAME>
<RETURNS>GDBusProxyFlags   </RETURNS>
GDBusProxy          *proxy
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_get_name</NAME>
<RETURNS>const gchar      *</RETURNS>
GDBusProxy          *proxy
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_get_name_owner</NAME>
<RETURNS>gchar            *</RETURNS>
GDBusProxy          *proxy
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_get_object_path</NAME>
<RETURNS>const gchar      *</RETURNS>
GDBusProxy          *proxy
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_get_interface_name</NAME>
<RETURNS>const gchar      *</RETURNS>
GDBusProxy          *proxy
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_get_default_timeout</NAME>
<RETURNS>gint              </RETURNS>
GDBusProxy          *proxy
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_set_default_timeout</NAME>
<RETURNS>void              </RETURNS>
GDBusProxy          *proxy, gint                 timeout_msec
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_get_interface_info</NAME>
<RETURNS>GDBusInterfaceInfo  *</RETURNS>
GDBusProxy          *proxy
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_set_interface_info</NAME>
<RETURNS>void              </RETURNS>
GDBusProxy           *proxy, GDBusInterfaceInfo   *info
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_get_cached_property</NAME>
<RETURNS>GVariant         *</RETURNS>
GDBusProxy          *proxy, const gchar         *property_name
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_set_cached_property</NAME>
<RETURNS>void              </RETURNS>
GDBusProxy          *proxy, const gchar         *property_name, GVariant            *value
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_get_cached_property_names</NAME>
<RETURNS>gchar           **</RETURNS>
GDBusProxy          *proxy
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_call</NAME>
<RETURNS>void              </RETURNS>
GDBusProxy          *proxy, const gchar         *method_name, GVariant            *parameters, GDBusCallFlags       flags, gint                 timeout_msec, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_call_finish</NAME>
<RETURNS>GVariant         *</RETURNS>
GDBusProxy          *proxy, GAsyncResult        *res, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_call_sync</NAME>
<RETURNS>GVariant         *</RETURNS>
GDBusProxy          *proxy, const gchar         *method_name, GVariant            *parameters, GDBusCallFlags       flags, gint                 timeout_msec, GCancellable        *cancellable, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_call_with_unix_fd_list</NAME>
<RETURNS>void              </RETURNS>
GDBusProxy          *proxy, const gchar         *method_name, GVariant            *parameters, GDBusCallFlags       flags, gint                 timeout_msec, GUnixFDList         *fd_list, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_call_with_unix_fd_list_finish</NAME>
<RETURNS>GVariant         *</RETURNS>
GDBusProxy          *proxy, GUnixFDList        **out_fd_list, GAsyncResult        *res, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_proxy_call_with_unix_fd_list_sync</NAME>
<RETURNS>GVariant         *</RETURNS>
GDBusProxy          *proxy, const gchar         *method_name, GVariant            *parameters, GDBusCallFlags       flags, gint                 timeout_msec, GUnixFDList         *fd_list, GUnixFDList        **out_fd_list, GCancellable        *cancellable, GError             **error
</FUNCTION>
<STRUCT>
<NAME>GDBusProxyPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_DBUS_SERVER</NAME>
#define G_TYPE_DBUS_SERVER         (g_dbus_server_get_type ())
</MACRO>
<MACRO>
<NAME>G_DBUS_SERVER</NAME>
#define G_DBUS_SERVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_SERVER, GDBusServer))
</MACRO>
<MACRO>
<NAME>G_IS_DBUS_SERVER</NAME>
#define G_IS_DBUS_SERVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_SERVER))
</MACRO>
<FUNCTION>
<NAME>g_dbus_server_get_type</NAME>
<RETURNS>GType              </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_server_new_sync</NAME>
<RETURNS>GDBusServer       *</RETURNS>
const gchar       *address, GDBusServerFlags   flags, const gchar       *guid, GDBusAuthObserver *observer, GCancellable      *cancellable, GError           **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_server_get_client_address</NAME>
<RETURNS>const gchar       *</RETURNS>
GDBusServer       *server
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_server_get_guid</NAME>
<RETURNS>const gchar       *</RETURNS>
GDBusServer       *server
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_server_get_flags</NAME>
<RETURNS>GDBusServerFlags   </RETURNS>
GDBusServer       *server
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_server_start</NAME>
<RETURNS>void               </RETURNS>
GDBusServer       *server
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_server_stop</NAME>
<RETURNS>void               </RETURNS>
GDBusServer       *server
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_server_is_active</NAME>
<RETURNS>gboolean           </RETURNS>
GDBusServer       *server
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_is_guid</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *string
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_generate_guid</NAME>
<RETURNS>gchar  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_is_name</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *string
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_is_unique_name</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *string
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_is_member_name</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *string
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_is_interface_name</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *string
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_gvariant_to_gvalue</NAME>
<RETURNS>void  </RETURNS>
GVariant  *value, GValue    *out_gvalue
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_gvalue_to_gvariant</NAME>
<RETURNS>GVariant  *</RETURNS>
const GValue         *gvalue, const GVariantType   *type
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DESKTOP_APP_INFO</NAME>
#define G_TYPE_DESKTOP_APP_INFO         (g_desktop_app_info_get_type ())
</MACRO>
<MACRO>
<NAME>G_DESKTOP_APP_INFO</NAME>
#define G_DESKTOP_APP_INFO(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DESKTOP_APP_INFO, GDesktopAppInfo))
</MACRO>
<MACRO>
<NAME>G_DESKTOP_APP_INFO_CLASS</NAME>
#define G_DESKTOP_APP_INFO_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DESKTOP_APP_INFO, GDesktopAppInfoClass))
</MACRO>
<MACRO>
<NAME>G_IS_DESKTOP_APP_INFO</NAME>
#define G_IS_DESKTOP_APP_INFO(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DESKTOP_APP_INFO))
</MACRO>
<MACRO>
<NAME>G_IS_DESKTOP_APP_INFO_CLASS</NAME>
#define G_IS_DESKTOP_APP_INFO_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DESKTOP_APP_INFO))
</MACRO>
<MACRO>
<NAME>G_DESKTOP_APP_INFO_GET_CLASS</NAME>
#define G_DESKTOP_APP_INFO_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DESKTOP_APP_INFO, GDesktopAppInfoClass))
</MACRO>
<STRUCT>
<NAME>GDesktopAppInfoClass</NAME>
struct _GDesktopAppInfoClass
{
  GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>g_desktop_app_info_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_new_from_filename</NAME>
<RETURNS>GDesktopAppInfo  *</RETURNS>
const char      *filename
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_new_from_keyfile</NAME>
<RETURNS>GDesktopAppInfo  *</RETURNS>
GKeyFile        *key_file
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_get_filename</NAME>
<RETURNS>const char  *     </RETURNS>
GDesktopAppInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_get_generic_name</NAME>
<RETURNS>const char  *     </RETURNS>
GDesktopAppInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_get_categories</NAME>
<RETURNS>const char  *     </RETURNS>
GDesktopAppInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_get_keywords</NAME>
<RETURNS>const char  * const *</RETURNS>
GDesktopAppInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_get_nodisplay</NAME>
<RETURNS>gboolean          </RETURNS>
GDesktopAppInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_get_show_in</NAME>
<RETURNS>gboolean          </RETURNS>
GDesktopAppInfo *info, const gchar     *desktop_env
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_get_startup_wm_class</NAME>
<RETURNS>const char  *     </RETURNS>
GDesktopAppInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_new</NAME>
<RETURNS>GDesktopAppInfo  *</RETURNS>
const char      *desktop_id
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_get_is_hidden</NAME>
<RETURNS>gboolean          </RETURNS>
GDesktopAppInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_set_desktop_env</NAME>
<DEPRECATED/>
<RETURNS>void              </RETURNS>
const char      *desktop_env
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_has_key</NAME>
<RETURNS>gboolean          </RETURNS>
GDesktopAppInfo *info, const char      *key
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_get_string</NAME>
<RETURNS>char  *           </RETURNS>
GDesktopAppInfo *info, const char      *key
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_get_locale_string</NAME>
<RETURNS>char  *           </RETURNS>
GDesktopAppInfo *info, const char      *key
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_get_boolean</NAME>
<RETURNS>gboolean          </RETURNS>
GDesktopAppInfo *info, const char      *key
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_list_actions</NAME>
<RETURNS>const gchar  * const *</RETURNS>
GDesktopAppInfo   *info
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_launch_action</NAME>
<RETURNS>void                     </RETURNS>
GDesktopAppInfo   *info, const gchar       *action_name, GAppLaunchContext *launch_context
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_get_action_name</NAME>
<RETURNS>gchar  *                 </RETURNS>
GDesktopAppInfo   *info, const gchar       *action_name
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DESKTOP_APP_INFO_LOOKUP</NAME>
<DEPRECATED/>
#define G_TYPE_DESKTOP_APP_INFO_LOOKUP           (g_desktop_app_info_lookup_get_type ())
</MACRO>
<MACRO>
<NAME>G_DESKTOP_APP_INFO_LOOKUP</NAME>
<DEPRECATED/>
#define G_DESKTOP_APP_INFO_LOOKUP(obj)           (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_DESKTOP_APP_INFO_LOOKUP, GDesktopAppInfoLookup))
</MACRO>
<MACRO>
<NAME>G_IS_DESKTOP_APP_INFO_LOOKUP</NAME>
<DEPRECATED/>
#define G_IS_DESKTOP_APP_INFO_LOOKUP(obj)	 (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_DESKTOP_APP_INFO_LOOKUP))
</MACRO>
<MACRO>
<NAME>G_DESKTOP_APP_INFO_LOOKUP_GET_IFACE</NAME>
<DEPRECATED/>
#define G_DESKTOP_APP_INFO_LOOKUP_GET_IFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_DESKTOP_APP_INFO_LOOKUP, GDesktopAppInfoLookupIface))
</MACRO>
<MACRO>
<NAME>G_DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME</NAME>
<DEPRECATED/>
#define G_DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME "gio-desktop-app-info-lookup"
</MACRO>
<STRUCT>
<NAME>GDesktopAppInfoLookupIface</NAME>
<DEPRECATED/>
struct _GDesktopAppInfoLookupIface
{
  GTypeInterface g_iface;

  GAppInfo * (* get_default_for_uri_scheme) (GDesktopAppInfoLookup *lookup,
                                             const char            *uri_scheme);
};
</STRUCT>
<FUNCTION>
<NAME>g_desktop_app_info_lookup_get_type</NAME>
<DEPRECATED/>
<RETURNS>GType      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_lookup_get_default_for_uri_scheme</NAME>
<DEPRECATED/>
<RETURNS>GAppInfo  *</RETURNS>
GDesktopAppInfoLookup *lookup, const char            *uri_scheme
</FUNCTION>
<USER_FUNCTION>
<NAME>GDesktopAppLaunchCallback</NAME>
<RETURNS>void </RETURNS>
GDesktopAppInfo  *appinfo,
					   GPid              pid,
					   gpointer          user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_launch_uris_as_manager</NAME>
<RETURNS>gboolean     </RETURNS>
GDesktopAppInfo            *appinfo, GList                      *uris, GAppLaunchContext          *launch_context, GSpawnFlags                 spawn_flags, GSpawnChildSetupFunc        user_setup, gpointer                    user_setup_data, GDesktopAppLaunchCallback   pid_callback, gpointer                    pid_callback_data, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_launch_uris_as_manager_with_fds</NAME>
<RETURNS>gboolean     </RETURNS>
GDesktopAppInfo            *appinfo, GList                      *uris, GAppLaunchContext          *launch_context, GSpawnFlags                 spawn_flags, GSpawnChildSetupFunc        user_setup, gpointer                    user_setup_data, GDesktopAppLaunchCallback   pid_callback, gpointer                    pid_callback_data, gint                        stdin_fd, gint                        stdout_fd, gint                        stderr_fd, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_search</NAME>
<RETURNS>gchar  *** </RETURNS>
const gchar *search_string
</FUNCTION>
<FUNCTION>
<NAME>g_desktop_app_info_get_implementations</NAME>
<RETURNS>GList  *</RETURNS>
const gchar *interface
</FUNCTION>
<STRUCT>
<NAME>GDesktopAppInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GDesktopAppInfoLookup</NAME>
<DEPRECATED/>
</STRUCT>
<FUNCTION>
<NAME>g_document_portal_add_document</NAME>
<RETURNS>char  * </RETURNS>
GFile   *file, GError **error
</FUNCTION>
<FUNCTION>
<NAME>g_document_portal_add_documents</NAME>
<RETURNS>GList  * </RETURNS>
GList       *uris, const char  *app_id, GError     **error
</FUNCTION>
<MACRO>
<NAME>G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE</NAME>
#define G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE "unix-device"
</MACRO>
<MACRO>
<NAME>G_TYPE_DRIVE</NAME>
#define G_TYPE_DRIVE           (g_drive_get_type ())
</MACRO>
<MACRO>
<NAME>G_DRIVE</NAME>
#define G_DRIVE(obj)           (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_DRIVE, GDrive))
</MACRO>
<MACRO>
<NAME>G_IS_DRIVE</NAME>
#define G_IS_DRIVE(obj)        (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_DRIVE))
</MACRO>
<MACRO>
<NAME>G_DRIVE_GET_IFACE</NAME>
#define G_DRIVE_GET_IFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_DRIVE, GDriveIface))
</MACRO>
<STRUCT>
<NAME>GDriveIface</NAME>
struct _GDriveIface
{
  GTypeInterface g_iface;

  /* signals */
  void     (* changed)                  (GDrive              *drive);
  void     (* disconnected)             (GDrive              *drive);
  void     (* eject_button)             (GDrive              *drive);

  /* Virtual Table */
  char *   (* get_name)                 (GDrive              *drive);
  GIcon *  (* get_icon)                 (GDrive              *drive);
  gboolean (* has_volumes)              (GDrive              *drive);
  GList *  (* get_volumes)              (GDrive              *drive);
  gboolean (* is_media_removable)       (GDrive              *drive);
  gboolean (* has_media)                (GDrive              *drive);
  gboolean (* is_media_check_automatic) (GDrive              *drive);
  gboolean (* can_eject)                (GDrive              *drive);
  gboolean (* can_poll_for_media)       (GDrive              *drive);
  void     (* eject)                    (GDrive              *drive,
                                         GMountUnmountFlags   flags,
                                         GCancellable        *cancellable,
                                         GAsyncReadyCallback  callback,
                                         gpointer             user_data);
  gboolean (* eject_finish)             (GDrive              *drive,
                                         GAsyncResult        *result,
                                         GError             **error);
  void     (* poll_for_media)           (GDrive              *drive,
                                         GCancellable        *cancellable,
                                         GAsyncReadyCallback  callback,
                                         gpointer             user_data);
  gboolean (* poll_for_media_finish)    (GDrive              *drive,
                                         GAsyncResult        *result,
                                         GError             **error);

  char *   (* get_identifier)           (GDrive              *drive,
                                         const char          *kind);
  char **  (* enumerate_identifiers)    (GDrive              *drive);

  GDriveStartStopType (* get_start_stop_type) (GDrive        *drive);

  gboolean (* can_start)                (GDrive              *drive);
  gboolean (* can_start_degraded)       (GDrive              *drive);
  void     (* start)                    (GDrive              *drive,
                                         GDriveStartFlags     flags,
                                         GMountOperation     *mount_operation,
                                         GCancellable        *cancellable,
                                         GAsyncReadyCallback  callback,
                                         gpointer             user_data);
  gboolean (* start_finish)             (GDrive              *drive,
                                         GAsyncResult        *result,
                                         GError             **error);

  gboolean (* can_stop)                 (GDrive              *drive);
  void     (* stop)                     (GDrive              *drive,
                                         GMountUnmountFlags   flags,
                                         GMountOperation     *mount_operation,
                                         GCancellable        *cancellable,
                                         GAsyncReadyCallback  callback,
                                         gpointer             user_data);
  gboolean (* stop_finish)              (GDrive              *drive,
                                         GAsyncResult        *result,
                                         GError             **error);
  /* signal, not VFunc */
  void     (* stop_button)              (GDrive              *drive);

  void        (* eject_with_operation)      (GDrive              *drive,
                                             GMountUnmountFlags   flags,
                                             GMountOperation     *mount_operation,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* eject_with_operation_finish) (GDrive            *drive,
                                             GAsyncResult        *result,
                                             GError             **error);

  const gchar * (* get_sort_key)        (GDrive              *drive);
  GIcon *       (* get_symbolic_icon)   (GDrive              *drive);
  gboolean      (* is_removable)        (GDrive              *drive);

};
</STRUCT>
<FUNCTION>
<NAME>g_drive_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_drive_get_name</NAME>
<RETURNS>char  *   </RETURNS>
GDrive               *drive
</FUNCTION>
<FUNCTION>
<NAME>g_drive_get_icon</NAME>
<RETURNS>GIcon  *  </RETURNS>
GDrive               *drive
</FUNCTION>
<FUNCTION>
<NAME>g_drive_get_symbolic_icon</NAME>
<RETURNS>GIcon  *  </RETURNS>
GDrive               *drive
</FUNCTION>
<FUNCTION>
<NAME>g_drive_has_volumes</NAME>
<RETURNS>gboolean  </RETURNS>
GDrive               *drive
</FUNCTION>
<FUNCTION>
<NAME>g_drive_get_volumes</NAME>
<RETURNS>GList  *  </RETURNS>
GDrive               *drive
</FUNCTION>
<FUNCTION>
<NAME>g_drive_is_removable</NAME>
<RETURNS>gboolean  </RETURNS>
GDrive               *drive
</FUNCTION>
<FUNCTION>
<NAME>g_drive_is_media_removable</NAME>
<RETURNS>gboolean  </RETURNS>
GDrive               *drive
</FUNCTION>
<FUNCTION>
<NAME>g_drive_has_media</NAME>
<RETURNS>gboolean  </RETURNS>
GDrive               *drive
</FUNCTION>
<FUNCTION>
<NAME>g_drive_is_media_check_automatic</NAME>
<RETURNS>gboolean  </RETURNS>
GDrive               *drive
</FUNCTION>
<FUNCTION>
<NAME>g_drive_can_poll_for_media</NAME>
<RETURNS>gboolean  </RETURNS>
GDrive               *drive
</FUNCTION>
<FUNCTION>
<NAME>g_drive_can_eject</NAME>
<RETURNS>gboolean  </RETURNS>
GDrive               *drive
</FUNCTION>
<FUNCTION>
<NAME>g_drive_eject</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GDrive               *drive, GMountUnmountFlags    flags, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_drive_eject_finish</NAME>
<DEPRECATED/>
<RETURNS>gboolean  </RETURNS>
GDrive               *drive, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_drive_poll_for_media</NAME>
<RETURNS>void      </RETURNS>
GDrive               *drive, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_drive_poll_for_media_finish</NAME>
<RETURNS>gboolean  </RETURNS>
GDrive               *drive, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_drive_get_identifier</NAME>
<RETURNS>char  *   </RETURNS>
GDrive              *drive, const char          *kind
</FUNCTION>
<FUNCTION>
<NAME>g_drive_enumerate_identifiers</NAME>
<RETURNS>char  **  </RETURNS>
GDrive              *drive
</FUNCTION>
<FUNCTION>
<NAME>g_drive_get_start_stop_type</NAME>
<RETURNS>GDriveStartStopType  </RETURNS>
GDrive        *drive
</FUNCTION>
<FUNCTION>
<NAME>g_drive_can_start</NAME>
<RETURNS>gboolean  </RETURNS>
GDrive              *drive
</FUNCTION>
<FUNCTION>
<NAME>g_drive_can_start_degraded</NAME>
<RETURNS>gboolean  </RETURNS>
GDrive              *drive
</FUNCTION>
<FUNCTION>
<NAME>g_drive_start</NAME>
<RETURNS>void      </RETURNS>
GDrive              *drive, GDriveStartFlags     flags, GMountOperation     *mount_operation, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_drive_start_finish</NAME>
<RETURNS>gboolean  </RETURNS>
GDrive               *drive, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_drive_can_stop</NAME>
<RETURNS>gboolean  </RETURNS>
GDrive               *drive
</FUNCTION>
<FUNCTION>
<NAME>g_drive_stop</NAME>
<RETURNS>void      </RETURNS>
GDrive               *drive, GMountUnmountFlags    flags, GMountOperation      *mount_operation, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_drive_stop_finish</NAME>
<RETURNS>gboolean  </RETURNS>
GDrive               *drive, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_drive_eject_with_operation</NAME>
<RETURNS>void         </RETURNS>
GDrive              *drive, GMountUnmountFlags   flags, GMountOperation     *mount_operation, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_drive_eject_with_operation_finish</NAME>
<RETURNS>gboolean     </RETURNS>
GDrive            *drive, GAsyncResult        *result, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_drive_get_sort_key</NAME>
<RETURNS>const gchar  *</RETURNS>
GDrive               *drive
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DTLS_CLIENT_CONNECTION</NAME>
#define G_TYPE_DTLS_CLIENT_CONNECTION                (g_dtls_client_connection_get_type ())
</MACRO>
<MACRO>
<NAME>G_DTLS_CLIENT_CONNECTION</NAME>
#define G_DTLS_CLIENT_CONNECTION(inst)               (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_DTLS_CLIENT_CONNECTION, GDtlsClientConnection))
</MACRO>
<MACRO>
<NAME>G_IS_DTLS_CLIENT_CONNECTION</NAME>
#define G_IS_DTLS_CLIENT_CONNECTION(inst)            (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_DTLS_CLIENT_CONNECTION))
</MACRO>
<MACRO>
<NAME>G_DTLS_CLIENT_CONNECTION_GET_INTERFACE</NAME>
#define G_DTLS_CLIENT_CONNECTION_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_DTLS_CLIENT_CONNECTION, GDtlsClientConnectionInterface))
</MACRO>
<STRUCT>
<NAME>GDtlsClientConnectionInterface</NAME>
struct _GDtlsClientConnectionInterface
{
  GTypeInterface g_iface;
};
</STRUCT>
<FUNCTION>
<NAME>g_dtls_client_connection_get_type</NAME>
<RETURNS>GType                 </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_client_connection_new</NAME>
<RETURNS>GDatagramBased       *</RETURNS>
GDatagramBased         *base_socket, GSocketConnectable     *server_identity, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_client_connection_get_validation_flags</NAME>
<RETURNS>GTlsCertificateFlags  </RETURNS>
GDtlsClientConnection  *conn
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_client_connection_set_validation_flags</NAME>
<RETURNS>void                  </RETURNS>
GDtlsClientConnection  *conn, GTlsCertificateFlags    flags
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_client_connection_get_server_identity</NAME>
<RETURNS>GSocketConnectable   *</RETURNS>
GDtlsClientConnection  *conn
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_client_connection_set_server_identity</NAME>
<RETURNS>void                  </RETURNS>
GDtlsClientConnection  *conn, GSocketConnectable     *identity
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_client_connection_get_accepted_cas</NAME>
<RETURNS>GList  *              </RETURNS>
GDtlsClientConnection  *conn
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DTLS_CONNECTION</NAME>
#define G_TYPE_DTLS_CONNECTION                (g_dtls_connection_get_type ())
</MACRO>
<MACRO>
<NAME>G_DTLS_CONNECTION</NAME>
#define G_DTLS_CONNECTION(inst)               (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_DTLS_CONNECTION, GDtlsConnection))
</MACRO>
<MACRO>
<NAME>G_IS_DTLS_CONNECTION</NAME>
#define G_IS_DTLS_CONNECTION(inst)            (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_DTLS_CONNECTION))
</MACRO>
<MACRO>
<NAME>G_DTLS_CONNECTION_GET_INTERFACE</NAME>
#define G_DTLS_CONNECTION_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_DTLS_CONNECTION, GDtlsConnectionInterface))
</MACRO>
<STRUCT>
<NAME>GDtlsConnectionInterface</NAME>
struct _GDtlsConnectionInterface
{
  GTypeInterface g_iface;

  /* signals */
  gboolean (*accept_certificate) (GDtlsConnection       *connection,
                                  GTlsCertificate       *peer_cert,
                                  GTlsCertificateFlags   errors);

  /* methods */
  gboolean (*handshake)          (GDtlsConnection       *conn,
                                  GCancellable          *cancellable,
                                  GError               **error);

  void     (*handshake_async)    (GDtlsConnection       *conn,
                                  int                    io_priority,
                                  GCancellable          *cancellable,
                                  GAsyncReadyCallback    callback,
                                  gpointer               user_data);
  gboolean (*handshake_finish)   (GDtlsConnection       *conn,
                                  GAsyncResult          *result,
                                  GError               **error);

  gboolean (*shutdown)           (GDtlsConnection       *conn,
                                  gboolean               shutdown_read,
                                  gboolean               shutdown_write,
                                  GCancellable          *cancellable,
                                  GError               **error);

  void     (*shutdown_async)     (GDtlsConnection       *conn,
                                  gboolean               shutdown_read,
                                  gboolean               shutdown_write,
                                  int                    io_priority,
                                  GCancellable          *cancellable,
                                  GAsyncReadyCallback    callback,
                                  gpointer               user_data);
  gboolean (*shutdown_finish)    (GDtlsConnection       *conn,
                                  GAsyncResult          *result,
                                  GError               **error);
};
</STRUCT>
<FUNCTION>
<NAME>g_dtls_connection_get_type</NAME>
<RETURNS>GType                  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_set_database</NAME>
<RETURNS>void                   </RETURNS>
GDtlsConnection       *conn, GTlsDatabase          *database
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_get_database</NAME>
<RETURNS>GTlsDatabase          *</RETURNS>
GDtlsConnection       *conn
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_set_certificate</NAME>
<RETURNS>void                   </RETURNS>
GDtlsConnection       *conn, GTlsCertificate       *certificate
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_get_certificate</NAME>
<RETURNS>GTlsCertificate       *</RETURNS>
GDtlsConnection       *conn
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_set_interaction</NAME>
<RETURNS>void                   </RETURNS>
GDtlsConnection       *conn, GTlsInteraction       *interaction
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_get_interaction</NAME>
<RETURNS>GTlsInteraction       *</RETURNS>
GDtlsConnection       *conn
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_get_peer_certificate</NAME>
<RETURNS>GTlsCertificate       *</RETURNS>
GDtlsConnection       *conn
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_get_peer_certificate_errors</NAME>
<RETURNS>GTlsCertificateFlags   </RETURNS>
GDtlsConnection       *conn
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_set_require_close_notify</NAME>
<RETURNS>void                   </RETURNS>
GDtlsConnection       *conn, gboolean               require_close_notify
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_get_require_close_notify</NAME>
<RETURNS>gboolean               </RETURNS>
GDtlsConnection       *conn
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_set_rehandshake_mode</NAME>
<RETURNS>void                   </RETURNS>
GDtlsConnection       *conn, GTlsRehandshakeMode    mode
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_get_rehandshake_mode</NAME>
<RETURNS>GTlsRehandshakeMode    </RETURNS>
GDtlsConnection       *conn
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_handshake</NAME>
<RETURNS>gboolean               </RETURNS>
GDtlsConnection       *conn, GCancellable          *cancellable, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_handshake_async</NAME>
<RETURNS>void                   </RETURNS>
GDtlsConnection       *conn, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_handshake_finish</NAME>
<RETURNS>gboolean               </RETURNS>
GDtlsConnection       *conn, GAsyncResult          *result, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_shutdown</NAME>
<RETURNS>gboolean               </RETURNS>
GDtlsConnection       *conn, gboolean               shutdown_read, gboolean               shutdown_write, GCancellable          *cancellable, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_shutdown_async</NAME>
<RETURNS>void                   </RETURNS>
GDtlsConnection       *conn, gboolean               shutdown_read, gboolean               shutdown_write, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_shutdown_finish</NAME>
<RETURNS>gboolean               </RETURNS>
GDtlsConnection       *conn, GAsyncResult          *result, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_close</NAME>
<RETURNS>gboolean               </RETURNS>
GDtlsConnection       *conn, GCancellable          *cancellable, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_close_async</NAME>
<RETURNS>void                   </RETURNS>
GDtlsConnection       *conn, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_close_finish</NAME>
<RETURNS>gboolean               </RETURNS>
GDtlsConnection       *conn, GAsyncResult          *result, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_connection_emit_accept_certificate</NAME>
<RETURNS>gboolean               </RETURNS>
GDtlsConnection       *conn, GTlsCertificate       *peer_cert, GTlsCertificateFlags   errors
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DTLS_SERVER_CONNECTION</NAME>
#define G_TYPE_DTLS_SERVER_CONNECTION                (g_dtls_server_connection_get_type ())
</MACRO>
<MACRO>
<NAME>G_DTLS_SERVER_CONNECTION</NAME>
#define G_DTLS_SERVER_CONNECTION(inst)               (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_DTLS_SERVER_CONNECTION, GDtlsServerConnection))
</MACRO>
<MACRO>
<NAME>G_IS_DTLS_SERVER_CONNECTION</NAME>
#define G_IS_DTLS_SERVER_CONNECTION(inst)            (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_DTLS_SERVER_CONNECTION))
</MACRO>
<MACRO>
<NAME>G_DTLS_SERVER_CONNECTION_GET_INTERFACE</NAME>
#define G_DTLS_SERVER_CONNECTION_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_DTLS_SERVER_CONNECTION, GDtlsServerConnectionInterface))
</MACRO>
<STRUCT>
<NAME>GDtlsServerConnectionInterface</NAME>
struct _GDtlsServerConnectionInterface
{
  GTypeInterface g_iface;
};
</STRUCT>
<FUNCTION>
<NAME>g_dtls_server_connection_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_dtls_server_connection_new</NAME>
<RETURNS>GDatagramBased  *</RETURNS>
GDatagramBased   *base_socket, GTlsCertificate  *certificate, GError          **error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_EMBLEM</NAME>
#define G_TYPE_EMBLEM         (g_emblem_get_type ())
</MACRO>
<MACRO>
<NAME>G_EMBLEM</NAME>
#define G_EMBLEM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_EMBLEM, GEmblem))
</MACRO>
<MACRO>
<NAME>G_EMBLEM_CLASS</NAME>
#define G_EMBLEM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_EMBLEM, GEmblemClass))
</MACRO>
<MACRO>
<NAME>G_IS_EMBLEM</NAME>
#define G_IS_EMBLEM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_EMBLEM))
</MACRO>
<MACRO>
<NAME>G_IS_EMBLEM_CLASS</NAME>
#define G_IS_EMBLEM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_EMBLEM))
</MACRO>
<MACRO>
<NAME>G_EMBLEM_GET_CLASS</NAME>
#define G_EMBLEM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_EMBLEM, GEmblemClass))
</MACRO>
<FUNCTION>
<NAME>g_emblem_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_emblem_new</NAME>
<RETURNS>GEmblem        *</RETURNS>
GIcon         *icon
</FUNCTION>
<FUNCTION>
<NAME>g_emblem_new_with_origin</NAME>
<RETURNS>GEmblem        *</RETURNS>
GIcon         *icon, GEmblemOrigin  origin
</FUNCTION>
<FUNCTION>
<NAME>g_emblem_get_icon</NAME>
<RETURNS>GIcon          *</RETURNS>
GEmblem       *emblem
</FUNCTION>
<FUNCTION>
<NAME>g_emblem_get_origin</NAME>
<RETURNS>GEmblemOrigin   </RETURNS>
GEmblem       *emblem
</FUNCTION>
<STRUCT>
<NAME>GEmblem</NAME>
</STRUCT>
<STRUCT>
<NAME>GEmblemClass</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_EMBLEMED_ICON</NAME>
#define G_TYPE_EMBLEMED_ICON         (g_emblemed_icon_get_type ())
</MACRO>
<MACRO>
<NAME>G_EMBLEMED_ICON</NAME>
#define G_EMBLEMED_ICON(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_EMBLEMED_ICON, GEmblemedIcon))
</MACRO>
<MACRO>
<NAME>G_EMBLEMED_ICON_CLASS</NAME>
#define G_EMBLEMED_ICON_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_EMBLEMED_ICON, GEmblemedIconClass))
</MACRO>
<MACRO>
<NAME>G_IS_EMBLEMED_ICON</NAME>
#define G_IS_EMBLEMED_ICON(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_EMBLEMED_ICON))
</MACRO>
<MACRO>
<NAME>G_IS_EMBLEMED_ICON_CLASS</NAME>
#define G_IS_EMBLEMED_ICON_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_EMBLEMED_ICON))
</MACRO>
<MACRO>
<NAME>G_EMBLEMED_ICON_GET_CLASS</NAME>
#define G_EMBLEMED_ICON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_EMBLEMED_ICON, GEmblemedIconClass))
</MACRO>
<STRUCT>
<NAME>GEmblemedIcon</NAME>
struct _GEmblemedIcon
{
  GObject parent_instance;

  /*< private >*/
  GEmblemedIconPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GEmblemedIconClass</NAME>
struct _GEmblemedIconClass
{
  GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>g_emblemed_icon_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_emblemed_icon_new</NAME>
<RETURNS>GIcon  *</RETURNS>
GIcon         *icon, GEmblem       *emblem
</FUNCTION>
<FUNCTION>
<NAME>g_emblemed_icon_get_icon</NAME>
<RETURNS>GIcon  *</RETURNS>
GEmblemedIcon *emblemed
</FUNCTION>
<FUNCTION>
<NAME>g_emblemed_icon_get_emblems</NAME>
<RETURNS>GList  *</RETURNS>
GEmblemedIcon *emblemed
</FUNCTION>
<FUNCTION>
<NAME>g_emblemed_icon_add_emblem</NAME>
<RETURNS>void    </RETURNS>
GEmblemedIcon *emblemed, GEmblem       *emblem
</FUNCTION>
<FUNCTION>
<NAME>g_emblemed_icon_clear_emblems</NAME>
<RETURNS>void    </RETURNS>
GEmblemedIcon *emblemed
</FUNCTION>
<STRUCT>
<NAME>GEmblemedIconPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_FILE</NAME>
#define G_TYPE_FILE            (g_file_get_type ())
</MACRO>
<MACRO>
<NAME>G_FILE</NAME>
#define G_FILE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_FILE, GFile))
</MACRO>
<MACRO>
<NAME>G_IS_FILE</NAME>
#define G_IS_FILE(obj)	       (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_FILE))
</MACRO>
<MACRO>
<NAME>G_FILE_GET_IFACE</NAME>
#define G_FILE_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_FILE, GFileIface))
</MACRO>
<STRUCT>
<NAME>GFileIface</NAME>
struct _GFileIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  GFile *             (* dup)                         (GFile         *file);
  guint               (* hash)                        (GFile         *file);
  gboolean            (* equal)                       (GFile         *file1,
                                                       GFile         *file2);
  gboolean            (* is_native)                   (GFile         *file);
  gboolean            (* has_uri_scheme)              (GFile         *file,
                                                       const char    *uri_scheme);
  char *              (* get_uri_scheme)              (GFile         *file);
  char *              (* get_basename)                (GFile         *file);
  char *              (* get_path)                    (GFile         *file);
  char *              (* get_uri)                     (GFile         *file);
  char *              (* get_parse_name)              (GFile         *file);
  GFile *             (* get_parent)                  (GFile         *file);
  gboolean            (* prefix_matches)              (GFile         *prefix,
                                                       GFile         *file);
  char *              (* get_relative_path)           (GFile         *parent,
                                                       GFile         *descendant);
  GFile *             (* resolve_relative_path)       (GFile        *file,
                                                       const char   *relative_path);
  GFile *             (* get_child_for_display_name)  (GFile        *file,
                                                       const char   *display_name,
                                                       GError      **error);

  GFileEnumerator *   (* enumerate_children)          (GFile                *file,
                                                       const char           *attributes,
                                                       GFileQueryInfoFlags   flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* enumerate_children_async)    (GFile                *file,
                                                       const char           *attributes,
                                                       GFileQueryInfoFlags   flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileEnumerator *   (* enumerate_children_finish)   (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  GFileInfo *         (* query_info)                  (GFile                *file,
                                                       const char           *attributes,
                                                       GFileQueryInfoFlags   flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* query_info_async)            (GFile                *file,
                                                       const char           *attributes,
                                                       GFileQueryInfoFlags   flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileInfo *         (* query_info_finish)           (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  GFileInfo *         (* query_filesystem_info)       (GFile                *file,
                                                       const char           *attributes,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* query_filesystem_info_async) (GFile                *file,
                                                       const char           *attributes,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileInfo *         (* query_filesystem_info_finish)(GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  GMount *            (* find_enclosing_mount)        (GFile                *file,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* find_enclosing_mount_async)  (GFile                *file,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GMount *            (* find_enclosing_mount_finish) (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  GFile *             (* set_display_name)            (GFile                *file,
                                                       const char           *display_name,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* set_display_name_async)      (GFile                *file,
                                                       const char           *display_name,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFile *             (* set_display_name_finish)     (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  GFileAttributeInfoList * (* query_settable_attributes)    (GFile          *file,
                                                             GCancellable   *cancellable,
                                                             GError        **error);
  void                (* _query_settable_attributes_async)  (void);
  void                (* _query_settable_attributes_finish) (void);

  GFileAttributeInfoList * (* query_writable_namespaces)    (GFile          *file,
                                                             GCancellable   *cancellable,
                                                             GError        **error);
  void                (* _query_writable_namespaces_async)  (void);
  void                (* _query_writable_namespaces_finish) (void);

  gboolean            (* set_attribute)               (GFile                *file,
                                                       const char           *attribute,
                                                       GFileAttributeType    type,
                                                       gpointer              value_p,
                                                       GFileQueryInfoFlags   flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  gboolean            (* set_attributes_from_info)    (GFile                *file,
                                                       GFileInfo            *info,
                                                       GFileQueryInfoFlags   flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* set_attributes_async)        (GFile                *file,
                                                       GFileInfo            *info,
                                                       GFileQueryInfoFlags   flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* set_attributes_finish)       (GFile                *file,
                                                       GAsyncResult         *result,
                                                       GFileInfo           **info,
                                                       GError              **error);

  GFileInputStream *  (* read_fn)                     (GFile                *file,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* read_async)                  (GFile                *file,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileInputStream *  (* read_finish)                 (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  GFileOutputStream * (* append_to)                   (GFile                *file,
                                                       GFileCreateFlags      flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* append_to_async)             (GFile                *file,
                                                       GFileCreateFlags      flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileOutputStream * (* append_to_finish)            (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  GFileOutputStream * (* create)                      (GFile                *file,
                                                       GFileCreateFlags      flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* create_async)                (GFile                *file,
                                                       GFileCreateFlags      flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileOutputStream * (* create_finish)               (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  GFileOutputStream * (* replace)                     (GFile                *file,
                                                       const char           *etag,
                                                       gboolean              make_backup,
                                                       GFileCreateFlags      flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* replace_async)               (GFile                *file,
                                                       const char           *etag,
                                                       gboolean              make_backup,
                                                       GFileCreateFlags      flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileOutputStream * (* replace_finish)              (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  gboolean            (* delete_file)                 (GFile                *file,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* delete_file_async)           (GFile                *file,
						       int                   io_priority,
						       GCancellable         *cancellable,
						       GAsyncReadyCallback   callback,
						       gpointer              user_data);
  gboolean            (* delete_file_finish)          (GFile                *file,
						       GAsyncResult         *result,
						       GError              **error);

  gboolean            (* trash)                       (GFile                *file,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* trash_async)                 (GFile                *file,
						       int                   io_priority,
						       GCancellable         *cancellable,
						       GAsyncReadyCallback   callback,
						       gpointer              user_data);
  gboolean            (* trash_finish)                (GFile                *file,
						       GAsyncResult         *result,
						       GError              **error);

  gboolean            (* make_directory)              (GFile                *file,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* make_directory_async)        (GFile                *file,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* make_directory_finish)       (GFile                *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  gboolean            (* make_symbolic_link)          (GFile                *file,
                                                       const char           *symlink_value,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* _make_symbolic_link_async)   (void);
  void                (* _make_symbolic_link_finish)  (void);

  gboolean            (* copy)                        (GFile                *source,
                                                       GFile                *destination,
                                                       GFileCopyFlags        flags,
                                                       GCancellable         *cancellable,
                                                       GFileProgressCallback progress_callback,
                                                       gpointer              progress_callback_data,
                                                       GError              **error);
  void                (* copy_async)                  (GFile                *source,
                                                       GFile                *destination,
                                                       GFileCopyFlags        flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GFileProgressCallback progress_callback,
                                                       gpointer              progress_callback_data,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* copy_finish)                 (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  gboolean            (* move)                        (GFile                *source,
                                                       GFile                *destination,
                                                       GFileCopyFlags        flags,
                                                       GCancellable         *cancellable,
                                                       GFileProgressCallback progress_callback,
                                                       gpointer              progress_callback_data,
                                                       GError              **error);
  void                (* _move_async)                 (void);
  void                (* _move_finish)                (void);

  void                (* mount_mountable)             (GFile                *file,
                                                       GMountMountFlags      flags,
                                                       GMountOperation      *mount_operation,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFile *             (* mount_mountable_finish)      (GFile                *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  void                (* unmount_mountable)           (GFile                *file,
                                                       GMountUnmountFlags    flags,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* unmount_mountable_finish)    (GFile                *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  void                (* eject_mountable)             (GFile                *file,
                                                       GMountUnmountFlags    flags,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* eject_mountable_finish)      (GFile                *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  void                (* mount_enclosing_volume)      (GFile                *location,
                                                       GMountMountFlags      flags,
                                                       GMountOperation      *mount_operation,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean         (* mount_enclosing_volume_finish)  (GFile                *location,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  GFileMonitor *      (* monitor_dir)                 (GFile                *file,
                                                       GFileMonitorFlags     flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  GFileMonitor *      (* monitor_file)                (GFile                *file,
                                                       GFileMonitorFlags     flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);

  GFileIOStream *     (* open_readwrite)              (GFile                *file,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* open_readwrite_async)        (GFile                *file,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileIOStream *     (* open_readwrite_finish)       (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);
  GFileIOStream *     (* create_readwrite)            (GFile                *file,
						       GFileCreateFlags      flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* create_readwrite_async)      (GFile                *file,
						       GFileCreateFlags      flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileIOStream *     (* create_readwrite_finish)      (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);
  GFileIOStream *     (* replace_readwrite)           (GFile                *file,
                                                       const char           *etag,
                                                       gboolean              make_backup,
                                                       GFileCreateFlags      flags,
                                                       GCancellable         *cancellable,
                                                       GError              **error);
  void                (* replace_readwrite_async)     (GFile                *file,
                                                       const char           *etag,
                                                       gboolean              make_backup,
                                                       GFileCreateFlags      flags,
                                                       int                   io_priority,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  GFileIOStream *     (* replace_readwrite_finish)    (GFile                *file,
                                                       GAsyncResult         *res,
                                                       GError              **error);

  void                (* start_mountable)             (GFile                *file,
                                                       GDriveStartFlags      flags,
                                                       GMountOperation      *start_operation,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* start_mountable_finish)      (GFile                *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  void                (* stop_mountable)              (GFile                *file,
                                                       GMountUnmountFlags    flags,
                                                       GMountOperation      *mount_operation,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* stop_mountable_finish)       (GFile                *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  gboolean            supports_thread_contexts;

  void                (* unmount_mountable_with_operation) (GFile           *file,
                                                       GMountUnmountFlags    flags,
                                                       GMountOperation      *mount_operation,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* unmount_mountable_with_operation_finish) (GFile    *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  void                (* eject_mountable_with_operation) (GFile             *file,
                                                       GMountUnmountFlags    flags,
                                                       GMountOperation      *mount_operation,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* eject_mountable_with_operation_finish) (GFile      *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  void                (* poll_mountable)              (GFile                *file,
                                                       GCancellable         *cancellable,
                                                       GAsyncReadyCallback   callback,
                                                       gpointer              user_data);
  gboolean            (* poll_mountable_finish)       (GFile                *file,
                                                       GAsyncResult         *result,
                                                       GError              **error);

  gboolean            (* measure_disk_usage)          (GFile                         *file,
                                                       GFileMeasureFlags              flags,
                                                       GCancellable                  *cancellable,
                                                       GFileMeasureProgressCallback   progress_callback,
                                                       gpointer                       progress_data,
                                                       guint64                       *disk_usage,
                                                       guint64                       *num_dirs,
                                                       guint64                       *num_files,
                                                       GError                       **error);
  void                (* measure_disk_usage_async)    (GFile                         *file,
                                                       GFileMeasureFlags              flags,
                                                       gint                           io_priority,
                                                       GCancellable                  *cancellable,
                                                       GFileMeasureProgressCallback   progress_callback,
                                                       gpointer                       progress_data,
                                                       GAsyncReadyCallback            callback,
                                                       gpointer                       user_data);
  gboolean            (* measure_disk_usage_finish)   (GFile                         *file,
                                                       GAsyncResult                  *result,
                                                       guint64                       *disk_usage,
                                                       guint64                       *num_dirs,
                                                       guint64                       *num_files,
                                                       GError                       **error);
};
</STRUCT>
<FUNCTION>
<NAME>g_file_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_file_new_for_path</NAME>
<RETURNS>GFile  *                 </RETURNS>
const char                 *path
</FUNCTION>
<FUNCTION>
<NAME>g_file_new_for_uri</NAME>
<RETURNS>GFile  *                 </RETURNS>
const char                 *uri
</FUNCTION>
<FUNCTION>
<NAME>g_file_new_for_commandline_arg</NAME>
<RETURNS>GFile  *                 </RETURNS>
const char                 *arg
</FUNCTION>
<FUNCTION>
<NAME>g_file_new_for_commandline_arg_and_cwd</NAME>
<RETURNS>GFile  *                 </RETURNS>
const gchar           *arg, const gchar           *cwd
</FUNCTION>
<FUNCTION>
<NAME>g_file_new_tmp</NAME>
<RETURNS>GFile  *                 </RETURNS>
const char                 *tmpl, GFileIOStream             **iostream, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_parse_name</NAME>
<RETURNS>GFile  *                 </RETURNS>
const char                 *parse_name
</FUNCTION>
<FUNCTION>
<NAME>g_file_new_build_filename</NAME>
<RETURNS>GFile  *                 </RETURNS>
const gchar                *first_element, ...
</FUNCTION>
<FUNCTION>
<NAME>g_file_dup</NAME>
<RETURNS>GFile  *                 </RETURNS>
GFile                      *file
</FUNCTION>
<FUNCTION>
<NAME>g_file_hash</NAME>
<RETURNS>guint                    </RETURNS>
gconstpointer               file
</FUNCTION>
<FUNCTION>
<NAME>g_file_equal</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file1, GFile                      *file2
</FUNCTION>
<FUNCTION>
<NAME>g_file_get_basename</NAME>
<RETURNS>char  *                  </RETURNS>
GFile                      *file
</FUNCTION>
<FUNCTION>
<NAME>g_file_get_path</NAME>
<RETURNS>char  *                  </RETURNS>
GFile                      *file
</FUNCTION>
<FUNCTION>
<NAME>g_file_peek_path</NAME>
<RETURNS>const char  *            </RETURNS>
GFile                      *file
</FUNCTION>
<FUNCTION>
<NAME>g_file_get_uri</NAME>
<RETURNS>char  *                  </RETURNS>
GFile                      *file
</FUNCTION>
<FUNCTION>
<NAME>g_file_get_parse_name</NAME>
<RETURNS>char  *                  </RETURNS>
GFile                      *file
</FUNCTION>
<FUNCTION>
<NAME>g_file_get_parent</NAME>
<RETURNS>GFile  *                 </RETURNS>
GFile                      *file
</FUNCTION>
<FUNCTION>
<NAME>g_file_has_parent</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GFile                      *parent
</FUNCTION>
<FUNCTION>
<NAME>g_file_get_child</NAME>
<RETURNS>GFile  *                 </RETURNS>
GFile                      *file, const char                 *name
</FUNCTION>
<FUNCTION>
<NAME>g_file_get_child_for_display_name</NAME>
<RETURNS>GFile  *                 </RETURNS>
GFile                      *file, const char                 *display_name, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_has_prefix</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GFile                      *prefix
</FUNCTION>
<FUNCTION>
<NAME>g_file_get_relative_path</NAME>
<RETURNS>char  *                  </RETURNS>
GFile                      *parent, GFile                      *descendant
</FUNCTION>
<FUNCTION>
<NAME>g_file_resolve_relative_path</NAME>
<RETURNS>GFile  *                 </RETURNS>
GFile                      *file, const char                 *relative_path
</FUNCTION>
<FUNCTION>
<NAME>g_file_is_native</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file
</FUNCTION>
<FUNCTION>
<NAME>g_file_has_uri_scheme</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, const char                 *uri_scheme
</FUNCTION>
<FUNCTION>
<NAME>g_file_get_uri_scheme</NAME>
<RETURNS>char  *                  </RETURNS>
GFile                      *file
</FUNCTION>
<FUNCTION>
<NAME>g_file_read</NAME>
<RETURNS>GFileInputStream  *      </RETURNS>
GFile                      *file, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_read_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_read_finish</NAME>
<RETURNS>GFileInputStream  *      </RETURNS>
GFile                      *file, GAsyncResult               *res, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_append_to</NAME>
<RETURNS>GFileOutputStream  *     </RETURNS>
GFile                      *file, GFileCreateFlags             flags, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_create</NAME>
<RETURNS>GFileOutputStream  *     </RETURNS>
GFile                      *file, GFileCreateFlags             flags, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_replace</NAME>
<RETURNS>GFileOutputStream  *     </RETURNS>
GFile                      *file, const char                 *etag, gboolean                    make_backup, GFileCreateFlags            flags, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_append_to_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, GFileCreateFlags            flags, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_append_to_finish</NAME>
<RETURNS>GFileOutputStream  *     </RETURNS>
GFile                      *file, GAsyncResult               *res, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_create_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, GFileCreateFlags            flags, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_create_finish</NAME>
<RETURNS>GFileOutputStream  *     </RETURNS>
GFile                      *file, GAsyncResult               *res, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_replace_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, const char                 *etag, gboolean                    make_backup, GFileCreateFlags            flags, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_replace_finish</NAME>
<RETURNS>GFileOutputStream  *     </RETURNS>
GFile                      *file, GAsyncResult               *res, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_open_readwrite</NAME>
<RETURNS>GFileIOStream  *         </RETURNS>
GFile                      *file, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_open_readwrite_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_open_readwrite_finish</NAME>
<RETURNS>GFileIOStream  *         </RETURNS>
GFile                      *file, GAsyncResult               *res, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_create_readwrite</NAME>
<RETURNS>GFileIOStream  *         </RETURNS>
GFile                      *file, GFileCreateFlags            flags, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_create_readwrite_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, GFileCreateFlags            flags, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_create_readwrite_finish</NAME>
<RETURNS>GFileIOStream  *         </RETURNS>
GFile                      *file, GAsyncResult               *res, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_replace_readwrite</NAME>
<RETURNS>GFileIOStream  *         </RETURNS>
GFile                      *file, const char                 *etag, gboolean                    make_backup, GFileCreateFlags            flags, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_replace_readwrite_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, const char                 *etag, gboolean                    make_backup, GFileCreateFlags            flags, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_replace_readwrite_finish</NAME>
<RETURNS>GFileIOStream  *         </RETURNS>
GFile                      *file, GAsyncResult               *res, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_query_exists</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GCancellable               *cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_file_query_file_type</NAME>
<RETURNS>GFileType                </RETURNS>
GFile                      *file, GFileQueryInfoFlags         flags, GCancellable               *cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_file_query_info</NAME>
<RETURNS>GFileInfo  *             </RETURNS>
GFile                      *file, const char                 *attributes, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_query_info_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, const char                 *attributes, GFileQueryInfoFlags         flags, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_query_info_finish</NAME>
<RETURNS>GFileInfo  *             </RETURNS>
GFile                      *file, GAsyncResult               *res, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_query_filesystem_info</NAME>
<RETURNS>GFileInfo  *             </RETURNS>
GFile                      *file, const char                 *attributes, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_query_filesystem_info_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, const char                 *attributes, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_query_filesystem_info_finish</NAME>
<RETURNS>GFileInfo  *             </RETURNS>
GFile                      *file, GAsyncResult               *res, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_find_enclosing_mount</NAME>
<RETURNS>GMount  *                </RETURNS>
GFile                      *file, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_find_enclosing_mount_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_find_enclosing_mount_finish</NAME>
<RETURNS>GMount  *                </RETURNS>
GFile                     *file, GAsyncResult              *res, GError                   **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_enumerate_children</NAME>
<RETURNS>GFileEnumerator  *       </RETURNS>
GFile                      *file, const char                 *attributes, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_enumerate_children_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, const char                 *attributes, GFileQueryInfoFlags         flags, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_enumerate_children_finish</NAME>
<RETURNS>GFileEnumerator  *       </RETURNS>
GFile                      *file, GAsyncResult               *res, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_set_display_name</NAME>
<RETURNS>GFile  *                 </RETURNS>
GFile                      *file, const char                 *display_name, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_set_display_name_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, const char                 *display_name, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_set_display_name_finish</NAME>
<RETURNS>GFile  *                 </RETURNS>
GFile                      *file, GAsyncResult               *res, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_delete</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_delete_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_delete_finish</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GAsyncResult               *result, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_trash</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_trash_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_trash_finish</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GAsyncResult               *result, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_copy</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *source, GFile                      *destination, GFileCopyFlags              flags, GCancellable               *cancellable, GFileProgressCallback       progress_callback, gpointer                    progress_callback_data, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_copy_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *source, GFile                      *destination, GFileCopyFlags              flags, int                         io_priority, GCancellable               *cancellable, GFileProgressCallback       progress_callback, gpointer                    progress_callback_data, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_copy_finish</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GAsyncResult               *res, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_move</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *source, GFile                      *destination, GFileCopyFlags              flags, GCancellable               *cancellable, GFileProgressCallback       progress_callback, gpointer                    progress_callback_data, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_make_directory</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_make_directory_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_make_directory_finish</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GAsyncResult               *result, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_make_directory_with_parents</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                     *file, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_make_symbolic_link</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, const char                 *symlink_value, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_query_settable_attributes</NAME>
<RETURNS>GFileAttributeInfoList  *</RETURNS>
GFile                      *file, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_query_writable_namespaces</NAME>
<RETURNS>GFileAttributeInfoList  *</RETURNS>
GFile                      *file, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_set_attribute</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, const char                 *attribute, GFileAttributeType          type, gpointer                    value_p, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_set_attributes_from_info</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GFileInfo                  *info, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_set_attributes_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, GFileInfo                  *info, GFileQueryInfoFlags         flags, int                         io_priority, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_set_attributes_finish</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GAsyncResult               *result, GFileInfo                 **info, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_set_attribute_string</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, const char                 *attribute, const char                 *value, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_set_attribute_byte_string</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, const char                 *attribute, const char                 *value, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_set_attribute_uint32</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, const char                 *attribute, guint32                     value, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_set_attribute_int32</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, const char                 *attribute, gint32                      value, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_set_attribute_uint64</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, const char                 *attribute, guint64                     value, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_set_attribute_int64</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, const char                 *attribute, gint64                      value, GFileQueryInfoFlags         flags, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_mount_enclosing_volume</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *location, GMountMountFlags            flags, GMountOperation            *mount_operation, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_mount_enclosing_volume_finish</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *location, GAsyncResult               *result, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_mount_mountable</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, GMountMountFlags            flags, GMountOperation            *mount_operation, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_mount_mountable_finish</NAME>
<RETURNS>GFile  *                 </RETURNS>
GFile                      *file, GAsyncResult               *result, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_unmount_mountable</NAME>
<DEPRECATED/>
<RETURNS>void                     </RETURNS>
GFile                      *file, GMountUnmountFlags          flags, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_unmount_mountable_finish</NAME>
<DEPRECATED/>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GAsyncResult               *result, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_unmount_mountable_with_operation</NAME>
<RETURNS>void                     </RETURNS>
GFile                *file, GMountUnmountFlags          flags, GMountOperation            *mount_operation, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_unmount_mountable_with_operation_finish</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile         *file, GAsyncResult               *result, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_eject_mountable</NAME>
<DEPRECATED/>
<RETURNS>void                     </RETURNS>
GFile                      *file, GMountUnmountFlags          flags, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_eject_mountable_finish</NAME>
<DEPRECATED/>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GAsyncResult               *result, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_eject_mountable_with_operation</NAME>
<RETURNS>void                     </RETURNS>
GFile                  *file, GMountUnmountFlags          flags, GMountOperation            *mount_operation, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_eject_mountable_with_operation_finish</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile           *file, GAsyncResult               *result, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_copy_attributes</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *source, GFile                      *destination, GFileCopyFlags              flags, GCancellable               *cancellable, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_monitor_directory</NAME>
<RETURNS>GFileMonitor *           </RETURNS>
GFile                  *file, GFileMonitorFlags       flags, GCancellable           *cancellable, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_monitor_file</NAME>
<RETURNS>GFileMonitor *           </RETURNS>
GFile                  *file, GFileMonitorFlags       flags, GCancellable           *cancellable, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_monitor</NAME>
<RETURNS>GFileMonitor *           </RETURNS>
GFile                  *file, GFileMonitorFlags       flags, GCancellable           *cancellable, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_measure_disk_usage</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                         *file, GFileMeasureFlags              flags, GCancellable                  *cancellable, GFileMeasureProgressCallback   progress_callback, gpointer                       progress_data, guint64                       *disk_usage, guint64                       *num_dirs, guint64                       *num_files, GError                       **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_measure_disk_usage_async</NAME>
<RETURNS>void                     </RETURNS>
GFile                         *file, GFileMeasureFlags              flags, gint                           io_priority, GCancellable                  *cancellable, GFileMeasureProgressCallback   progress_callback, gpointer                       progress_data, GAsyncReadyCallback            callback, gpointer                       user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_measure_disk_usage_finish</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                         *file, GAsyncResult                  *result, guint64                       *disk_usage, guint64                       *num_dirs, guint64                       *num_files, GError                       **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_start_mountable</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, GDriveStartFlags            flags, GMountOperation            *start_operation, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_start_mountable_finish</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GAsyncResult               *result, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_stop_mountable</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, GMountUnmountFlags          flags, GMountOperation            *mount_operation, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_stop_mountable_finish</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GAsyncResult               *result, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_poll_mountable</NAME>
<RETURNS>void                     </RETURNS>
GFile                      *file, GCancellable               *cancellable, GAsyncReadyCallback         callback, gpointer                    user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_poll_mountable_finish</NAME>
<RETURNS>gboolean                 </RETURNS>
GFile                      *file, GAsyncResult               *result, GError                    **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_query_default_handler</NAME>
<RETURNS>GAppInfo  *</RETURNS>
GFile                  *file, GCancellable           *cancellable, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_load_contents</NAME>
<RETURNS>gboolean  </RETURNS>
GFile                  *file, GCancellable           *cancellable, char                  **contents, gsize                  *length, char                  **etag_out, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_load_contents_async</NAME>
<RETURNS>void      </RETURNS>
GFile                  *file, GCancellable           *cancellable, GAsyncReadyCallback     callback, gpointer                user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_load_contents_finish</NAME>
<RETURNS>gboolean  </RETURNS>
GFile                  *file, GAsyncResult           *res, char                  **contents, gsize                  *length, char                  **etag_out, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_load_partial_contents_async</NAME>
<RETURNS>void      </RETURNS>
GFile                  *file, GCancellable           *cancellable, GFileReadMoreCallback   read_more_callback, GAsyncReadyCallback     callback, gpointer                user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_load_partial_contents_finish</NAME>
<RETURNS>gboolean  </RETURNS>
GFile                  *file, GAsyncResult           *res, char                  **contents, gsize                  *length, char                  **etag_out, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_replace_contents</NAME>
<RETURNS>gboolean  </RETURNS>
GFile                  *file, const char             *contents, gsize                   length, const char             *etag, gboolean                make_backup, GFileCreateFlags        flags, char                  **new_etag, GCancellable           *cancellable, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_replace_contents_async</NAME>
<RETURNS>void      </RETURNS>
GFile                  *file, const char             *contents, gsize                   length, const char             *etag, gboolean                make_backup, GFileCreateFlags        flags, GCancellable           *cancellable, GAsyncReadyCallback     callback, gpointer                user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_replace_contents_bytes_async</NAME>
<RETURNS>void      </RETURNS>
GFile                  *file, GBytes                 *contents, const char             *etag, gboolean                make_backup, GFileCreateFlags        flags, GCancellable           *cancellable, GAsyncReadyCallback     callback, gpointer                user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_replace_contents_finish</NAME>
<RETURNS>gboolean  </RETURNS>
GFile                  *file, GAsyncResult           *res, char                  **new_etag, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_supports_thread_contexts</NAME>
<RETURNS>gboolean  </RETURNS>
GFile                  *file
</FUNCTION>
<FUNCTION>
<NAME>g_file_load_bytes</NAME>
<RETURNS>GBytes   *</RETURNS>
GFile                  *file, GCancellable           *cancellable, gchar                 **etag_out, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_load_bytes_async</NAME>
<RETURNS>void      </RETURNS>
GFile                  *file, GCancellable           *cancellable, GAsyncReadyCallback     callback, gpointer                user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_load_bytes_finish</NAME>
<RETURNS>GBytes   *</RETURNS>
GFile                  *file, GAsyncResult           *result, gchar                 **etag_out, GError                **error
</FUNCTION>
<STRUCT>
<NAME>GFile</NAME>
</STRUCT>
<STRUCT>
<NAME>GFileAttributeInfo</NAME>
struct _GFileAttributeInfo
{
  char                    *name;
  GFileAttributeType       type;
  GFileAttributeInfoFlags  flags;
};
</STRUCT>
<STRUCT>
<NAME>GFileAttributeInfoList</NAME>
struct _GFileAttributeInfoList
{
  GFileAttributeInfo *infos;
  int                 n_infos;
};
</STRUCT>
<MACRO>
<NAME>G_TYPE_FILE_ATTRIBUTE_INFO_LIST</NAME>
#define G_TYPE_FILE_ATTRIBUTE_INFO_LIST (g_file_attribute_info_list_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_file_attribute_info_list_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_file_attribute_info_list_new</NAME>
<RETURNS>GFileAttributeInfoList  *  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_file_attribute_info_list_ref</NAME>
<RETURNS>GFileAttributeInfoList  *  </RETURNS>
GFileAttributeInfoList *list
</FUNCTION>
<FUNCTION>
<NAME>g_file_attribute_info_list_unref</NAME>
<RETURNS>void                       </RETURNS>
GFileAttributeInfoList *list
</FUNCTION>
<FUNCTION>
<NAME>g_file_attribute_info_list_dup</NAME>
<RETURNS>GFileAttributeInfoList  *  </RETURNS>
GFileAttributeInfoList *list
</FUNCTION>
<FUNCTION>
<NAME>g_file_attribute_info_list_lookup</NAME>
<RETURNS>const GFileAttributeInfo  *</RETURNS>
GFileAttributeInfoList *list, const char             *name
</FUNCTION>
<FUNCTION>
<NAME>g_file_attribute_info_list_add</NAME>
<RETURNS>void                       </RETURNS>
GFileAttributeInfoList *list, const char             *name, GFileAttributeType      type, GFileAttributeInfoFlags flags
</FUNCTION>
<MACRO>
<NAME>G_TYPE_FILE_DESCRIPTOR_BASED</NAME>
#define G_TYPE_FILE_DESCRIPTOR_BASED            (g_file_descriptor_based_get_type ())
</MACRO>
<MACRO>
<NAME>G_FILE_DESCRIPTOR_BASED</NAME>
#define G_FILE_DESCRIPTOR_BASED(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_FILE_DESCRIPTOR_BASED, GFileDescriptorBased))
</MACRO>
<MACRO>
<NAME>G_IS_FILE_DESCRIPTOR_BASED</NAME>
#define G_IS_FILE_DESCRIPTOR_BASED(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_FILE_DESCRIPTOR_BASED))
</MACRO>
<MACRO>
<NAME>G_FILE_DESCRIPTOR_BASED_GET_IFACE</NAME>
#define G_FILE_DESCRIPTOR_BASED_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_FILE_DESCRIPTOR_BASED, GFileDescriptorBasedIface))
</MACRO>
<STRUCT>
<NAME>GFileDescriptorBasedIface</NAME>
struct _GFileDescriptorBasedIface
{
  GTypeInterface g_iface;

  /* Virtual Table */
  int (*get_fd) (GFileDescriptorBased *fd_based);
};
</STRUCT>
<FUNCTION>
<NAME>g_file_descriptor_based_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_file_descriptor_based_get_fd</NAME>
<RETURNS>int       </RETURNS>
GFileDescriptorBased *fd_based
</FUNCTION>
<MACRO>
<NAME>G_TYPE_FILE_ENUMERATOR</NAME>
#define G_TYPE_FILE_ENUMERATOR         (g_file_enumerator_get_type ())
</MACRO>
<MACRO>
<NAME>G_FILE_ENUMERATOR</NAME>
#define G_FILE_ENUMERATOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_ENUMERATOR, GFileEnumerator))
</MACRO>
<MACRO>
<NAME>G_FILE_ENUMERATOR_CLASS</NAME>
#define G_FILE_ENUMERATOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_ENUMERATOR, GFileEnumeratorClass))
</MACRO>
<MACRO>
<NAME>G_IS_FILE_ENUMERATOR</NAME>
#define G_IS_FILE_ENUMERATOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_ENUMERATOR))
</MACRO>
<MACRO>
<NAME>G_IS_FILE_ENUMERATOR_CLASS</NAME>
#define G_IS_FILE_ENUMERATOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_ENUMERATOR))
</MACRO>
<MACRO>
<NAME>G_FILE_ENUMERATOR_GET_CLASS</NAME>
#define G_FILE_ENUMERATOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_ENUMERATOR, GFileEnumeratorClass))
</MACRO>
<STRUCT>
<NAME>GFileEnumerator</NAME>
struct _GFileEnumerator
{
  GObject parent_instance;

  /*< private >*/
  GFileEnumeratorPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GFileEnumeratorClass</NAME>
struct _GFileEnumeratorClass
{
  GObjectClass parent_class;

  /* Virtual Table */

  GFileInfo * (* next_file)         (GFileEnumerator      *enumerator,
                                     GCancellable         *cancellable,
                                     GError              **error);
  gboolean    (* close_fn)          (GFileEnumerator      *enumerator,
                                     GCancellable         *cancellable,
                                     GError              **error);

  void        (* next_files_async)  (GFileEnumerator      *enumerator,
                                     int                   num_files,
                                     int                   io_priority,
                                     GCancellable         *cancellable,
                                     GAsyncReadyCallback   callback,
                                     gpointer              user_data);
  GList *     (* next_files_finish) (GFileEnumerator      *enumerator,
                                     GAsyncResult         *result,
                                     GError              **error);
  void        (* close_async)       (GFileEnumerator      *enumerator,
                                     int                   io_priority,
                                     GCancellable         *cancellable,
                                     GAsyncReadyCallback   callback,
                                     gpointer              user_data);
  gboolean    (* close_finish)      (GFileEnumerator      *enumerator,
                                     GAsyncResult         *result,
                                     GError              **error);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
  void (*_g_reserved7) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_file_enumerator_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_file_enumerator_next_file</NAME>
<RETURNS>GFileInfo  *</RETURNS>
GFileEnumerator      *enumerator, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_enumerator_close</NAME>
<RETURNS>gboolean    </RETURNS>
GFileEnumerator      *enumerator, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_enumerator_next_files_async</NAME>
<RETURNS>void        </RETURNS>
GFileEnumerator      *enumerator, int                   num_files, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_enumerator_next_files_finish</NAME>
<RETURNS>GList  *    </RETURNS>
GFileEnumerator      *enumerator, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_enumerator_close_async</NAME>
<RETURNS>void        </RETURNS>
GFileEnumerator      *enumerator, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_enumerator_close_finish</NAME>
<RETURNS>gboolean    </RETURNS>
GFileEnumerator      *enumerator, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_enumerator_is_closed</NAME>
<RETURNS>gboolean    </RETURNS>
GFileEnumerator      *enumerator
</FUNCTION>
<FUNCTION>
<NAME>g_file_enumerator_has_pending</NAME>
<RETURNS>gboolean    </RETURNS>
GFileEnumerator      *enumerator
</FUNCTION>
<FUNCTION>
<NAME>g_file_enumerator_set_pending</NAME>
<RETURNS>void        </RETURNS>
GFileEnumerator      *enumerator, gboolean              pending
</FUNCTION>
<FUNCTION>
<NAME>g_file_enumerator_get_container</NAME>
<RETURNS>GFile  *    </RETURNS>
GFileEnumerator *enumerator
</FUNCTION>
<FUNCTION>
<NAME>g_file_enumerator_get_child</NAME>
<RETURNS>GFile  *    </RETURNS>
GFileEnumerator *enumerator, GFileInfo       *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_enumerator_iterate</NAME>
<RETURNS>gboolean    </RETURNS>
GFileEnumerator  *direnum, GFileInfo       **out_info, GFile           **out_child, GCancellable     *cancellable, GError          **error
</FUNCTION>
<STRUCT>
<NAME>GFileEnumeratorPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_FILE_ICON</NAME>
#define G_TYPE_FILE_ICON         (g_file_icon_get_type ())
</MACRO>
<MACRO>
<NAME>G_FILE_ICON</NAME>
#define G_FILE_ICON(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_ICON, GFileIcon))
</MACRO>
<MACRO>
<NAME>G_FILE_ICON_CLASS</NAME>
#define G_FILE_ICON_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_ICON, GFileIconClass))
</MACRO>
<MACRO>
<NAME>G_IS_FILE_ICON</NAME>
#define G_IS_FILE_ICON(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_ICON))
</MACRO>
<MACRO>
<NAME>G_IS_FILE_ICON_CLASS</NAME>
#define G_IS_FILE_ICON_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_ICON))
</MACRO>
<MACRO>
<NAME>G_FILE_ICON_GET_CLASS</NAME>
#define G_FILE_ICON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_ICON, GFileIconClass))
</MACRO>
<FUNCTION>
<NAME>g_file_icon_get_type</NAME>
<RETURNS>GType    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_file_icon_new</NAME>
<RETURNS>GIcon  * </RETURNS>
GFile     *file
</FUNCTION>
<FUNCTION>
<NAME>g_file_icon_get_file</NAME>
<RETURNS>GFile  * </RETURNS>
GFileIcon *icon
</FUNCTION>
<STRUCT>
<NAME>GFileIconClass</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_FILE_INFO</NAME>
#define G_TYPE_FILE_INFO         (g_file_info_get_type ())
</MACRO>
<MACRO>
<NAME>G_FILE_INFO</NAME>
#define G_FILE_INFO(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_INFO, GFileInfo))
</MACRO>
<MACRO>
<NAME>G_FILE_INFO_CLASS</NAME>
#define G_FILE_INFO_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_INFO, GFileInfoClass))
</MACRO>
<MACRO>
<NAME>G_IS_FILE_INFO</NAME>
#define G_IS_FILE_INFO(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_INFO))
</MACRO>
<MACRO>
<NAME>G_IS_FILE_INFO_CLASS</NAME>
#define G_IS_FILE_INFO_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_INFO))
</MACRO>
<MACRO>
<NAME>G_FILE_INFO_GET_CLASS</NAME>
#define G_FILE_INFO_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_INFO, GFileInfoClass))
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_TYPE</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_TYPE "standard::type"                     /* uint32 (GFileType) */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN "standard::is-hidden"           /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP "standard::is-backup"           /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK "standard::is-symlink"         /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL "standard::is-virtual"         /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE "standard::is-volatile"      /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_NAME</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_NAME "standard::name"                     /* byte string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME "standard::display-name"     /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME "standard::edit-name"           /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_COPY_NAME</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_COPY_NAME "standard::copy-name"           /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION "standard::description"        /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_ICON</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_ICON "standard::icon"                     /* object (GIcon) */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON "standard::symbolic-icon"   /* object (GIcon) */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE "standard::content-type"     /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE "standard::fast-content-type" /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_SIZE</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_SIZE "standard::size"                     /* uint64 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE "standard::allocated-size" /* uint64 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET "standard::symlink-target" /* byte string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_TARGET_URI</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_TARGET_URI "standard::target-uri"         /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER</NAME>
#define G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER "standard::sort-order"         /* int32  */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_ETAG_VALUE</NAME>
#define G_FILE_ATTRIBUTE_ETAG_VALUE "etag::value"                 /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_ID_FILE</NAME>
#define G_FILE_ATTRIBUTE_ID_FILE "id::file"                     /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_ID_FILESYSTEM</NAME>
#define G_FILE_ATTRIBUTE_ID_FILESYSTEM "id::filesystem"         /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_ACCESS_CAN_READ</NAME>
#define G_FILE_ATTRIBUTE_ACCESS_CAN_READ "access::can-read"       /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE</NAME>
#define G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE "access::can-write"     /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE</NAME>
#define G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE "access::can-execute" /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE</NAME>
#define G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE "access::can-delete"   /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH</NAME>
#define G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH "access::can-trash"     /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME</NAME>
#define G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME "access::can-rename"   /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT</NAME>
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT "mountable::can-mount"     /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT</NAME>
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT "mountable::can-unmount" /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT</NAME>
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT "mountable::can-eject"     /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE</NAME>
#define G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE "mountable::unix-device" /* uint32 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE</NAME>
#define G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE "mountable::unix-device-file" /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI</NAME>
#define G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI "mountable::hal-udi"         /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START</NAME>
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START "mountable::can-start"     /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED</NAME>
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED "mountable::can-start-degraded"     /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP</NAME>
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP "mountable::can-stop"      /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE</NAME>
#define G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE "mountable::start-stop-type" /* uint32 (GDriveStartStopType) */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL</NAME>
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL "mountable::can-poll"      /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC</NAME>
#define G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC "mountable::is-media-check-automatic"      /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_TIME_MODIFIED</NAME>
#define G_FILE_ATTRIBUTE_TIME_MODIFIED "time::modified"           /* uint64 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC</NAME>
#define G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC "time::modified-usec" /* uint32 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_TIME_ACCESS</NAME>
#define G_FILE_ATTRIBUTE_TIME_ACCESS "time::access"               /* uint64 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_TIME_ACCESS_USEC</NAME>
#define G_FILE_ATTRIBUTE_TIME_ACCESS_USEC "time::access-usec"     /* uint32 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_TIME_CHANGED</NAME>
#define G_FILE_ATTRIBUTE_TIME_CHANGED "time::changed"             /* uint64 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_TIME_CHANGED_USEC</NAME>
#define G_FILE_ATTRIBUTE_TIME_CHANGED_USEC "time::changed-usec"   /* uint32 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_TIME_CREATED</NAME>
#define G_FILE_ATTRIBUTE_TIME_CREATED "time::created"             /* uint64 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_TIME_CREATED_USEC</NAME>
#define G_FILE_ATTRIBUTE_TIME_CREATED_USEC "time::created-usec"   /* uint32 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_UNIX_DEVICE</NAME>
#define G_FILE_ATTRIBUTE_UNIX_DEVICE "unix::device"               /* uint32 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_UNIX_INODE</NAME>
#define G_FILE_ATTRIBUTE_UNIX_INODE "unix::inode"                 /* uint64 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_UNIX_MODE</NAME>
#define G_FILE_ATTRIBUTE_UNIX_MODE "unix::mode"                   /* uint32 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_UNIX_NLINK</NAME>
#define G_FILE_ATTRIBUTE_UNIX_NLINK "unix::nlink"                 /* uint32 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_UNIX_UID</NAME>
#define G_FILE_ATTRIBUTE_UNIX_UID "unix::uid"                     /* uint32 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_UNIX_GID</NAME>
#define G_FILE_ATTRIBUTE_UNIX_GID "unix::gid"                     /* uint32 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_UNIX_RDEV</NAME>
#define G_FILE_ATTRIBUTE_UNIX_RDEV "unix::rdev"                   /* uint32 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE</NAME>
#define G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE "unix::block-size"       /* uint32 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_UNIX_BLOCKS</NAME>
#define G_FILE_ATTRIBUTE_UNIX_BLOCKS "unix::blocks"               /* uint64 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT</NAME>
#define G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT "unix::is-mountpoint" /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE</NAME>
#define G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE "dos::is-archive"         /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_DOS_IS_SYSTEM</NAME>
#define G_FILE_ATTRIBUTE_DOS_IS_SYSTEM "dos::is-system"           /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_OWNER_USER</NAME>
#define G_FILE_ATTRIBUTE_OWNER_USER "owner::user"                 /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_OWNER_USER_REAL</NAME>
#define G_FILE_ATTRIBUTE_OWNER_USER_REAL "owner::user-real"       /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_OWNER_GROUP</NAME>
#define G_FILE_ATTRIBUTE_OWNER_GROUP "owner::group"               /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_THUMBNAIL_PATH</NAME>
#define G_FILE_ATTRIBUTE_THUMBNAIL_PATH "thumbnail::path"         /* bytestring */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_THUMBNAILING_FAILED</NAME>
#define G_FILE_ATTRIBUTE_THUMBNAILING_FAILED "thumbnail::failed"         /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID</NAME>
#define G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID "thumbnail::is-valid"        /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_PREVIEW_ICON</NAME>
#define G_FILE_ATTRIBUTE_PREVIEW_ICON "preview::icon"         /* object (GIcon) */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_FILESYSTEM_SIZE</NAME>
#define G_FILE_ATTRIBUTE_FILESYSTEM_SIZE "filesystem::size"                       /* uint64 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_FILESYSTEM_FREE</NAME>
#define G_FILE_ATTRIBUTE_FILESYSTEM_FREE "filesystem::free"                       /* uint64 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_FILESYSTEM_USED</NAME>
#define G_FILE_ATTRIBUTE_FILESYSTEM_USED "filesystem::used"                       /* uint64 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_FILESYSTEM_TYPE</NAME>
#define G_FILE_ATTRIBUTE_FILESYSTEM_TYPE "filesystem::type"                       /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_FILESYSTEM_READONLY</NAME>
#define G_FILE_ATTRIBUTE_FILESYSTEM_READONLY "filesystem::readonly"               /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW</NAME>
#define G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW "filesystem::use-preview"        /* uint32 (GFilesystemPreviewType) */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_FILESYSTEM_REMOTE</NAME>
#define G_FILE_ATTRIBUTE_FILESYSTEM_REMOTE "filesystem::remote"                   /* boolean */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_GVFS_BACKEND</NAME>
#define G_FILE_ATTRIBUTE_GVFS_BACKEND "gvfs::backend"             /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_SELINUX_CONTEXT</NAME>
#define G_FILE_ATTRIBUTE_SELINUX_CONTEXT "selinux::context"       /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT</NAME>
#define G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT "trash::item-count"     /* uint32 */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_TRASH_ORIG_PATH</NAME>
#define G_FILE_ATTRIBUTE_TRASH_ORIG_PATH "trash::orig-path"     /* byte string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_TRASH_DELETION_DATE</NAME>
#define G_FILE_ATTRIBUTE_TRASH_DELETION_DATE "trash::deletion-date"  /* string */
</MACRO>
<MACRO>
<NAME>G_FILE_ATTRIBUTE_RECENT_MODIFIED</NAME>
#define G_FILE_ATTRIBUTE_RECENT_MODIFIED "recent::modified"          /* int64 (time_t) */
</MACRO>
<FUNCTION>
<NAME>g_file_info_get_type</NAME>
<RETURNS>GType               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_new</NAME>
<RETURNS>GFileInfo  *        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_dup</NAME>
<RETURNS>GFileInfo  *        </RETURNS>
GFileInfo  *other
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_copy_into</NAME>
<RETURNS>void                </RETURNS>
GFileInfo  *src_info, GFileInfo  *dest_info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_has_attribute</NAME>
<RETURNS>gboolean            </RETURNS>
GFileInfo  *info, const char *attribute
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_has_namespace</NAME>
<RETURNS>gboolean            </RETURNS>
GFileInfo  *info, const char *name_space
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_list_attributes</NAME>
<RETURNS>char  **            </RETURNS>
GFileInfo  *info, const char *name_space
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_attribute_data</NAME>
<RETURNS>gboolean            </RETURNS>
GFileInfo  *info, const char *attribute, GFileAttributeType *type, gpointer   *value_pp, GFileAttributeStatus *status
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_attribute_type</NAME>
<RETURNS>GFileAttributeType  </RETURNS>
GFileInfo  *info, const char *attribute
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_remove_attribute</NAME>
<RETURNS>void                </RETURNS>
GFileInfo  *info, const char *attribute
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_attribute_status</NAME>
<RETURNS>GFileAttributeStatus  </RETURNS>
GFileInfo  *info, const char *attribute
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_attribute_status</NAME>
<RETURNS>gboolean            </RETURNS>
GFileInfo  *info, const char *attribute, GFileAttributeStatus status
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_attribute_as_string</NAME>
<RETURNS>char  *             </RETURNS>
GFileInfo  *info, const char *attribute
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_attribute_string</NAME>
<RETURNS>const char  *       </RETURNS>
GFileInfo  *info, const char *attribute
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_attribute_byte_string</NAME>
<RETURNS>const char  *       </RETURNS>
GFileInfo  *info, const char *attribute
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_attribute_boolean</NAME>
<RETURNS>gboolean            </RETURNS>
GFileInfo  *info, const char *attribute
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_attribute_uint32</NAME>
<RETURNS>guint32             </RETURNS>
GFileInfo  *info, const char *attribute
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_attribute_int32</NAME>
<RETURNS>gint32              </RETURNS>
GFileInfo  *info, const char *attribute
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_attribute_uint64</NAME>
<RETURNS>guint64             </RETURNS>
GFileInfo  *info, const char *attribute
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_attribute_int64</NAME>
<RETURNS>gint64              </RETURNS>
GFileInfo  *info, const char *attribute
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_attribute_object</NAME>
<RETURNS>GObject  *          </RETURNS>
GFileInfo  *info, const char *attribute
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_attribute_stringv</NAME>
<RETURNS>char  **            </RETURNS>
GFileInfo  *info, const char *attribute
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_attribute</NAME>
<RETURNS>void                </RETURNS>
GFileInfo  *info, const char *attribute, GFileAttributeType type, gpointer    value_p
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_attribute_string</NAME>
<RETURNS>void                </RETURNS>
GFileInfo  *info, const char *attribute, const char *attr_value
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_attribute_byte_string</NAME>
<RETURNS>void                </RETURNS>
GFileInfo  *info, const char *attribute, const char *attr_value
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_attribute_boolean</NAME>
<RETURNS>void                </RETURNS>
GFileInfo  *info, const char *attribute, gboolean    attr_value
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_attribute_uint32</NAME>
<RETURNS>void                </RETURNS>
GFileInfo  *info, const char *attribute, guint32     attr_value
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_attribute_int32</NAME>
<RETURNS>void                </RETURNS>
GFileInfo  *info, const char *attribute, gint32      attr_value
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_attribute_uint64</NAME>
<RETURNS>void                </RETURNS>
GFileInfo  *info, const char *attribute, guint64     attr_value
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_attribute_int64</NAME>
<RETURNS>void                </RETURNS>
GFileInfo  *info, const char *attribute, gint64      attr_value
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_attribute_object</NAME>
<RETURNS>void                </RETURNS>
GFileInfo  *info, const char *attribute, GObject    *attr_value
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_attribute_stringv</NAME>
<RETURNS>void                </RETURNS>
GFileInfo  *info, const char *attribute, char      **attr_value
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_clear_status</NAME>
<RETURNS>void                </RETURNS>
GFileInfo  *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_deletion_date</NAME>
<RETURNS>GDateTime  *       </RETURNS>
GFileInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_file_type</NAME>
<RETURNS>GFileType          </RETURNS>
GFileInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_is_hidden</NAME>
<RETURNS>gboolean           </RETURNS>
GFileInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_is_backup</NAME>
<RETURNS>gboolean           </RETURNS>
GFileInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_is_symlink</NAME>
<RETURNS>gboolean           </RETURNS>
GFileInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_name</NAME>
<RETURNS>const char  *      </RETURNS>
GFileInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_display_name</NAME>
<RETURNS>const char  *      </RETURNS>
GFileInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_edit_name</NAME>
<RETURNS>const char  *      </RETURNS>
GFileInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_icon</NAME>
<RETURNS>GIcon  *           </RETURNS>
GFileInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_symbolic_icon</NAME>
<RETURNS>GIcon  *           </RETURNS>
GFileInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_content_type</NAME>
<RETURNS>const char  *      </RETURNS>
GFileInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_size</NAME>
<RETURNS>goffset            </RETURNS>
GFileInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_modification_time</NAME>
<RETURNS>void               </RETURNS>
GFileInfo         *info, GTimeVal          *result
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_symlink_target</NAME>
<RETURNS>const char  *      </RETURNS>
GFileInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_etag</NAME>
<RETURNS>const char  *      </RETURNS>
GFileInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_get_sort_order</NAME>
<RETURNS>gint32             </RETURNS>
GFileInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_attribute_mask</NAME>
<RETURNS>void               </RETURNS>
GFileInfo         *info, GFileAttributeMatcher *mask
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_unset_attribute_mask</NAME>
<RETURNS>void               </RETURNS>
GFileInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_file_type</NAME>
<RETURNS>void               </RETURNS>
GFileInfo         *info, GFileType          type
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_is_hidden</NAME>
<RETURNS>void               </RETURNS>
GFileInfo         *info, gboolean           is_hidden
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_is_symlink</NAME>
<RETURNS>void               </RETURNS>
GFileInfo         *info, gboolean           is_symlink
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_name</NAME>
<RETURNS>void               </RETURNS>
GFileInfo         *info, const char        *name
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_display_name</NAME>
<RETURNS>void               </RETURNS>
GFileInfo         *info, const char        *display_name
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_edit_name</NAME>
<RETURNS>void               </RETURNS>
GFileInfo         *info, const char        *edit_name
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_icon</NAME>
<RETURNS>void               </RETURNS>
GFileInfo         *info, GIcon             *icon
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_symbolic_icon</NAME>
<RETURNS>void               </RETURNS>
GFileInfo         *info, GIcon             *icon
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_content_type</NAME>
<RETURNS>void               </RETURNS>
GFileInfo         *info, const char        *content_type
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_size</NAME>
<RETURNS>void               </RETURNS>
GFileInfo         *info, goffset            size
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_modification_time</NAME>
<RETURNS>void               </RETURNS>
GFileInfo         *info, GTimeVal          *mtime
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_symlink_target</NAME>
<RETURNS>void               </RETURNS>
GFileInfo         *info, const char        *symlink_target
</FUNCTION>
<FUNCTION>
<NAME>g_file_info_set_sort_order</NAME>
<RETURNS>void               </RETURNS>
GFileInfo         *info, gint32             sort_order
</FUNCTION>
<MACRO>
<NAME>G_TYPE_FILE_ATTRIBUTE_MATCHER</NAME>
#define G_TYPE_FILE_ATTRIBUTE_MATCHER (g_file_attribute_matcher_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_file_attribute_matcher_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_file_attribute_matcher_new</NAME>
<RETURNS>GFileAttributeMatcher  *</RETURNS>
const char            *attributes
</FUNCTION>
<FUNCTION>
<NAME>g_file_attribute_matcher_ref</NAME>
<RETURNS>GFileAttributeMatcher  *</RETURNS>
GFileAttributeMatcher *matcher
</FUNCTION>
<FUNCTION>
<NAME>g_file_attribute_matcher_unref</NAME>
<RETURNS>void                    </RETURNS>
GFileAttributeMatcher *matcher
</FUNCTION>
<FUNCTION>
<NAME>g_file_attribute_matcher_subtract</NAME>
<RETURNS>GFileAttributeMatcher  *</RETURNS>
GFileAttributeMatcher *matcher, GFileAttributeMatcher *subtract
</FUNCTION>
<FUNCTION>
<NAME>g_file_attribute_matcher_matches</NAME>
<RETURNS>gboolean                </RETURNS>
GFileAttributeMatcher *matcher, const char            *attribute
</FUNCTION>
<FUNCTION>
<NAME>g_file_attribute_matcher_matches_only</NAME>
<RETURNS>gboolean                </RETURNS>
GFileAttributeMatcher *matcher, const char            *attribute
</FUNCTION>
<FUNCTION>
<NAME>g_file_attribute_matcher_enumerate_namespace</NAME>
<RETURNS>gboolean                </RETURNS>
GFileAttributeMatcher *matcher, const char            *ns
</FUNCTION>
<FUNCTION>
<NAME>g_file_attribute_matcher_enumerate_next</NAME>
<RETURNS>const char  *           </RETURNS>
GFileAttributeMatcher *matcher
</FUNCTION>
<FUNCTION>
<NAME>g_file_attribute_matcher_to_string</NAME>
<RETURNS>char  *                 </RETURNS>
GFileAttributeMatcher *matcher
</FUNCTION>
<STRUCT>
<NAME>GFileInfoClass</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_FILE_INPUT_STREAM</NAME>
#define G_TYPE_FILE_INPUT_STREAM         (g_file_input_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_FILE_INPUT_STREAM</NAME>
#define G_FILE_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_INPUT_STREAM, GFileInputStream))
</MACRO>
<MACRO>
<NAME>G_FILE_INPUT_STREAM_CLASS</NAME>
#define G_FILE_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_INPUT_STREAM, GFileInputStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_FILE_INPUT_STREAM</NAME>
#define G_IS_FILE_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_FILE_INPUT_STREAM_CLASS</NAME>
#define G_IS_FILE_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_FILE_INPUT_STREAM_GET_CLASS</NAME>
#define G_FILE_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_INPUT_STREAM, GFileInputStreamClass))
</MACRO>
<STRUCT>
<NAME>GFileInputStream</NAME>
struct _GFileInputStream
{
  GInputStream parent_instance;

  /*< private >*/
  GFileInputStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GFileInputStreamClass</NAME>
struct _GFileInputStreamClass
{
  GInputStreamClass parent_class;

  goffset     (* tell)              (GFileInputStream     *stream);
  gboolean    (* can_seek)          (GFileInputStream     *stream);
  gboolean    (* seek)	            (GFileInputStream     *stream,
                                     goffset               offset,
                                     GSeekType             type,
                                     GCancellable         *cancellable,
                                     GError              **error);
  GFileInfo * (* query_info)        (GFileInputStream     *stream,
                                     const char           *attributes,
                                     GCancellable         *cancellable,
                                     GError              **error);
  void        (* query_info_async)  (GFileInputStream     *stream,
                                     const char           *attributes,
                                     int                   io_priority,
                                     GCancellable         *cancellable,
                                     GAsyncReadyCallback   callback,
                                     gpointer              user_data);
  GFileInfo * (* query_info_finish) (GFileInputStream     *stream,
                                     GAsyncResult         *result,
                                     GError              **error);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_file_input_stream_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_file_input_stream_query_info</NAME>
<RETURNS>GFileInfo  *</RETURNS>
GFileInputStream     *stream, const char           *attributes, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_input_stream_query_info_async</NAME>
<RETURNS>void        </RETURNS>
GFileInputStream     *stream, const char           *attributes, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_input_stream_query_info_finish</NAME>
<RETURNS>GFileInfo  *</RETURNS>
GFileInputStream     *stream, GAsyncResult         *result, GError              **error
</FUNCTION>
<STRUCT>
<NAME>GFileInputStreamPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_FILE_IO_STREAM</NAME>
#define G_TYPE_FILE_IO_STREAM         (g_file_io_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_FILE_IO_STREAM</NAME>
#define G_FILE_IO_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_IO_STREAM, GFileIOStream))
</MACRO>
<MACRO>
<NAME>G_FILE_IO_STREAM_CLASS</NAME>
#define G_FILE_IO_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_IO_STREAM, GFileIOStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_FILE_IO_STREAM</NAME>
#define G_IS_FILE_IO_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_IO_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_FILE_IO_STREAM_CLASS</NAME>
#define G_IS_FILE_IO_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_IO_STREAM))
</MACRO>
<MACRO>
<NAME>G_FILE_IO_STREAM_GET_CLASS</NAME>
#define G_FILE_IO_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_IO_STREAM, GFileIOStreamClass))
</MACRO>
<STRUCT>
<NAME>GFileIOStream</NAME>
struct _GFileIOStream
{
  GIOStream parent_instance;

  /*< private >*/
  GFileIOStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GFileIOStreamClass</NAME>
struct _GFileIOStreamClass
{
  GIOStreamClass parent_class;

  goffset     (* tell)              (GFileIOStream    *stream);
  gboolean    (* can_seek)          (GFileIOStream    *stream);
  gboolean    (* seek)	            (GFileIOStream    *stream,
                                     goffset               offset,
                                     GSeekType             type,
                                     GCancellable         *cancellable,
                                     GError              **error);
  gboolean    (* can_truncate)      (GFileIOStream    *stream);
  gboolean    (* truncate_fn)       (GFileIOStream    *stream,
                                     goffset               size,
                                     GCancellable         *cancellable,
                                     GError              **error);
  GFileInfo * (* query_info)        (GFileIOStream    *stream,
                                     const char           *attributes,
                                     GCancellable         *cancellable,
                                     GError              **error);
  void        (* query_info_async)  (GFileIOStream     *stream,
                                     const char            *attributes,
                                     int                   io_priority,
                                     GCancellable         *cancellable,
                                     GAsyncReadyCallback   callback,
                                     gpointer              user_data);
  GFileInfo * (* query_info_finish) (GFileIOStream     *stream,
                                     GAsyncResult         *result,
                                     GError              **error);
  char      * (* get_etag)          (GFileIOStream    *stream);

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_file_io_stream_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_file_io_stream_query_info</NAME>
<RETURNS>GFileInfo  *</RETURNS>
GFileIOStream    *stream, const char           *attributes, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_io_stream_query_info_async</NAME>
<RETURNS>void        </RETURNS>
GFileIOStream    *stream, const char           *attributes, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_io_stream_query_info_finish</NAME>
<RETURNS>GFileInfo  *</RETURNS>
GFileIOStream    *stream, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_io_stream_get_etag</NAME>
<RETURNS>char  *     </RETURNS>
GFileIOStream    *stream
</FUNCTION>
<STRUCT>
<NAME>GFileIOStreamPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_FILE_MONITOR</NAME>
#define G_TYPE_FILE_MONITOR         (g_file_monitor_get_type ())
</MACRO>
<MACRO>
<NAME>G_FILE_MONITOR</NAME>
#define G_FILE_MONITOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_MONITOR, GFileMonitor))
</MACRO>
<MACRO>
<NAME>G_FILE_MONITOR_CLASS</NAME>
#define G_FILE_MONITOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_MONITOR, GFileMonitorClass))
</MACRO>
<MACRO>
<NAME>G_IS_FILE_MONITOR</NAME>
#define G_IS_FILE_MONITOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_MONITOR))
</MACRO>
<MACRO>
<NAME>G_IS_FILE_MONITOR_CLASS</NAME>
#define G_IS_FILE_MONITOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_MONITOR))
</MACRO>
<MACRO>
<NAME>G_FILE_MONITOR_GET_CLASS</NAME>
#define G_FILE_MONITOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_MONITOR, GFileMonitorClass))
</MACRO>
<STRUCT>
<NAME>GFileMonitor</NAME>
struct _GFileMonitor
{
  GObject parent_instance;

  /*< private >*/
  GFileMonitorPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GFileMonitorClass</NAME>
struct _GFileMonitorClass
{
  GObjectClass parent_class;

  /* Signals */
  void     (* changed) (GFileMonitor      *monitor,
                        GFile             *file,
                        GFile             *other_file,
                        GFileMonitorEvent  event_type);

  /* Virtual Table */
  gboolean (* cancel)  (GFileMonitor      *monitor);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_file_monitor_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_file_monitor_cancel</NAME>
<RETURNS>gboolean  </RETURNS>
GFileMonitor      *monitor
</FUNCTION>
<FUNCTION>
<NAME>g_file_monitor_is_cancelled</NAME>
<RETURNS>gboolean  </RETURNS>
GFileMonitor      *monitor
</FUNCTION>
<FUNCTION>
<NAME>g_file_monitor_set_rate_limit</NAME>
<RETURNS>void      </RETURNS>
GFileMonitor      *monitor, gint               limit_msecs
</FUNCTION>
<FUNCTION>
<NAME>g_file_monitor_emit_event</NAME>
<RETURNS>void      </RETURNS>
GFileMonitor      *monitor, GFile             *child, GFile             *other_file, GFileMonitorEvent  event_type
</FUNCTION>
<STRUCT>
<NAME>GFileMonitorPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_FILENAME_COMPLETER</NAME>
#define G_TYPE_FILENAME_COMPLETER         (g_filename_completer_get_type ())
</MACRO>
<MACRO>
<NAME>G_FILENAME_COMPLETER</NAME>
#define G_FILENAME_COMPLETER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILENAME_COMPLETER, GFilenameCompleter))
</MACRO>
<MACRO>
<NAME>G_FILENAME_COMPLETER_CLASS</NAME>
#define G_FILENAME_COMPLETER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILENAME_COMPLETER, GFilenameCompleterClass))
</MACRO>
<MACRO>
<NAME>G_FILENAME_COMPLETER_GET_CLASS</NAME>
#define G_FILENAME_COMPLETER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILENAME_COMPLETER, GFilenameCompleterClass))
</MACRO>
<MACRO>
<NAME>G_IS_FILENAME_COMPLETER</NAME>
#define G_IS_FILENAME_COMPLETER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILENAME_COMPLETER))
</MACRO>
<MACRO>
<NAME>G_IS_FILENAME_COMPLETER_CLASS</NAME>
#define G_IS_FILENAME_COMPLETER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILENAME_COMPLETER))
</MACRO>
<STRUCT>
<NAME>GFilenameCompleterClass</NAME>
struct _GFilenameCompleterClass
{
  GObjectClass parent_class;

  /*< public >*/
  /* signals */
  void (* got_completion_data) (GFilenameCompleter *filename_completer);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_filename_completer_get_type</NAME>
<RETURNS>GType                </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_filename_completer_new</NAME>
<RETURNS>GFilenameCompleter  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_filename_completer_get_completion_suffix</NAME>
<RETURNS>char  *              </RETURNS>
GFilenameCompleter *completer, const char *initial_text
</FUNCTION>
<FUNCTION>
<NAME>g_filename_completer_get_completions</NAME>
<RETURNS>char  **             </RETURNS>
GFilenameCompleter *completer, const char *initial_text
</FUNCTION>
<FUNCTION>
<NAME>g_filename_completer_set_dirs_only</NAME>
<RETURNS>void                 </RETURNS>
GFilenameCompleter *completer, gboolean dirs_only
</FUNCTION>
<MACRO>
<NAME>G_TYPE_FILE_OUTPUT_STREAM</NAME>
#define G_TYPE_FILE_OUTPUT_STREAM         (g_file_output_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_FILE_OUTPUT_STREAM</NAME>
#define G_FILE_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_OUTPUT_STREAM, GFileOutputStream))
</MACRO>
<MACRO>
<NAME>G_FILE_OUTPUT_STREAM_CLASS</NAME>
#define G_FILE_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_OUTPUT_STREAM, GFileOutputStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_FILE_OUTPUT_STREAM</NAME>
#define G_IS_FILE_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_FILE_OUTPUT_STREAM_CLASS</NAME>
#define G_IS_FILE_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_FILE_OUTPUT_STREAM_GET_CLASS</NAME>
#define G_FILE_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_OUTPUT_STREAM, GFileOutputStreamClass))
</MACRO>
<STRUCT>
<NAME>GFileOutputStream</NAME>
struct _GFileOutputStream
{
  GOutputStream parent_instance;

  /*< private >*/
  GFileOutputStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GFileOutputStreamClass</NAME>
struct _GFileOutputStreamClass
{
  GOutputStreamClass parent_class;

  goffset     (* tell)              (GFileOutputStream    *stream);
  gboolean    (* can_seek)          (GFileOutputStream    *stream);
  gboolean    (* seek)	            (GFileOutputStream    *stream,
                                     goffset               offset,
                                     GSeekType             type,
                                     GCancellable         *cancellable,
                                     GError              **error);
  gboolean    (* can_truncate)      (GFileOutputStream    *stream);
  gboolean    (* truncate_fn)       (GFileOutputStream    *stream,
                                     goffset               size,
                                     GCancellable         *cancellable,
                                     GError              **error);
  GFileInfo * (* query_info)        (GFileOutputStream    *stream,
                                     const char           *attributes,
                                     GCancellable         *cancellable,
                                     GError              **error);
  void        (* query_info_async)  (GFileOutputStream     *stream,
                                     const char            *attributes,
                                     int                   io_priority,
                                     GCancellable         *cancellable,
                                     GAsyncReadyCallback   callback,
                                     gpointer              user_data);
  GFileInfo * (* query_info_finish) (GFileOutputStream     *stream,
                                     GAsyncResult         *result,
                                     GError              **error);
  char      * (* get_etag)          (GFileOutputStream    *stream);

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_file_output_stream_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_file_output_stream_query_info</NAME>
<RETURNS>GFileInfo  *</RETURNS>
GFileOutputStream    *stream, const char           *attributes, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_output_stream_query_info_async</NAME>
<RETURNS>void        </RETURNS>
GFileOutputStream    *stream, const char           *attributes, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_file_output_stream_query_info_finish</NAME>
<RETURNS>GFileInfo  *</RETURNS>
GFileOutputStream    *stream, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_file_output_stream_get_etag</NAME>
<RETURNS>char  *     </RETURNS>
GFileOutputStream    *stream
</FUNCTION>
<STRUCT>
<NAME>GFileOutputStreamPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_FILTER_INPUT_STREAM</NAME>
#define G_TYPE_FILTER_INPUT_STREAM         (g_filter_input_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_FILTER_INPUT_STREAM</NAME>
#define G_FILTER_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILTER_INPUT_STREAM, GFilterInputStream))
</MACRO>
<MACRO>
<NAME>G_FILTER_INPUT_STREAM_CLASS</NAME>
#define G_FILTER_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILTER_INPUT_STREAM, GFilterInputStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_FILTER_INPUT_STREAM</NAME>
#define G_IS_FILTER_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILTER_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_FILTER_INPUT_STREAM_CLASS</NAME>
#define G_IS_FILTER_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILTER_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_FILTER_INPUT_STREAM_GET_CLASS</NAME>
#define G_FILTER_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILTER_INPUT_STREAM, GFilterInputStreamClass))
</MACRO>
<STRUCT>
<NAME>GFilterInputStream</NAME>
struct _GFilterInputStream
{
  GInputStream parent_instance;

  /*<protected >*/
  GInputStream *base_stream;
};
</STRUCT>
<STRUCT>
<NAME>GFilterInputStreamClass</NAME>
struct _GFilterInputStreamClass
{
  GInputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_filter_input_stream_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_filter_input_stream_get_base_stream</NAME>
<RETURNS>GInputStream  * </RETURNS>
GFilterInputStream *stream
</FUNCTION>
<FUNCTION>
<NAME>g_filter_input_stream_get_close_base_stream</NAME>
<RETURNS>gboolean        </RETURNS>
GFilterInputStream *stream
</FUNCTION>
<FUNCTION>
<NAME>g_filter_input_stream_set_close_base_stream</NAME>
<RETURNS>void            </RETURNS>
GFilterInputStream *stream, gboolean            close_base
</FUNCTION>
<MACRO>
<NAME>G_TYPE_FILTER_OUTPUT_STREAM</NAME>
#define G_TYPE_FILTER_OUTPUT_STREAM         (g_filter_output_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_FILTER_OUTPUT_STREAM</NAME>
#define G_FILTER_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILTER_OUTPUT_STREAM, GFilterOutputStream))
</MACRO>
<MACRO>
<NAME>G_FILTER_OUTPUT_STREAM_CLASS</NAME>
#define G_FILTER_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILTER_OUTPUT_STREAM, GFilterOutputStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_FILTER_OUTPUT_STREAM</NAME>
#define G_IS_FILTER_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILTER_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_FILTER_OUTPUT_STREAM_CLASS</NAME>
#define G_IS_FILTER_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILTER_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_FILTER_OUTPUT_STREAM_GET_CLASS</NAME>
#define G_FILTER_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILTER_OUTPUT_STREAM, GFilterOutputStreamClass))
</MACRO>
<STRUCT>
<NAME>GFilterOutputStream</NAME>
struct _GFilterOutputStream
{
  GOutputStream parent_instance;

  /*< protected >*/
  GOutputStream *base_stream;
};
</STRUCT>
<STRUCT>
<NAME>GFilterOutputStreamClass</NAME>
struct _GFilterOutputStreamClass
{
  GOutputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_filter_output_stream_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_filter_output_stream_get_base_stream</NAME>
<RETURNS>GOutputStream  * </RETURNS>
GFilterOutputStream *stream
</FUNCTION>
<FUNCTION>
<NAME>g_filter_output_stream_get_close_base_stream</NAME>
<RETURNS>gboolean         </RETURNS>
GFilterOutputStream *stream
</FUNCTION>
<FUNCTION>
<NAME>g_filter_output_stream_set_close_base_stream</NAME>
<RETURNS>void             </RETURNS>
GFilterOutputStream *stream, gboolean             close_base
</FUNCTION>
<MACRO>
<NAME>G_TYPE_ICON</NAME>
#define G_TYPE_ICON            (g_icon_get_type ())
</MACRO>
<MACRO>
<NAME>G_ICON</NAME>
#define G_ICON(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_ICON, GIcon))
</MACRO>
<MACRO>
<NAME>G_IS_ICON</NAME>
#define G_IS_ICON(obj)	       (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_ICON))
</MACRO>
<MACRO>
<NAME>G_ICON_GET_IFACE</NAME>
#define G_ICON_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_ICON, GIconIface))
</MACRO>
<STRUCT>
<NAME>GIconIface</NAME>
struct _GIconIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  guint       (* hash)        (GIcon   *icon);
  gboolean    (* equal)       (GIcon   *icon1,
                               GIcon   *icon2);
  gboolean    (* to_tokens)   (GIcon   *icon,
			       GPtrArray *tokens,
                               gint    *out_version);
  GIcon *     (* from_tokens) (gchar  **tokens,
                               gint     num_tokens,
                               gint     version,
                               GError **error);

  GVariant *  (* serialize)   (GIcon   *icon);
};
</STRUCT>
<FUNCTION>
<NAME>g_icon_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_icon_hash</NAME>
<RETURNS>guint     </RETURNS>
gconstpointer  icon
</FUNCTION>
<FUNCTION>
<NAME>g_icon_equal</NAME>
<RETURNS>gboolean  </RETURNS>
GIcon         *icon1, GIcon         *icon2
</FUNCTION>
<FUNCTION>
<NAME>g_icon_to_string</NAME>
<RETURNS>gchar    *</RETURNS>
GIcon         *icon
</FUNCTION>
<FUNCTION>
<NAME>g_icon_new_for_string</NAME>
<RETURNS>GIcon    *</RETURNS>
const gchar   *str, GError       **error
</FUNCTION>
<FUNCTION>
<NAME>g_icon_serialize</NAME>
<RETURNS>GVariant  * </RETURNS>
GIcon         *icon
</FUNCTION>
<FUNCTION>
<NAME>g_icon_deserialize</NAME>
<RETURNS>GIcon  *    </RETURNS>
GVariant      *value
</FUNCTION>
<MACRO>
<NAME>G_TYPE_INET_ADDRESS</NAME>
#define G_TYPE_INET_ADDRESS         (g_inet_address_get_type ())
</MACRO>
<MACRO>
<NAME>G_INET_ADDRESS</NAME>
#define G_INET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INET_ADDRESS, GInetAddress))
</MACRO>
<MACRO>
<NAME>G_INET_ADDRESS_CLASS</NAME>
#define G_INET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INET_ADDRESS, GInetAddressClass))
</MACRO>
<MACRO>
<NAME>G_IS_INET_ADDRESS</NAME>
#define G_IS_INET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INET_ADDRESS))
</MACRO>
<MACRO>
<NAME>G_IS_INET_ADDRESS_CLASS</NAME>
#define G_IS_INET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INET_ADDRESS))
</MACRO>
<MACRO>
<NAME>G_INET_ADDRESS_GET_CLASS</NAME>
#define G_INET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INET_ADDRESS, GInetAddressClass))
</MACRO>
<STRUCT>
<NAME>GInetAddress</NAME>
struct _GInetAddress
{
  GObject parent_instance;

  /*< private >*/
  GInetAddressPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GInetAddressClass</NAME>
struct _GInetAddressClass
{
  GObjectClass parent_class;

  gchar *        (*to_string) (GInetAddress *address);
  const guint8 * (*to_bytes)  (GInetAddress *address);
};
</STRUCT>
<FUNCTION>
<NAME>g_inet_address_get_type</NAME>
<RETURNS>GType                  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_new_from_string</NAME>
<RETURNS>GInetAddress  *        </RETURNS>
const gchar          *string
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_new_from_bytes</NAME>
<RETURNS>GInetAddress  *        </RETURNS>
const guint8         *bytes, GSocketFamily         family
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_new_loopback</NAME>
<RETURNS>GInetAddress  *        </RETURNS>
GSocketFamily         family
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_new_any</NAME>
<RETURNS>GInetAddress  *        </RETURNS>
GSocketFamily         family
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_equal</NAME>
<RETURNS>gboolean               </RETURNS>
GInetAddress         *address, GInetAddress         *other_address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_to_string</NAME>
<RETURNS>gchar  *               </RETURNS>
GInetAddress         *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_to_bytes</NAME>
<RETURNS>const guint8  *        </RETURNS>
GInetAddress         *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_get_native_size</NAME>
<RETURNS>gsize                  </RETURNS>
GInetAddress         *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_get_family</NAME>
<RETURNS>GSocketFamily          </RETURNS>
GInetAddress         *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_get_is_any</NAME>
<RETURNS>gboolean               </RETURNS>
GInetAddress         *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_get_is_loopback</NAME>
<RETURNS>gboolean               </RETURNS>
GInetAddress         *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_get_is_link_local</NAME>
<RETURNS>gboolean               </RETURNS>
GInetAddress         *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_get_is_site_local</NAME>
<RETURNS>gboolean               </RETURNS>
GInetAddress         *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_get_is_multicast</NAME>
<RETURNS>gboolean               </RETURNS>
GInetAddress         *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_get_is_mc_global</NAME>
<RETURNS>gboolean               </RETURNS>
GInetAddress         *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_get_is_mc_link_local</NAME>
<RETURNS>gboolean               </RETURNS>
GInetAddress         *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_get_is_mc_node_local</NAME>
<RETURNS>gboolean               </RETURNS>
GInetAddress         *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_get_is_mc_org_local</NAME>
<RETURNS>gboolean               </RETURNS>
GInetAddress         *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_get_is_mc_site_local</NAME>
<RETURNS>gboolean               </RETURNS>
GInetAddress         *address
</FUNCTION>
<STRUCT>
<NAME>GInetAddressPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_INET_ADDRESS_MASK</NAME>
#define G_TYPE_INET_ADDRESS_MASK         (g_inet_address_mask_get_type ())
</MACRO>
<MACRO>
<NAME>G_INET_ADDRESS_MASK</NAME>
#define G_INET_ADDRESS_MASK(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INET_ADDRESS_MASK, GInetAddressMask))
</MACRO>
<MACRO>
<NAME>G_INET_ADDRESS_MASK_CLASS</NAME>
#define G_INET_ADDRESS_MASK_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INET_ADDRESS_MASK, GInetAddressMaskClass))
</MACRO>
<MACRO>
<NAME>G_IS_INET_ADDRESS_MASK</NAME>
#define G_IS_INET_ADDRESS_MASK(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INET_ADDRESS_MASK))
</MACRO>
<MACRO>
<NAME>G_IS_INET_ADDRESS_MASK_CLASS</NAME>
#define G_IS_INET_ADDRESS_MASK_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INET_ADDRESS_MASK))
</MACRO>
<MACRO>
<NAME>G_INET_ADDRESS_MASK_GET_CLASS</NAME>
#define G_INET_ADDRESS_MASK_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INET_ADDRESS_MASK, GInetAddressMaskClass))
</MACRO>
<STRUCT>
<NAME>GInetAddressMask</NAME>
struct _GInetAddressMask
{
  GObject parent_instance;

  /*< private >*/
  GInetAddressMaskPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GInetAddressMaskClass</NAME>
struct _GInetAddressMaskClass
{
  GObjectClass parent_class;

};
</STRUCT>
<FUNCTION>
<NAME>g_inet_address_mask_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_mask_new</NAME>
<RETURNS>GInetAddressMask  *</RETURNS>
GInetAddress      *addr, guint              length, GError           **error
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_mask_new_from_string</NAME>
<RETURNS>GInetAddressMask  *</RETURNS>
const gchar       *mask_string, GError           **error
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_mask_to_string</NAME>
<RETURNS>gchar             *</RETURNS>
GInetAddressMask  *mask
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_mask_get_family</NAME>
<RETURNS>GSocketFamily      </RETURNS>
GInetAddressMask  *mask
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_mask_get_address</NAME>
<RETURNS>GInetAddress      *</RETURNS>
GInetAddressMask  *mask
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_mask_get_length</NAME>
<RETURNS>guint              </RETURNS>
GInetAddressMask  *mask
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_mask_matches</NAME>
<RETURNS>gboolean           </RETURNS>
GInetAddressMask  *mask, GInetAddress      *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_address_mask_equal</NAME>
<RETURNS>gboolean           </RETURNS>
GInetAddressMask  *mask, GInetAddressMask  *mask2
</FUNCTION>
<STRUCT>
<NAME>GInetAddressMaskPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_INET_SOCKET_ADDRESS</NAME>
#define G_TYPE_INET_SOCKET_ADDRESS         (g_inet_socket_address_get_type ())
</MACRO>
<MACRO>
<NAME>G_INET_SOCKET_ADDRESS</NAME>
#define G_INET_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddress))
</MACRO>
<MACRO>
<NAME>G_INET_SOCKET_ADDRESS_CLASS</NAME>
#define G_INET_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddressClass))
</MACRO>
<MACRO>
<NAME>G_IS_INET_SOCKET_ADDRESS</NAME>
#define G_IS_INET_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INET_SOCKET_ADDRESS))
</MACRO>
<MACRO>
<NAME>G_IS_INET_SOCKET_ADDRESS_CLASS</NAME>
#define G_IS_INET_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INET_SOCKET_ADDRESS))
</MACRO>
<MACRO>
<NAME>G_INET_SOCKET_ADDRESS_GET_CLASS</NAME>
#define G_INET_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddressClass))
</MACRO>
<STRUCT>
<NAME>GInetSocketAddress</NAME>
struct _GInetSocketAddress
{
  GSocketAddress parent_instance;

  /*< private >*/
  GInetSocketAddressPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GInetSocketAddressClass</NAME>
struct _GInetSocketAddressClass
{
  GSocketAddressClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>g_inet_socket_address_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_inet_socket_address_new</NAME>
<RETURNS>GSocketAddress  *</RETURNS>
GInetAddress       *address, guint16             port
</FUNCTION>
<FUNCTION>
<NAME>g_inet_socket_address_new_from_string</NAME>
<RETURNS>GSocketAddress  *</RETURNS>
const char         *address, guint               port
</FUNCTION>
<FUNCTION>
<NAME>g_inet_socket_address_get_address</NAME>
<RETURNS>GInetAddress  *  </RETURNS>
GInetSocketAddress *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_socket_address_get_port</NAME>
<RETURNS>guint16          </RETURNS>
GInetSocketAddress *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_socket_address_get_flowinfo</NAME>
<RETURNS>guint32          </RETURNS>
GInetSocketAddress *address
</FUNCTION>
<FUNCTION>
<NAME>g_inet_socket_address_get_scope_id</NAME>
<RETURNS>guint32          </RETURNS>
GInetSocketAddress *address
</FUNCTION>
<STRUCT>
<NAME>GInetSocketAddressPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_INITABLE</NAME>
#define G_TYPE_INITABLE            (g_initable_get_type ())
</MACRO>
<MACRO>
<NAME>G_INITABLE</NAME>
#define G_INITABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_INITABLE, GInitable))
</MACRO>
<MACRO>
<NAME>G_IS_INITABLE</NAME>
#define G_IS_INITABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_INITABLE))
</MACRO>
<MACRO>
<NAME>G_INITABLE_GET_IFACE</NAME>
#define G_INITABLE_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_INITABLE, GInitableIface))
</MACRO>
<MACRO>
<NAME>G_TYPE_IS_INITABLE</NAME>
#define G_TYPE_IS_INITABLE(type)   (g_type_is_a ((type), G_TYPE_INITABLE))
</MACRO>
<STRUCT>
<NAME>GInitableIface</NAME>
struct _GInitableIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  gboolean    (* init) (GInitable    *initable,
			GCancellable *cancellable,
			GError      **error);
};
</STRUCT>
<FUNCTION>
<NAME>g_initable_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_initable_init</NAME>
<RETURNS>gboolean  </RETURNS>
GInitable     *initable, GCancellable  *cancellable, GError       **error
</FUNCTION>
<FUNCTION>
<NAME>g_initable_new</NAME>
<RETURNS>gpointer  </RETURNS>
GType          object_type, GCancellable  *cancellable, GError       **error, const gchar   *first_property_name, ...
</FUNCTION>
<FUNCTION>
<NAME>g_initable_newv</NAME>
<DEPRECATED/>
<RETURNS>gpointer  </RETURNS>
GType          object_type, guint          n_parameters, GParameter    *parameters, GCancellable  *cancellable, GError       **error
</FUNCTION>
<FUNCTION>
<NAME>g_initable_new_valist</NAME>
<RETURNS>GObject * </RETURNS>
GType          object_type, const gchar   *first_property_name, va_list        var_args, GCancellable  *cancellable, GError       **error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_INPUT_STREAM</NAME>
#define G_TYPE_INPUT_STREAM         (g_input_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_INPUT_STREAM</NAME>
#define G_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INPUT_STREAM, GInputStream))
</MACRO>
<MACRO>
<NAME>G_INPUT_STREAM_CLASS</NAME>
#define G_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INPUT_STREAM, GInputStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_INPUT_STREAM</NAME>
#define G_IS_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_INPUT_STREAM_CLASS</NAME>
#define G_IS_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_INPUT_STREAM_GET_CLASS</NAME>
#define G_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INPUT_STREAM, GInputStreamClass))
</MACRO>
<STRUCT>
<NAME>GInputStream</NAME>
struct _GInputStream
{
  GObject parent_instance;

  /*< private >*/
  GInputStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GInputStreamClass</NAME>
struct _GInputStreamClass
{
  GObjectClass parent_class;

  /* Sync ops: */

  gssize   (* read_fn)      (GInputStream        *stream,
                             void                *buffer,
                             gsize                count,
                             GCancellable        *cancellable,
                             GError             **error);
  gssize   (* skip)         (GInputStream        *stream,
                             gsize                count,
                             GCancellable        *cancellable,
                             GError             **error);
  gboolean (* close_fn)	    (GInputStream        *stream,
                             GCancellable        *cancellable,
                             GError             **error);

  /* Async ops: (optional in derived classes) */
  void     (* read_async)   (GInputStream        *stream,
                             void                *buffer,
                             gsize                count,
                             int                  io_priority,
                             GCancellable        *cancellable,
                             GAsyncReadyCallback  callback,
                             gpointer             user_data);
  gssize   (* read_finish)  (GInputStream        *stream,
                             GAsyncResult        *result,
                             GError             **error);
  void     (* skip_async)   (GInputStream        *stream,
                             gsize                count,
                             int                  io_priority,
                             GCancellable        *cancellable,
                             GAsyncReadyCallback  callback,
                             gpointer             user_data);
  gssize   (* skip_finish)  (GInputStream        *stream,
                             GAsyncResult        *result,
                             GError             **error);
  void     (* close_async)  (GInputStream        *stream,
                             int                  io_priority,
                             GCancellable        *cancellable,
                             GAsyncReadyCallback  callback,
                             gpointer             user_data);
  gboolean (* close_finish) (GInputStream        *stream,
                             GAsyncResult        *result,
                             GError             **error);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_input_stream_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_read</NAME>
<RETURNS>gssize    </RETURNS>
GInputStream          *stream, void                  *buffer, gsize                  count, GCancellable          *cancellable, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_read_all</NAME>
<RETURNS>gboolean  </RETURNS>
GInputStream          *stream, void                  *buffer, gsize                  count, gsize                 *bytes_read, GCancellable          *cancellable, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_read_bytes</NAME>
<RETURNS>GBytes   *</RETURNS>
GInputStream          *stream, gsize                  count, GCancellable          *cancellable, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_skip</NAME>
<RETURNS>gssize    </RETURNS>
GInputStream          *stream, gsize                  count, GCancellable          *cancellable, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_close</NAME>
<RETURNS>gboolean  </RETURNS>
GInputStream          *stream, GCancellable          *cancellable, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_read_async</NAME>
<RETURNS>void      </RETURNS>
GInputStream          *stream, void                  *buffer, gsize                  count, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_read_finish</NAME>
<RETURNS>gssize    </RETURNS>
GInputStream          *stream, GAsyncResult          *result, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_read_all_async</NAME>
<RETURNS>void      </RETURNS>
GInputStream          *stream, void                  *buffer, gsize                  count, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_read_all_finish</NAME>
<RETURNS>gboolean  </RETURNS>
GInputStream          *stream, GAsyncResult          *result, gsize                 *bytes_read, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_read_bytes_async</NAME>
<RETURNS>void      </RETURNS>
GInputStream          *stream, gsize                  count, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_read_bytes_finish</NAME>
<RETURNS>GBytes   *</RETURNS>
GInputStream          *stream, GAsyncResult          *result, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_skip_async</NAME>
<RETURNS>void      </RETURNS>
GInputStream          *stream, gsize                  count, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_skip_finish</NAME>
<RETURNS>gssize    </RETURNS>
GInputStream          *stream, GAsyncResult          *result, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_close_async</NAME>
<RETURNS>void      </RETURNS>
GInputStream          *stream, int                    io_priority, GCancellable          *cancellable, GAsyncReadyCallback    callback, gpointer               user_data
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_close_finish</NAME>
<RETURNS>gboolean  </RETURNS>
GInputStream          *stream, GAsyncResult          *result, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_is_closed</NAME>
<RETURNS>gboolean  </RETURNS>
GInputStream          *stream
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_has_pending</NAME>
<RETURNS>gboolean  </RETURNS>
GInputStream          *stream
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_set_pending</NAME>
<RETURNS>gboolean  </RETURNS>
GInputStream          *stream, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_input_stream_clear_pending</NAME>
<RETURNS>void      </RETURNS>
GInputStream          *stream
</FUNCTION>
<STRUCT>
<NAME>GInputStreamPrivate</NAME>
</STRUCT>
<FUNCTION>
<NAME>print_error</NAME>
<RETURNS>void  </RETURNS>
const gchar    *format, ...
</FUNCTION>
<FUNCTION>
<NAME>print_file_error</NAME>
<RETURNS>void  </RETURNS>
GFile          *file, const gchar    *message
</FUNCTION>
<FUNCTION>
<NAME>show_help</NAME>
<RETURNS>void  </RETURNS>
GOptionContext *context, const char     *message
</FUNCTION>
<FUNCTION>
<NAME>file_type_to_string</NAME>
<RETURNS>const char          *</RETURNS>
GFileType                type
</FUNCTION>
<FUNCTION>
<NAME>attribute_type_to_string</NAME>
<RETURNS>const char          *</RETURNS>
GFileAttributeType       type
</FUNCTION>
<FUNCTION>
<NAME>attribute_type_from_string</NAME>
<RETURNS>GFileAttributeType   </RETURNS>
const char              *str
</FUNCTION>
<FUNCTION>
<NAME>attribute_flags_to_string</NAME>
<RETURNS>char                *</RETURNS>
GFileAttributeInfoFlags  flags
</FUNCTION>
<FUNCTION>
<NAME>file_is_dir</NAME>
<RETURNS>gboolean  </RETURNS>
GFile *file
</FUNCTION>
<FUNCTION>
<NAME>handle_cat</NAME>
<RETURNS>int  </RETURNS>
int argc, char *argv[], gboolean do_help
</FUNCTION>
<FUNCTION>
<NAME>handle_copy</NAME>
<RETURNS>int  </RETURNS>
int argc, char *argv[], gboolean do_help
</FUNCTION>
<FUNCTION>
<NAME>handle_info</NAME>
<RETURNS>int  </RETURNS>
int argc, char *argv[], gboolean do_help
</FUNCTION>
<FUNCTION>
<NAME>handle_list</NAME>
<RETURNS>int  </RETURNS>
int argc, char *argv[], gboolean do_help
</FUNCTION>
<FUNCTION>
<NAME>handle_mime</NAME>
<RETURNS>int  </RETURNS>
int argc, char *argv[], gboolean do_help
</FUNCTION>
<FUNCTION>
<NAME>handle_mkdir</NAME>
<RETURNS>int  </RETURNS>
int argc, char *argv[], gboolean do_help
</FUNCTION>
<FUNCTION>
<NAME>handle_monitor</NAME>
<RETURNS>int  </RETURNS>
int argc, char *argv[], gboolean do_help
</FUNCTION>
<FUNCTION>
<NAME>handle_mount</NAME>
<RETURNS>int  </RETURNS>
int argc, char *argv[], gboolean do_help
</FUNCTION>
<FUNCTION>
<NAME>handle_move</NAME>
<RETURNS>int  </RETURNS>
int argc, char *argv[], gboolean do_help
</FUNCTION>
<FUNCTION>
<NAME>handle_open</NAME>
<RETURNS>int  </RETURNS>
int argc, char *argv[], gboolean do_help
</FUNCTION>
<FUNCTION>
<NAME>handle_rename</NAME>
<RETURNS>int  </RETURNS>
int argc, char *argv[], gboolean do_help
</FUNCTION>
<FUNCTION>
<NAME>handle_remove</NAME>
<RETURNS>int  </RETURNS>
int argc, char *argv[], gboolean do_help
</FUNCTION>
<FUNCTION>
<NAME>handle_save</NAME>
<RETURNS>int  </RETURNS>
int argc, char *argv[], gboolean do_help
</FUNCTION>
<FUNCTION>
<NAME>handle_set</NAME>
<RETURNS>int  </RETURNS>
int argc, char *argv[], gboolean do_help
</FUNCTION>
<FUNCTION>
<NAME>handle_trash</NAME>
<RETURNS>int  </RETURNS>
int argc, char *argv[], gboolean do_help
</FUNCTION>
<FUNCTION>
<NAME>handle_tree</NAME>
<RETURNS>int  </RETURNS>
int argc, char *argv[], gboolean do_help
</FUNCTION>
<MACRO>
<NAME>TRACE</NAME>
#define TRACE(probe) probe
</MACRO>
<ENUM>
<NAME>GAppInfoCreateFlags</NAME>
typedef enum {
  G_APP_INFO_CREATE_NONE                           = 0,         /*< nick=none >*/
  G_APP_INFO_CREATE_NEEDS_TERMINAL                 = (1 << 0),  /*< nick=needs-terminal >*/
  G_APP_INFO_CREATE_SUPPORTS_URIS                  = (1 << 1),  /*< nick=supports-uris >*/
  G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION  = (1 << 2)   /*< nick=supports-startup-notification >*/
} GAppInfoCreateFlags;
</ENUM>
<ENUM>
<NAME>GConverterFlags</NAME>
typedef enum {
  G_CONVERTER_NO_FLAGS     = 0,         /*< nick=none >*/
  G_CONVERTER_INPUT_AT_END = (1 << 0),  /*< nick=input-at-end >*/
  G_CONVERTER_FLUSH        = (1 << 1)   /*< nick=flush >*/
} GConverterFlags;
</ENUM>
<ENUM>
<NAME>GConverterResult</NAME>
typedef enum {
  G_CONVERTER_ERROR     = 0,  /*< nick=error >*/
  G_CONVERTER_CONVERTED = 1,  /*< nick=converted >*/
  G_CONVERTER_FINISHED  = 2,  /*< nick=finished >*/
  G_CONVERTER_FLUSHED   = 3   /*< nick=flushed >*/
} GConverterResult;
</ENUM>
<ENUM>
<NAME>GDataStreamByteOrder</NAME>
typedef enum {
  G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN,
  G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN,
  G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN
} GDataStreamByteOrder;
</ENUM>
<ENUM>
<NAME>GDataStreamNewlineType</NAME>
typedef enum {
  G_DATA_STREAM_NEWLINE_TYPE_LF,
  G_DATA_STREAM_NEWLINE_TYPE_CR,
  G_DATA_STREAM_NEWLINE_TYPE_CR_LF,
  G_DATA_STREAM_NEWLINE_TYPE_ANY
} GDataStreamNewlineType;
</ENUM>
<ENUM>
<NAME>GFileAttributeType</NAME>
typedef enum {
  G_FILE_ATTRIBUTE_TYPE_INVALID = 0,
  G_FILE_ATTRIBUTE_TYPE_STRING,
  G_FILE_ATTRIBUTE_TYPE_BYTE_STRING, /* zero terminated string of non-zero bytes */
  G_FILE_ATTRIBUTE_TYPE_BOOLEAN,
  G_FILE_ATTRIBUTE_TYPE_UINT32,
  G_FILE_ATTRIBUTE_TYPE_INT32,
  G_FILE_ATTRIBUTE_TYPE_UINT64,
  G_FILE_ATTRIBUTE_TYPE_INT64,
  G_FILE_ATTRIBUTE_TYPE_OBJECT,
  G_FILE_ATTRIBUTE_TYPE_STRINGV
} GFileAttributeType;
</ENUM>
<ENUM>
<NAME>GFileAttributeInfoFlags</NAME>
typedef enum {
  G_FILE_ATTRIBUTE_INFO_NONE            = 0,
  G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE  = (1 << 0),
  G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED = (1 << 1)
} GFileAttributeInfoFlags;
</ENUM>
<ENUM>
<NAME>GFileAttributeStatus</NAME>
typedef enum {
  G_FILE_ATTRIBUTE_STATUS_UNSET = 0,
  G_FILE_ATTRIBUTE_STATUS_SET,
  G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING
} GFileAttributeStatus;
</ENUM>
<ENUM>
<NAME>GFileQueryInfoFlags</NAME>
typedef enum {
  G_FILE_QUERY_INFO_NONE              = 0,
  G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS = (1 << 0)   /*< nick=nofollow-symlinks >*/
} GFileQueryInfoFlags;
</ENUM>
<ENUM>
<NAME>GFileCreateFlags</NAME>
typedef enum {
  G_FILE_CREATE_NONE    = 0,
  G_FILE_CREATE_PRIVATE = (1 << 0),
  G_FILE_CREATE_REPLACE_DESTINATION = (1 << 1)
} GFileCreateFlags;
</ENUM>
<ENUM>
<NAME>GFileMeasureFlags</NAME>
typedef enum {
  G_FILE_MEASURE_NONE                 = 0,
  G_FILE_MEASURE_REPORT_ANY_ERROR     = (1 << 1),
  G_FILE_MEASURE_APPARENT_SIZE        = (1 << 2),
  G_FILE_MEASURE_NO_XDEV              = (1 << 3)
} GFileMeasureFlags;
</ENUM>
<ENUM>
<NAME>GMountMountFlags</NAME>
typedef enum /*< flags >*/ {
  G_MOUNT_MOUNT_NONE = 0
} GMountMountFlags;
</ENUM>
<ENUM>
<NAME>GMountUnmountFlags</NAME>
typedef enum {
  G_MOUNT_UNMOUNT_NONE  = 0,
  G_MOUNT_UNMOUNT_FORCE = (1 << 0)
} GMountUnmountFlags;
</ENUM>
<ENUM>
<NAME>GDriveStartFlags</NAME>
typedef enum /*< flags >*/ {
  G_DRIVE_START_NONE = 0
} GDriveStartFlags;
</ENUM>
<ENUM>
<NAME>GDriveStartStopType</NAME>
typedef enum {
  G_DRIVE_START_STOP_TYPE_UNKNOWN,
  G_DRIVE_START_STOP_TYPE_SHUTDOWN,
  G_DRIVE_START_STOP_TYPE_NETWORK,
  G_DRIVE_START_STOP_TYPE_MULTIDISK,
  G_DRIVE_START_STOP_TYPE_PASSWORD
} GDriveStartStopType;
</ENUM>
<ENUM>
<NAME>GFileCopyFlags</NAME>
typedef enum {
  G_FILE_COPY_NONE                 = 0,          /*< nick=none >*/
  G_FILE_COPY_OVERWRITE            = (1 << 0),
  G_FILE_COPY_BACKUP               = (1 << 1),
  G_FILE_COPY_NOFOLLOW_SYMLINKS    = (1 << 2),
  G_FILE_COPY_ALL_METADATA         = (1 << 3),
  G_FILE_COPY_NO_FALLBACK_FOR_MOVE = (1 << 4),
  G_FILE_COPY_TARGET_DEFAULT_PERMS = (1 << 5)
} GFileCopyFlags;
</ENUM>
<ENUM>
<NAME>GFileMonitorFlags</NAME>
typedef enum {
  G_FILE_MONITOR_NONE             = 0,
  G_FILE_MONITOR_WATCH_MOUNTS     = (1 << 0),
  G_FILE_MONITOR_SEND_MOVED       = (1 << 1),
  G_FILE_MONITOR_WATCH_HARD_LINKS = (1 << 2),
  G_FILE_MONITOR_WATCH_MOVES      = (1 << 3)
} GFileMonitorFlags;
</ENUM>
<ENUM>
<NAME>GFileType</NAME>
typedef enum {
  G_FILE_TYPE_UNKNOWN = 0,
  G_FILE_TYPE_REGULAR,
  G_FILE_TYPE_DIRECTORY,
  G_FILE_TYPE_SYMBOLIC_LINK,
  G_FILE_TYPE_SPECIAL, /* socket, fifo, blockdev, chardev */
  G_FILE_TYPE_SHORTCUT,
  G_FILE_TYPE_MOUNTABLE
} GFileType;
</ENUM>
<ENUM>
<NAME>GFilesystemPreviewType</NAME>
typedef enum {
  G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS = 0,
  G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL,
  G_FILESYSTEM_PREVIEW_TYPE_NEVER
} GFilesystemPreviewType;
</ENUM>
<ENUM>
<NAME>GFileMonitorEvent</NAME>
typedef enum {
  G_FILE_MONITOR_EVENT_CHANGED,
  G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT,
  G_FILE_MONITOR_EVENT_DELETED,
  G_FILE_MONITOR_EVENT_CREATED,
  G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED,
  G_FILE_MONITOR_EVENT_PRE_UNMOUNT,
  G_FILE_MONITOR_EVENT_UNMOUNTED,
  G_FILE_MONITOR_EVENT_MOVED,
  G_FILE_MONITOR_EVENT_RENAMED,
  G_FILE_MONITOR_EVENT_MOVED_IN,
  G_FILE_MONITOR_EVENT_MOVED_OUT
} GFileMonitorEvent;
</ENUM>
<ENUM>
<NAME>GIOErrorEnum</NAME>
typedef enum {
  G_IO_ERROR_FAILED,
  G_IO_ERROR_NOT_FOUND,
  G_IO_ERROR_EXISTS,
  G_IO_ERROR_IS_DIRECTORY,
  G_IO_ERROR_NOT_DIRECTORY,
  G_IO_ERROR_NOT_EMPTY,
  G_IO_ERROR_NOT_REGULAR_FILE,
  G_IO_ERROR_NOT_SYMBOLIC_LINK,
  G_IO_ERROR_NOT_MOUNTABLE_FILE,
  G_IO_ERROR_FILENAME_TOO_LONG,
  G_IO_ERROR_INVALID_FILENAME,
  G_IO_ERROR_TOO_MANY_LINKS,
  G_IO_ERROR_NO_SPACE,
  G_IO_ERROR_INVALID_ARGUMENT,
  G_IO_ERROR_PERMISSION_DENIED,
  G_IO_ERROR_NOT_SUPPORTED,
  G_IO_ERROR_NOT_MOUNTED,
  G_IO_ERROR_ALREADY_MOUNTED,
  G_IO_ERROR_CLOSED,
  G_IO_ERROR_CANCELLED,
  G_IO_ERROR_PENDING,
  G_IO_ERROR_READ_ONLY,
  G_IO_ERROR_CANT_CREATE_BACKUP,
  G_IO_ERROR_WRONG_ETAG,
  G_IO_ERROR_TIMED_OUT,
  G_IO_ERROR_WOULD_RECURSE,
  G_IO_ERROR_BUSY,
  G_IO_ERROR_WOULD_BLOCK,
  G_IO_ERROR_HOST_NOT_FOUND,
  G_IO_ERROR_WOULD_MERGE,
  G_IO_ERROR_FAILED_HANDLED,
  G_IO_ERROR_TOO_MANY_OPEN_FILES,
  G_IO_ERROR_NOT_INITIALIZED,
  G_IO_ERROR_ADDRESS_IN_USE,
  G_IO_ERROR_PARTIAL_INPUT,
  G_IO_ERROR_INVALID_DATA,
  G_IO_ERROR_DBUS_ERROR,
  G_IO_ERROR_HOST_UNREACHABLE,
  G_IO_ERROR_NETWORK_UNREACHABLE,
  G_IO_ERROR_CONNECTION_REFUSED,
  G_IO_ERROR_PROXY_FAILED,
  G_IO_ERROR_PROXY_AUTH_FAILED,
  G_IO_ERROR_PROXY_NEED_AUTH,
  G_IO_ERROR_PROXY_NOT_ALLOWED,
  G_IO_ERROR_BROKEN_PIPE,
  G_IO_ERROR_CONNECTION_CLOSED = G_IO_ERROR_BROKEN_PIPE,
  G_IO_ERROR_NOT_CONNECTED,
  G_IO_ERROR_MESSAGE_TOO_LARGE
} GIOErrorEnum;
</ENUM>
<ENUM>
<NAME>GAskPasswordFlags</NAME>
typedef enum {
  G_ASK_PASSWORD_NEED_PASSWORD           = (1 << 0),
  G_ASK_PASSWORD_NEED_USERNAME           = (1 << 1),
  G_ASK_PASSWORD_NEED_DOMAIN             = (1 << 2),
  G_ASK_PASSWORD_SAVING_SUPPORTED        = (1 << 3),
  G_ASK_PASSWORD_ANONYMOUS_SUPPORTED     = (1 << 4),
  G_ASK_PASSWORD_TCRYPT                  = (1 << 5),
} GAskPasswordFlags;
</ENUM>
<ENUM>
<NAME>GPasswordSave</NAME>
typedef enum {
  G_PASSWORD_SAVE_NEVER,
  G_PASSWORD_SAVE_FOR_SESSION,
  G_PASSWORD_SAVE_PERMANENTLY
} GPasswordSave;
</ENUM>
<ENUM>
<NAME>GMountOperationResult</NAME>
typedef enum {
  G_MOUNT_OPERATION_HANDLED,
  G_MOUNT_OPERATION_ABORTED,
  G_MOUNT_OPERATION_UNHANDLED
} GMountOperationResult;
</ENUM>
<ENUM>
<NAME>GOutputStreamSpliceFlags</NAME>
typedef enum {
  G_OUTPUT_STREAM_SPLICE_NONE         = 0,
  G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE = (1 << 0),
  G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET = (1 << 1)
} GOutputStreamSpliceFlags;
</ENUM>
<ENUM>
<NAME>GIOStreamSpliceFlags</NAME>
typedef enum {
  G_IO_STREAM_SPLICE_NONE          = 0,
  G_IO_STREAM_SPLICE_CLOSE_STREAM1 = (1 << 0),
  G_IO_STREAM_SPLICE_CLOSE_STREAM2 = (1 << 1),
  G_IO_STREAM_SPLICE_WAIT_FOR_BOTH = (1 << 2)
} GIOStreamSpliceFlags;
</ENUM>
<ENUM>
<NAME>GEmblemOrigin</NAME>
typedef enum  {
  G_EMBLEM_ORIGIN_UNKNOWN,
  G_EMBLEM_ORIGIN_DEVICE,
  G_EMBLEM_ORIGIN_LIVEMETADATA,
  G_EMBLEM_ORIGIN_TAG
} GEmblemOrigin;
</ENUM>
<ENUM>
<NAME>GResolverError</NAME>
typedef enum {
  G_RESOLVER_ERROR_NOT_FOUND,
  G_RESOLVER_ERROR_TEMPORARY_FAILURE,
  G_RESOLVER_ERROR_INTERNAL
} GResolverError;
</ENUM>
<ENUM>
<NAME>GResolverRecordType</NAME>
typedef enum {
  G_RESOLVER_RECORD_SRV = 1,
  G_RESOLVER_RECORD_MX,
  G_RESOLVER_RECORD_TXT,
  G_RESOLVER_RECORD_SOA,
  G_RESOLVER_RECORD_NS
} GResolverRecordType;
</ENUM>
<ENUM>
<NAME>GResourceError</NAME>
typedef enum {
  G_RESOURCE_ERROR_NOT_FOUND,
  G_RESOURCE_ERROR_INTERNAL
} GResourceError;
</ENUM>
<ENUM>
<NAME>GResourceFlags</NAME>
typedef enum {
  G_RESOURCE_FLAGS_NONE       = 0,
  G_RESOURCE_FLAGS_COMPRESSED = (1<<0)
} GResourceFlags;
</ENUM>
<ENUM>
<NAME>GResourceLookupFlags</NAME>
typedef enum /*< flags >*/ {
  G_RESOURCE_LOOKUP_FLAGS_NONE       = 0
} GResourceLookupFlags;
</ENUM>
<ENUM>
<NAME>GSocketFamily</NAME>
typedef enum {
  G_SOCKET_FAMILY_INVALID,
  G_SOCKET_FAMILY_UNIX = GLIB_SYSDEF_AF_UNIX,
  G_SOCKET_FAMILY_IPV4 = GLIB_SYSDEF_AF_INET,
  G_SOCKET_FAMILY_IPV6 = GLIB_SYSDEF_AF_INET6
} GSocketFamily;
</ENUM>
<ENUM>
<NAME>GSocketType</NAME>
typedef enum
{
  G_SOCKET_TYPE_INVALID,
  G_SOCKET_TYPE_STREAM,
  G_SOCKET_TYPE_DATAGRAM,
  G_SOCKET_TYPE_SEQPACKET
} GSocketType;
</ENUM>
<ENUM>
<NAME>GSocketMsgFlags</NAME>
typedef enum /*< flags >*/
{
  G_SOCKET_MSG_NONE,
  G_SOCKET_MSG_OOB = GLIB_SYSDEF_MSG_OOB,
  G_SOCKET_MSG_PEEK = GLIB_SYSDEF_MSG_PEEK,
  G_SOCKET_MSG_DONTROUTE = GLIB_SYSDEF_MSG_DONTROUTE
} GSocketMsgFlags;
</ENUM>
<ENUM>
<NAME>GSocketProtocol</NAME>
typedef enum {
  G_SOCKET_PROTOCOL_UNKNOWN = -1,
  G_SOCKET_PROTOCOL_DEFAULT = 0,
  G_SOCKET_PROTOCOL_TCP     = 6,
  G_SOCKET_PROTOCOL_UDP     = 17,
  G_SOCKET_PROTOCOL_SCTP    = 132
} GSocketProtocol;
</ENUM>
<ENUM>
<NAME>GZlibCompressorFormat</NAME>
typedef enum {
  G_ZLIB_COMPRESSOR_FORMAT_ZLIB,
  G_ZLIB_COMPRESSOR_FORMAT_GZIP,
  G_ZLIB_COMPRESSOR_FORMAT_RAW
} GZlibCompressorFormat;
</ENUM>
<ENUM>
<NAME>GUnixSocketAddressType</NAME>
typedef enum {
  G_UNIX_SOCKET_ADDRESS_INVALID,
  G_UNIX_SOCKET_ADDRESS_ANONYMOUS,
  G_UNIX_SOCKET_ADDRESS_PATH,
  G_UNIX_SOCKET_ADDRESS_ABSTRACT,
  G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED
} GUnixSocketAddressType;
</ENUM>
<ENUM>
<NAME>GBusType</NAME>
typedef enum
{
  G_BUS_TYPE_STARTER = -1,
  G_BUS_TYPE_NONE = 0,
  G_BUS_TYPE_SYSTEM  = 1,
  G_BUS_TYPE_SESSION = 2
} GBusType;
</ENUM>
<ENUM>
<NAME>GBusNameOwnerFlags</NAME>
typedef enum
{
  G_BUS_NAME_OWNER_FLAGS_NONE = 0,                    /*< nick=none >*/
  G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT = (1<<0),  /*< nick=allow-replacement >*/
  G_BUS_NAME_OWNER_FLAGS_REPLACE = (1<<1),           /*< nick=replace >*/
  G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE = (1<<2)       /*< nick=do-not-queue >*/
} GBusNameOwnerFlags;
</ENUM>
<ENUM>
<NAME>GBusNameWatcherFlags</NAME>
typedef enum
{
  G_BUS_NAME_WATCHER_FLAGS_NONE = 0,
  G_BUS_NAME_WATCHER_FLAGS_AUTO_START = (1<<0)
} GBusNameWatcherFlags;
</ENUM>
<ENUM>
<NAME>GDBusProxyFlags</NAME>
typedef enum
{
  G_DBUS_PROXY_FLAGS_NONE = 0,
  G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES = (1<<0),
  G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS = (1<<1),
  G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START = (1<<2),
  G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES = (1<<3),
  G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION = (1<<4)
} GDBusProxyFlags;
</ENUM>
<ENUM>
<NAME>GDBusError</NAME>
typedef enum
{
  /* Well-known errors in the org.freedesktop.DBus.Error namespace */
  G_DBUS_ERROR_FAILED,                           /* org.freedesktop.DBus.Error.Failed */
  G_DBUS_ERROR_NO_MEMORY,                        /* org.freedesktop.DBus.Error.NoMemory */
  G_DBUS_ERROR_SERVICE_UNKNOWN,                  /* org.freedesktop.DBus.Error.ServiceUnknown */
  G_DBUS_ERROR_NAME_HAS_NO_OWNER,                /* org.freedesktop.DBus.Error.NameHasNoOwner */
  G_DBUS_ERROR_NO_REPLY,                         /* org.freedesktop.DBus.Error.NoReply */
  G_DBUS_ERROR_IO_ERROR,                         /* org.freedesktop.DBus.Error.IOError */
  G_DBUS_ERROR_BAD_ADDRESS,                      /* org.freedesktop.DBus.Error.BadAddress */
  G_DBUS_ERROR_NOT_SUPPORTED,                    /* org.freedesktop.DBus.Error.NotSupported */
  G_DBUS_ERROR_LIMITS_EXCEEDED,                  /* org.freedesktop.DBus.Error.LimitsExceeded */
  G_DBUS_ERROR_ACCESS_DENIED,                    /* org.freedesktop.DBus.Error.AccessDenied */
  G_DBUS_ERROR_AUTH_FAILED,                      /* org.freedesktop.DBus.Error.AuthFailed */
  G_DBUS_ERROR_NO_SERVER,                        /* org.freedesktop.DBus.Error.NoServer */
  G_DBUS_ERROR_TIMEOUT,                          /* org.freedesktop.DBus.Error.Timeout */
  G_DBUS_ERROR_NO_NETWORK,                       /* org.freedesktop.DBus.Error.NoNetwork */
  G_DBUS_ERROR_ADDRESS_IN_USE,                   /* org.freedesktop.DBus.Error.AddressInUse */
  G_DBUS_ERROR_DISCONNECTED,                     /* org.freedesktop.DBus.Error.Disconnected */
  G_DBUS_ERROR_INVALID_ARGS,                     /* org.freedesktop.DBus.Error.InvalidArgs */
  G_DBUS_ERROR_FILE_NOT_FOUND,                   /* org.freedesktop.DBus.Error.FileNotFound */
  G_DBUS_ERROR_FILE_EXISTS,                      /* org.freedesktop.DBus.Error.FileExists */
  G_DBUS_ERROR_UNKNOWN_METHOD,                   /* org.freedesktop.DBus.Error.UnknownMethod */
  G_DBUS_ERROR_TIMED_OUT,                        /* org.freedesktop.DBus.Error.TimedOut */
  G_DBUS_ERROR_MATCH_RULE_NOT_FOUND,             /* org.freedesktop.DBus.Error.MatchRuleNotFound */
  G_DBUS_ERROR_MATCH_RULE_INVALID,               /* org.freedesktop.DBus.Error.MatchRuleInvalid */
  G_DBUS_ERROR_SPAWN_EXEC_FAILED,                /* org.freedesktop.DBus.Error.Spawn.ExecFailed */
  G_DBUS_ERROR_SPAWN_FORK_FAILED,                /* org.freedesktop.DBus.Error.Spawn.ForkFailed */
  G_DBUS_ERROR_SPAWN_CHILD_EXITED,               /* org.freedesktop.DBus.Error.Spawn.ChildExited */
  G_DBUS_ERROR_SPAWN_CHILD_SIGNALED,             /* org.freedesktop.DBus.Error.Spawn.ChildSignaled */
  G_DBUS_ERROR_SPAWN_FAILED,                     /* org.freedesktop.DBus.Error.Spawn.Failed */
  G_DBUS_ERROR_SPAWN_SETUP_FAILED,               /* org.freedesktop.DBus.Error.Spawn.FailedToSetup */
  G_DBUS_ERROR_SPAWN_CONFIG_INVALID,             /* org.freedesktop.DBus.Error.Spawn.ConfigInvalid */
  G_DBUS_ERROR_SPAWN_SERVICE_INVALID,            /* org.freedesktop.DBus.Error.Spawn.ServiceNotValid */
  G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND,          /* org.freedesktop.DBus.Error.Spawn.ServiceNotFound */
  G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID,        /* org.freedesktop.DBus.Error.Spawn.PermissionsInvalid */
  G_DBUS_ERROR_SPAWN_FILE_INVALID,               /* org.freedesktop.DBus.Error.Spawn.FileInvalid */
  G_DBUS_ERROR_SPAWN_NO_MEMORY,                  /* org.freedesktop.DBus.Error.Spawn.NoMemory */
  G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN,          /* org.freedesktop.DBus.Error.UnixProcessIdUnknown */
  G_DBUS_ERROR_INVALID_SIGNATURE,                /* org.freedesktop.DBus.Error.InvalidSignature */
  G_DBUS_ERROR_INVALID_FILE_CONTENT,             /* org.freedesktop.DBus.Error.InvalidFileContent */
  G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN, /* org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown */
  G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN,           /* org.freedesktop.DBus.Error.AdtAuditDataUnknown */
  G_DBUS_ERROR_OBJECT_PATH_IN_USE,               /* org.freedesktop.DBus.Error.ObjectPathInUse */
  G_DBUS_ERROR_UNKNOWN_OBJECT,                   /* org.freedesktop.DBus.Error.UnknownObject */
  G_DBUS_ERROR_UNKNOWN_INTERFACE,                /* org.freedesktop.DBus.Error.UnknownInterface */
  G_DBUS_ERROR_UNKNOWN_PROPERTY,                 /* org.freedesktop.DBus.Error.UnknownProperty */
  G_DBUS_ERROR_PROPERTY_READ_ONLY                /* org.freedesktop.DBus.Error.PropertyReadOnly */
} GDBusError;
</ENUM>
<ENUM>
<NAME>GDBusConnectionFlags</NAME>
typedef enum {
  G_DBUS_CONNECTION_FLAGS_NONE = 0,
  G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT = (1<<0),
  G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER = (1<<1),
  G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = (1<<2),
  G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION = (1<<3),
  G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING = (1<<4)
} GDBusConnectionFlags;
</ENUM>
<ENUM>
<NAME>GDBusCapabilityFlags</NAME>
typedef enum {
  G_DBUS_CAPABILITY_FLAGS_NONE = 0,
  G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING = (1<<0)
} GDBusCapabilityFlags;
</ENUM>
<ENUM>
<NAME>GDBusCallFlags</NAME>
typedef enum {
  G_DBUS_CALL_FLAGS_NONE = 0,
  G_DBUS_CALL_FLAGS_NO_AUTO_START = (1<<0),
  G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = (1<<1)
} GDBusCallFlags;
</ENUM>
<ENUM>
<NAME>GDBusMessageType</NAME>
typedef enum {
  G_DBUS_MESSAGE_TYPE_INVALID,
  G_DBUS_MESSAGE_TYPE_METHOD_CALL,
  G_DBUS_MESSAGE_TYPE_METHOD_RETURN,
  G_DBUS_MESSAGE_TYPE_ERROR,
  G_DBUS_MESSAGE_TYPE_SIGNAL
} GDBusMessageType;
</ENUM>
<ENUM>
<NAME>GDBusMessageFlags</NAME>
typedef enum {
  G_DBUS_MESSAGE_FLAGS_NONE = 0,
  G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED = (1<<0),
  G_DBUS_MESSAGE_FLAGS_NO_AUTO_START = (1<<1),
  G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = (1<<2)
} GDBusMessageFlags;
</ENUM>
<ENUM>
<NAME>GDBusMessageHeaderField</NAME>
typedef enum {
  G_DBUS_MESSAGE_HEADER_FIELD_INVALID,
  G_DBUS_MESSAGE_HEADER_FIELD_PATH,
  G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE,
  G_DBUS_MESSAGE_HEADER_FIELD_MEMBER,
  G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME,
  G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL,
  G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION,
  G_DBUS_MESSAGE_HEADER_FIELD_SENDER,
  G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE,
  G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS
} GDBusMessageHeaderField;
</ENUM>
<ENUM>
<NAME>GDBusPropertyInfoFlags</NAME>
typedef enum
{
  G_DBUS_PROPERTY_INFO_FLAGS_NONE = 0,
  G_DBUS_PROPERTY_INFO_FLAGS_READABLE = (1<<0),
  G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE = (1<<1)
} GDBusPropertyInfoFlags;
</ENUM>
<ENUM>
<NAME>GDBusSubtreeFlags</NAME>
typedef enum
{
  G_DBUS_SUBTREE_FLAGS_NONE = 0,
  G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES = (1<<0)
} GDBusSubtreeFlags;
</ENUM>
<ENUM>
<NAME>GDBusServerFlags</NAME>
typedef enum
{
  G_DBUS_SERVER_FLAGS_NONE = 0,
  G_DBUS_SERVER_FLAGS_RUN_IN_THREAD = (1<<0),
  G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = (1<<1)
} GDBusServerFlags;
</ENUM>
<ENUM>
<NAME>GDBusSignalFlags</NAME>
typedef enum /*< flags >*/
{
  G_DBUS_SIGNAL_FLAGS_NONE = 0,
  G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE = (1<<0),
  G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE = (1<<1),
  G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH = (1<<2)
} GDBusSignalFlags;
</ENUM>
<ENUM>
<NAME>GDBusSendMessageFlags</NAME>
typedef enum
{
  G_DBUS_SEND_MESSAGE_FLAGS_NONE = 0,
  G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL = (1<<0)
} GDBusSendMessageFlags;
</ENUM>
<ENUM>
<NAME>GCredentialsType</NAME>
typedef enum
{
  G_CREDENTIALS_TYPE_INVALID,
  G_CREDENTIALS_TYPE_LINUX_UCRED,
  G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED,
  G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED,
  G_CREDENTIALS_TYPE_SOLARIS_UCRED,
  G_CREDENTIALS_TYPE_NETBSD_UNPCBID
} GCredentialsType;
</ENUM>
<ENUM>
<NAME>GDBusMessageByteOrder</NAME>
typedef enum
{
  G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN    = 'B',
  G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN = 'l'
} GDBusMessageByteOrder;
</ENUM>
<ENUM>
<NAME>GApplicationFlags</NAME>
typedef enum
{
  G_APPLICATION_FLAGS_NONE,
  G_APPLICATION_IS_SERVICE  =          (1 << 0),
  G_APPLICATION_IS_LAUNCHER =          (1 << 1),

  G_APPLICATION_HANDLES_OPEN =         (1 << 2),
  G_APPLICATION_HANDLES_COMMAND_LINE = (1 << 3),
  G_APPLICATION_SEND_ENVIRONMENT    =  (1 << 4),

  G_APPLICATION_NON_UNIQUE =           (1 << 5),

  G_APPLICATION_CAN_OVERRIDE_APP_ID =  (1 << 6)
} GApplicationFlags;
</ENUM>
<ENUM>
<NAME>GTlsError</NAME>
typedef enum {
  G_TLS_ERROR_UNAVAILABLE,
  G_TLS_ERROR_MISC,
  G_TLS_ERROR_BAD_CERTIFICATE,
  G_TLS_ERROR_NOT_TLS,
  G_TLS_ERROR_HANDSHAKE,
  G_TLS_ERROR_CERTIFICATE_REQUIRED,
  G_TLS_ERROR_EOF
} GTlsError;
</ENUM>
<ENUM>
<NAME>GTlsCertificateFlags</NAME>
typedef enum {
  G_TLS_CERTIFICATE_UNKNOWN_CA    = (1 << 0),
  G_TLS_CERTIFICATE_BAD_IDENTITY  = (1 << 1),
  G_TLS_CERTIFICATE_NOT_ACTIVATED = (1 << 2),
  G_TLS_CERTIFICATE_EXPIRED       = (1 << 3),
  G_TLS_CERTIFICATE_REVOKED       = (1 << 4),
  G_TLS_CERTIFICATE_INSECURE      = (1 << 5),
  G_TLS_CERTIFICATE_GENERIC_ERROR = (1 << 6),

  G_TLS_CERTIFICATE_VALIDATE_ALL  = 0x007f
} GTlsCertificateFlags;
</ENUM>
<ENUM>
<NAME>GTlsAuthenticationMode</NAME>
typedef enum {
  G_TLS_AUTHENTICATION_NONE,
  G_TLS_AUTHENTICATION_REQUESTED,
  G_TLS_AUTHENTICATION_REQUIRED
} GTlsAuthenticationMode;
</ENUM>
<ENUM>
<NAME>GTlsRehandshakeMode</NAME>
typedef enum {
  G_TLS_REHANDSHAKE_NEVER,
  G_TLS_REHANDSHAKE_SAFELY,
  G_TLS_REHANDSHAKE_UNSAFELY
} GTlsRehandshakeMode;
</ENUM>
<ENUM>
<NAME>GTlsPasswordFlags</NAME>
typedef enum _GTlsPasswordFlags
{
  G_TLS_PASSWORD_NONE = 0,
  G_TLS_PASSWORD_RETRY = 1 << 1,
  G_TLS_PASSWORD_MANY_TRIES = 1 << 2,
  G_TLS_PASSWORD_FINAL_TRY = 1 << 3
} GTlsPasswordFlags;
</ENUM>
<ENUM>
<NAME>GTlsInteractionResult</NAME>
typedef enum {
  G_TLS_INTERACTION_UNHANDLED,
  G_TLS_INTERACTION_HANDLED,
  G_TLS_INTERACTION_FAILED
} GTlsInteractionResult;
</ENUM>
<ENUM>
<NAME>GDBusInterfaceSkeletonFlags</NAME>
typedef enum
{
  G_DBUS_INTERFACE_SKELETON_FLAGS_NONE = 0,
  G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD = (1<<0)
} GDBusInterfaceSkeletonFlags;
</ENUM>
<ENUM>
<NAME>GDBusObjectManagerClientFlags</NAME>
typedef enum
{
  G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE = 0,
  G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START = (1<<0)
} GDBusObjectManagerClientFlags;
</ENUM>
<ENUM>
<NAME>GTlsDatabaseVerifyFlags</NAME>
typedef enum /*< flags >*/ {
  G_TLS_DATABASE_VERIFY_NONE = 0
} GTlsDatabaseVerifyFlags;
</ENUM>
<ENUM>
<NAME>GTlsDatabaseLookupFlags</NAME>
typedef enum {
  G_TLS_DATABASE_LOOKUP_NONE = 0,
  G_TLS_DATABASE_LOOKUP_KEYPAIR = 1
} GTlsDatabaseLookupFlags;
</ENUM>
<ENUM>
<NAME>GTlsCertificateRequestFlags</NAME>
typedef enum {
  G_TLS_CERTIFICATE_REQUEST_NONE = 0
} GTlsCertificateRequestFlags;
</ENUM>
<ENUM>
<NAME>GIOModuleScopeFlags</NAME>
typedef enum {
  G_IO_MODULE_SCOPE_NONE,
  G_IO_MODULE_SCOPE_BLOCK_DUPLICATES
} GIOModuleScopeFlags;
</ENUM>
<ENUM>
<NAME>GSocketClientEvent</NAME>
typedef enum {
  G_SOCKET_CLIENT_RESOLVING,
  G_SOCKET_CLIENT_RESOLVED,
  G_SOCKET_CLIENT_CONNECTING,
  G_SOCKET_CLIENT_CONNECTED,
  G_SOCKET_CLIENT_PROXY_NEGOTIATING,
  G_SOCKET_CLIENT_PROXY_NEGOTIATED,
  G_SOCKET_CLIENT_TLS_HANDSHAKING,
  G_SOCKET_CLIENT_TLS_HANDSHAKED,
  G_SOCKET_CLIENT_COMPLETE
} GSocketClientEvent;
</ENUM>
<ENUM>
<NAME>GSocketListenerEvent</NAME>
typedef enum {
  G_SOCKET_LISTENER_BINDING,
  G_SOCKET_LISTENER_BOUND,
  G_SOCKET_LISTENER_LISTENING,
  G_SOCKET_LISTENER_LISTENED
} GSocketListenerEvent;
</ENUM>
<ENUM>
<NAME>GTestDBusFlags</NAME>
typedef enum /*< flags >*/ {
  G_TEST_DBUS_NONE = 0
} GTestDBusFlags;
</ENUM>
<ENUM>
<NAME>GSubprocessFlags</NAME>
typedef enum {
  G_SUBPROCESS_FLAGS_NONE                  = 0,
  G_SUBPROCESS_FLAGS_STDIN_PIPE            = (1u << 0),
  G_SUBPROCESS_FLAGS_STDIN_INHERIT         = (1u << 1),
  G_SUBPROCESS_FLAGS_STDOUT_PIPE           = (1u << 2),
  G_SUBPROCESS_FLAGS_STDOUT_SILENCE        = (1u << 3),
  G_SUBPROCESS_FLAGS_STDERR_PIPE           = (1u << 4),
  G_SUBPROCESS_FLAGS_STDERR_SILENCE        = (1u << 5),
  G_SUBPROCESS_FLAGS_STDERR_MERGE          = (1u << 6),
  G_SUBPROCESS_FLAGS_INHERIT_FDS           = (1u << 7)
} GSubprocessFlags;
</ENUM>
<ENUM>
<NAME>GNotificationPriority</NAME>
typedef enum {
  G_NOTIFICATION_PRIORITY_NORMAL,
  G_NOTIFICATION_PRIORITY_LOW,
  G_NOTIFICATION_PRIORITY_HIGH,
  G_NOTIFICATION_PRIORITY_URGENT
} GNotificationPriority;
</ENUM>
<ENUM>
<NAME>GNetworkConnectivity</NAME>
typedef enum {
  G_NETWORK_CONNECTIVITY_LOCAL       = 1,
  G_NETWORK_CONNECTIVITY_LIMITED     = 2,
  G_NETWORK_CONNECTIVITY_PORTAL      = 3,
  G_NETWORK_CONNECTIVITY_FULL        = 4
} GNetworkConnectivity;
</ENUM>
<MACRO>
<NAME>G_IO_ERROR</NAME>
#define G_IO_ERROR g_io_error_quark()
</MACRO>
<FUNCTION>
<NAME>g_io_error_quark</NAME>
<RETURNS>GQuark        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_io_error_from_errno</NAME>
<RETURNS>GIOErrorEnum  </RETURNS>
gint err_no
</FUNCTION>
<FUNCTION>
<NAME>g_io_error_from_win32_error</NAME>
<RETURNS>GIOErrorEnum  </RETURNS>
gint error_code
</FUNCTION>
<FUNCTION>
<NAME>g_io_module_scope_new</NAME>
<RETURNS>GIOModuleScope  *   </RETURNS>
GIOModuleScopeFlags  flags
</FUNCTION>
<FUNCTION>
<NAME>g_io_module_scope_free</NAME>
<RETURNS>void                </RETURNS>
GIOModuleScope      *scope
</FUNCTION>
<FUNCTION>
<NAME>g_io_module_scope_block</NAME>
<RETURNS>void                </RETURNS>
GIOModuleScope      *scope, const gchar         *basename
</FUNCTION>
<MACRO>
<NAME>G_IO_TYPE_MODULE</NAME>
#define G_IO_TYPE_MODULE         (g_io_module_get_type ())
</MACRO>
<MACRO>
<NAME>G_IO_MODULE</NAME>
#define G_IO_MODULE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_IO_TYPE_MODULE, GIOModule))
</MACRO>
<MACRO>
<NAME>G_IO_MODULE_CLASS</NAME>
#define G_IO_MODULE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_IO_TYPE_MODULE, GIOModuleClass))
</MACRO>
<MACRO>
<NAME>G_IO_IS_MODULE</NAME>
#define G_IO_IS_MODULE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_IO_TYPE_MODULE))
</MACRO>
<MACRO>
<NAME>G_IO_IS_MODULE_CLASS</NAME>
#define G_IO_IS_MODULE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_IO_TYPE_MODULE))
</MACRO>
<MACRO>
<NAME>G_IO_MODULE_GET_CLASS</NAME>
#define G_IO_MODULE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_IO_TYPE_MODULE, GIOModuleClass))
</MACRO>
<FUNCTION>
<NAME>g_io_module_get_type</NAME>
<RETURNS>GType               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_io_module_new</NAME>
<RETURNS>GIOModule          *</RETURNS>
const gchar       *filename
</FUNCTION>
<FUNCTION>
<NAME>g_io_modules_scan_all_in_directory</NAME>
<RETURNS>void                </RETURNS>
const char        *dirname
</FUNCTION>
<FUNCTION>
<NAME>g_io_modules_load_all_in_directory</NAME>
<RETURNS>GList              *</RETURNS>
const gchar       *dirname
</FUNCTION>
<FUNCTION>
<NAME>g_io_modules_scan_all_in_directory_with_scope</NAME>
<RETURNS>void                </RETURNS>
const gchar       *dirname, GIOModuleScope    *scope
</FUNCTION>
<FUNCTION>
<NAME>g_io_modules_load_all_in_directory_with_scope</NAME>
<RETURNS>GList              *</RETURNS>
const gchar       *dirname, GIOModuleScope    *scope
</FUNCTION>
<FUNCTION>
<NAME>g_io_extension_point_register</NAME>
<RETURNS>GIOExtensionPoint  *</RETURNS>
const char        *name
</FUNCTION>
<FUNCTION>
<NAME>g_io_extension_point_lookup</NAME>
<RETURNS>GIOExtensionPoint  *</RETURNS>
const char        *name
</FUNCTION>
<FUNCTION>
<NAME>g_io_extension_point_set_required_type</NAME>
<RETURNS>void                </RETURNS>
GIOExtensionPoint *extension_point, GType              type
</FUNCTION>
<FUNCTION>
<NAME>g_io_extension_point_get_required_type</NAME>
<RETURNS>GType               </RETURNS>
GIOExtensionPoint *extension_point
</FUNCTION>
<FUNCTION>
<NAME>g_io_extension_point_get_extensions</NAME>
<RETURNS>GList              *</RETURNS>
GIOExtensionPoint *extension_point
</FUNCTION>
<FUNCTION>
<NAME>g_io_extension_point_get_extension_by_name</NAME>
<RETURNS>GIOExtension  *     </RETURNS>
GIOExtensionPoint *extension_point, const char        *name
</FUNCTION>
<FUNCTION>
<NAME>g_io_extension_point_implement</NAME>
<RETURNS>GIOExtension  *     </RETURNS>
const char        *extension_point_name, GType              type, const char        *extension_name, gint               priority
</FUNCTION>
<FUNCTION>
<NAME>g_io_extension_get_type</NAME>
<RETURNS>GType               </RETURNS>
GIOExtension      *extension
</FUNCTION>
<FUNCTION>
<NAME>g_io_extension_get_name</NAME>
<RETURNS>const char  *       </RETURNS>
GIOExtension      *extension
</FUNCTION>
<FUNCTION>
<NAME>g_io_extension_get_priority</NAME>
<RETURNS>gint                </RETURNS>
GIOExtension      *extension
</FUNCTION>
<FUNCTION>
<NAME>g_io_extension_ref_class</NAME>
<RETURNS>GTypeClass *        </RETURNS>
GIOExtension      *extension
</FUNCTION>
<FUNCTION>
<NAME>g_io_module_load</NAME>
<RETURNS>void    </RETURNS>
GIOModule *module
</FUNCTION>
<FUNCTION>
<NAME>g_io_module_unload</NAME>
<RETURNS>void    </RETURNS>
GIOModule *module
</FUNCTION>
<FUNCTION>
<NAME>g_io_module_query</NAME>
<RETURNS>char  **</RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GIOModuleClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GIOModuleScope</NAME>
</STRUCT>
<FUNCTION>
<NAME>g_io_scheduler_push_job</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GIOSchedulerJobFunc  job_func, gpointer             user_data, GDestroyNotify       notify, gint                 io_priority, GCancellable        *cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_io_scheduler_cancel_all_jobs</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_io_scheduler_job_send_to_mainloop</NAME>
<DEPRECATED/>
<RETURNS>gboolean  </RETURNS>
GIOSchedulerJob     *job, GSourceFunc          func, gpointer             user_data, GDestroyNotify       notify
</FUNCTION>
<FUNCTION>
<NAME>g_io_scheduler_job_send_to_mainloop_async</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GIOSchedulerJob     *job, GSourceFunc          func, gpointer             user_data, GDestroyNotify       notify
</FUNCTION>
<MACRO>
<NAME>G_TYPE_IO_STREAM</NAME>
#define G_TYPE_IO_STREAM         (g_io_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_IO_STREAM</NAME>
#define G_IO_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_IO_STREAM, GIOStream))
</MACRO>
<MACRO>
<NAME>G_IO_STREAM_CLASS</NAME>
#define G_IO_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_IO_STREAM, GIOStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_IO_STREAM</NAME>
#define G_IS_IO_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_IO_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_IO_STREAM_CLASS</NAME>
#define G_IS_IO_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_IO_STREAM))
</MACRO>
<MACRO>
<NAME>G_IO_STREAM_GET_CLASS</NAME>
#define G_IO_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_IO_STREAM, GIOStreamClass))
</MACRO>
<STRUCT>
<NAME>GIOStream</NAME>
struct _GIOStream
{
  GObject parent_instance;

  /*< private >*/
  GIOStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GIOStreamClass</NAME>
struct _GIOStreamClass
{
  GObjectClass parent_class;

  GInputStream *  (*get_input_stream)  (GIOStream *stream);
  GOutputStream * (*get_output_stream) (GIOStream *stream);

  gboolean (* close_fn)	    (GIOStream           *stream,
                             GCancellable        *cancellable,
                             GError             **error);
  void     (* close_async)  (GIOStream           *stream,
                             int                  io_priority,
                             GCancellable        *cancellable,
                             GAsyncReadyCallback  callback,
                             gpointer             user_data);
  gboolean (* close_finish) (GIOStream           *stream,
                             GAsyncResult        *result,
                             GError             **error);
  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
  void (*_g_reserved7) (void);
  void (*_g_reserved8) (void);
  void (*_g_reserved9) (void);
  void (*_g_reserved10) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_io_stream_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_io_stream_get_input_stream</NAME>
<RETURNS>GInputStream  * </RETURNS>
GIOStream            *stream
</FUNCTION>
<FUNCTION>
<NAME>g_io_stream_get_output_stream</NAME>
<RETURNS>GOutputStream  *</RETURNS>
GIOStream            *stream
</FUNCTION>
<FUNCTION>
<NAME>g_io_stream_splice_async</NAME>
<RETURNS>void            </RETURNS>
GIOStream            *stream1, GIOStream            *stream2, GIOStreamSpliceFlags  flags, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_io_stream_splice_finish</NAME>
<RETURNS>gboolean        </RETURNS>
GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_io_stream_close</NAME>
<RETURNS>gboolean        </RETURNS>
GIOStream            *stream, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_io_stream_close_async</NAME>
<RETURNS>void            </RETURNS>
GIOStream            *stream, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_io_stream_close_finish</NAME>
<RETURNS>gboolean        </RETURNS>
GIOStream            *stream, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_io_stream_is_closed</NAME>
<RETURNS>gboolean        </RETURNS>
GIOStream            *stream
</FUNCTION>
<FUNCTION>
<NAME>g_io_stream_has_pending</NAME>
<RETURNS>gboolean        </RETURNS>
GIOStream            *stream
</FUNCTION>
<FUNCTION>
<NAME>g_io_stream_set_pending</NAME>
<RETURNS>gboolean        </RETURNS>
GIOStream            *stream, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_io_stream_clear_pending</NAME>
<RETURNS>void            </RETURNS>
GIOStream            *stream
</FUNCTION>
<STRUCT>
<NAME>GIOStreamPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GAsyncReadyCallback</NAME>
<RETURNS>void </RETURNS>
GObject *source_object,
				     GAsyncResult *res,
				     gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GFileProgressCallback</NAME>
<RETURNS>void </RETURNS>
goffset current_num_bytes,
                                       goffset total_num_bytes,
                                       gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GFileReadMoreCallback</NAME>
<RETURNS>gboolean </RETURNS>
const char *file_contents,
                                            goffset file_size,
                                            gpointer callback_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GFileMeasureProgressCallback</NAME>
<RETURNS>void </RETURNS>
gboolean reporting,
                                               guint64  current_size,
                                               guint64  num_dirs,
                                               guint64  num_files,
                                               gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GIOSchedulerJobFunc</NAME>
<RETURNS>gboolean </RETURNS>
GIOSchedulerJob *job,
					 GCancellable    *cancellable,
					 gpointer         user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GSimpleAsyncThreadFunc</NAME>
<RETURNS>void </RETURNS>
GSimpleAsyncResult *res,
                                        GObject *object,
                                        GCancellable *cancellable
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GSocketSourceFunc</NAME>
<RETURNS>gboolean </RETURNS>
GSocket *socket,
				       GIOCondition condition,
				       gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GDatagramBasedSourceFunc</NAME>
<RETURNS>gboolean </RETURNS>
GDatagramBased *datagram_based,
                                              GIOCondition    condition,
                                              gpointer        user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GInputVector</NAME>
struct _GInputVector {
  gpointer buffer;
  gsize size;
};
</STRUCT>
<STRUCT>
<NAME>GInputMessage</NAME>
struct _GInputMessage {
  GSocketAddress         **address;

  GInputVector            *vectors;
  guint                    num_vectors;

  gsize                    bytes_received;
  gint                     flags;

  GSocketControlMessage ***control_messages;
  guint                   *num_control_messages;
};
</STRUCT>
<STRUCT>
<NAME>GOutputVector</NAME>
struct _GOutputVector {
  gconstpointer buffer;
  gsize size;
};
</STRUCT>
<STRUCT>
<NAME>GOutputMessage</NAME>
struct _GOutputMessage {
  GSocketAddress         *address;

  GOutputVector          *vectors;
  guint                   num_vectors;

  guint                   bytes_sent;

  GSocketControlMessage **control_messages;
  guint                   num_control_messages;
};
</STRUCT>
<USER_FUNCTION>
<NAME>GCancellableSourceFunc</NAME>
<RETURNS>gboolean </RETURNS>
GCancellable *cancellable,
					    gpointer      user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GPollableSourceFunc</NAME>
<RETURNS>gboolean </RETURNS>
GObject  *pollable_stream,
					 gpointer  user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GDBusProxyTypeFunc</NAME>
<RETURNS>GType </RETURNS>
GDBusObjectManagerClient   *manager,
                                     const gchar                *object_path,
                                     const gchar                *interface_name,
                                     gpointer                    user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GAction</NAME>
</STRUCT>
<STRUCT>
<NAME>GActionGroup</NAME>
</STRUCT>
<STRUCT>
<NAME>GActionMap</NAME>
</STRUCT>
<STRUCT>
<NAME>GAppInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GAppLaunchContext</NAME>
</STRUCT>
<STRUCT>
<NAME>GApplication</NAME>
</STRUCT>
<STRUCT>
<NAME>GApplicationCommandLine</NAME>
</STRUCT>
<STRUCT>
<NAME>GAsyncInitable</NAME>
</STRUCT>
<STRUCT>
<NAME>GAsyncResult</NAME>
</STRUCT>
<STRUCT>
<NAME>GBufferedInputStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GBufferedOutputStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GBytesIcon</NAME>
</STRUCT>
<STRUCT>
<NAME>GCancellable</NAME>
</STRUCT>
<STRUCT>
<NAME>GCharsetConverter</NAME>
</STRUCT>
<STRUCT>
<NAME>GConverter</NAME>
</STRUCT>
<STRUCT>
<NAME>GConverterInputStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GConverterOutputStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GCredentials</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusActionGroup</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusAnnotationInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusArgInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusAuthObserver</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusConnection</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusErrorEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusInterface</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusInterfaceInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusInterfaceSkeleton</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusInterfaceVTable</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusMessage</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusMethodInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusMethodInvocation</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusNodeInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusObject</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusObjectManager</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusObjectManagerClient</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusObjectManagerServer</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusObjectProxy</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusObjectSkeleton</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusPropertyInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusProxy</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusServer</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusSignalInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GDBusSubtreeVTable</NAME>
</STRUCT>
<STRUCT>
<NAME>GDataInputStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GDatagramBased</NAME>
</STRUCT>
<STRUCT>
<NAME>GDrive</NAME>
</STRUCT>
<STRUCT>
<NAME>GDtlsClientConnection</NAME>
</STRUCT>
<STRUCT>
<NAME>GDtlsConnection</NAME>
</STRUCT>
<STRUCT>
<NAME>GDtlsServerConnection</NAME>
</STRUCT>
<STRUCT>
<NAME>GFile</NAME>
</STRUCT>
<STRUCT>
<NAME>GFileAttributeInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GFileAttributeInfoList</NAME>
</STRUCT>
<STRUCT>
<NAME>GFileAttributeMatcher</NAME>
</STRUCT>
<STRUCT>
<NAME>GFileDescriptorBased</NAME>
</STRUCT>
<STRUCT>
<NAME>GFileEnumerator</NAME>
</STRUCT>
<STRUCT>
<NAME>GFileIOStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GFileIcon</NAME>
</STRUCT>
<STRUCT>
<NAME>GFileInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GFileInputStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GFileMonitor</NAME>
</STRUCT>
<STRUCT>
<NAME>GFileOutputStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GFilenameCompleter</NAME>
</STRUCT>
<STRUCT>
<NAME>GFilterInputStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GFilterOutputStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GIOExtension</NAME>
</STRUCT>
<STRUCT>
<NAME>GIOExtensionPoint</NAME>
</STRUCT>
<STRUCT>
<NAME>GIOModule</NAME>
</STRUCT>
<STRUCT>
<NAME>GIOSchedulerJob</NAME>
</STRUCT>
<STRUCT>
<NAME>GIOStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GIOStreamAdapter</NAME>
</STRUCT>
<STRUCT>
<NAME>GIcon</NAME>
</STRUCT>
<STRUCT>
<NAME>GInetAddress</NAME>
</STRUCT>
<STRUCT>
<NAME>GInetAddressMask</NAME>
</STRUCT>
<STRUCT>
<NAME>GInetSocketAddress</NAME>
</STRUCT>
<STRUCT>
<NAME>GInitable</NAME>
</STRUCT>
<STRUCT>
<NAME>GInputStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GLoadableIcon</NAME>
</STRUCT>
<STRUCT>
<NAME>GMemoryInputStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GMemoryOutputStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GMenuModel</NAME>
</STRUCT>
<STRUCT>
<NAME>GMount</NAME>
</STRUCT>
<STRUCT>
<NAME>GMountOperation</NAME>
</STRUCT>
<STRUCT>
<NAME>GNativeSocketAddress</NAME>
</STRUCT>
<STRUCT>
<NAME>GNetworkAddress</NAME>
</STRUCT>
<STRUCT>
<NAME>GNetworkMonitor</NAME>
</STRUCT>
<STRUCT>
<NAME>GNetworkService</NAME>
</STRUCT>
<STRUCT>
<NAME>GNotification</NAME>
</STRUCT>
<STRUCT>
<NAME>GOutputStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GPermission</NAME>
</STRUCT>
<STRUCT>
<NAME>GPollableInputStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GPollableOutputStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GPropertyAction</NAME>
</STRUCT>
<STRUCT>
<NAME>GProxy</NAME>
</STRUCT>
<STRUCT>
<NAME>GProxyAddress</NAME>
</STRUCT>
<STRUCT>
<NAME>GProxyAddressEnumerator</NAME>
</STRUCT>
<STRUCT>
<NAME>GProxyResolver</NAME>
</STRUCT>
<STRUCT>
<NAME>GRemoteActionGroup</NAME>
</STRUCT>
<STRUCT>
<NAME>GResolver</NAME>
</STRUCT>
<STRUCT>
<NAME>GResource</NAME>
</STRUCT>
<STRUCT>
<NAME>GSeekable</NAME>
</STRUCT>
<STRUCT>
<NAME>GSettings</NAME>
</STRUCT>
<STRUCT>
<NAME>GSettingsBackend</NAME>
</STRUCT>
<STRUCT>
<NAME>GSimpleAction</NAME>
</STRUCT>
<STRUCT>
<NAME>GSimpleActionGroup</NAME>
</STRUCT>
<STRUCT>
<NAME>GSimpleAsyncResult</NAME>
</STRUCT>
<STRUCT>
<NAME>GSimpleIOStream</NAME>
</STRUCT>
<STRUCT>
<NAME>GSimplePermission</NAME>
</STRUCT>
<STRUCT>
<NAME>GSocket</NAME>
</STRUCT>
<STRUCT>
<NAME>GSocketAddress</NAME>
</STRUCT>
<STRUCT>
<NAME>GSocketAddressEnumerator</NAME>
</STRUCT>
<STRUCT>
<NAME>GSocketClient</NAME>
</STRUCT>
<STRUCT>
<NAME>GSocketConnectable</NAME>
</STRUCT>
<STRUCT>
<NAME>GSocketConnection</NAME>
</STRUCT>
<STRUCT>
<NAME>GSocketControlMessage</NAME>
</STRUCT>
<STRUCT>
<NAME>GSocketListener</NAME>
</STRUCT>
<STRUCT>
<NAME>GSocketService</NAME>
</STRUCT>
<STRUCT>
<NAME>GSrvTarget</NAME>
</STRUCT>
<STRUCT>
<NAME>GSubprocess</NAME>
</STRUCT>
<STRUCT>
<NAME>GSubprocessLauncher</NAME>
</STRUCT>
<STRUCT>
<NAME>GTask</NAME>
</STRUCT>
<STRUCT>
<NAME>GTcpConnection</NAME>
</STRUCT>
<STRUCT>
<NAME>GTcpWrapperConnection</NAME>
</STRUCT>
<STRUCT>
<NAME>GTestDBus</NAME>
</STRUCT>
<STRUCT>
<NAME>GThemedIcon</NAME>
</STRUCT>
<STRUCT>
<NAME>GThreadedSocketService</NAME>
</STRUCT>
<STRUCT>
<NAME>GTlsCertificate</NAME>
</STRUCT>
<STRUCT>
<NAME>GTlsClientConnection</NAME>
</STRUCT>
<STRUCT>
<NAME>GTlsConnection</NAME>
</STRUCT>
<STRUCT>
<NAME>GTlsDatabase</NAME>
</STRUCT>
<STRUCT>
<NAME>GTlsFileDatabase</NAME>
</STRUCT>
<STRUCT>
<NAME>GTlsInteraction</NAME>
</STRUCT>
<STRUCT>
<NAME>GTlsPassword</NAME>
</STRUCT>
<STRUCT>
<NAME>GTlsServerConnection</NAME>
</STRUCT>
<STRUCT>
<NAME>GUnixCredentialsMessage</NAME>
</STRUCT>
<STRUCT>
<NAME>GUnixFDList</NAME>
</STRUCT>
<STRUCT>
<NAME>GVfs</NAME>
</STRUCT>
<STRUCT>
<NAME>GVolume</NAME>
</STRUCT>
<STRUCT>
<NAME>GVolumeMonitor</NAME>
</STRUCT>
<STRUCT>
<NAME>GZlibCompressor</NAME>
</STRUCT>
<STRUCT>
<NAME>GZlibDecompressor</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_LIST_MODEL</NAME>
#define G_TYPE_LIST_MODEL g_list_model_get_type ()
</MACRO>
<STRUCT>
<NAME>GListModelInterface</NAME>
struct _GListModelInterface
{
  GTypeInterface g_iface;

  GType     (* get_item_type)   (GListModel *list);

  guint     (* get_n_items)     (GListModel *list);

  gpointer  (* get_item)        (GListModel *list,
                                 guint       position);
};
</STRUCT>
<FUNCTION>
<NAME>g_list_model_get_item_type</NAME>
<RETURNS>GType                    </RETURNS>
GListModel *list
</FUNCTION>
<FUNCTION>
<NAME>g_list_model_get_n_items</NAME>
<RETURNS>guint                    </RETURNS>
GListModel *list
</FUNCTION>
<FUNCTION>
<NAME>g_list_model_get_item</NAME>
<RETURNS>gpointer                 </RETURNS>
GListModel *list, guint       position
</FUNCTION>
<FUNCTION>
<NAME>g_list_model_get_object</NAME>
<RETURNS>GObject  *               </RETURNS>
GListModel *list, guint       position
</FUNCTION>
<FUNCTION>
<NAME>g_list_model_items_changed</NAME>
<RETURNS>void                     </RETURNS>
GListModel *list, guint       position, guint       removed, guint       added
</FUNCTION>
<STRUCT>
<NAME>GListModel</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_LIST_STORE</NAME>
#define G_TYPE_LIST_STORE (g_list_store_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_list_store_new</NAME>
<RETURNS>GListStore  *            </RETURNS>
GType       item_type
</FUNCTION>
<FUNCTION>
<NAME>g_list_store_insert</NAME>
<RETURNS>void                     </RETURNS>
GListStore *store, guint       position, gpointer    item
</FUNCTION>
<FUNCTION>
<NAME>g_list_store_insert_sorted</NAME>
<RETURNS>guint                    </RETURNS>
GListStore       *store, gpointer          item, GCompareDataFunc  compare_func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_list_store_sort</NAME>
<RETURNS>void                    </RETURNS>
GListStore       *store, GCompareDataFunc  compare_func, gpointer          user_data
</FUNCTION>
<FUNCTION>
<NAME>g_list_store_append</NAME>
<RETURNS>void                     </RETURNS>
GListStore *store, gpointer    item
</FUNCTION>
<FUNCTION>
<NAME>g_list_store_remove</NAME>
<RETURNS>void                     </RETURNS>
GListStore *store, guint       position
</FUNCTION>
<FUNCTION>
<NAME>g_list_store_remove_all</NAME>
<RETURNS>void                     </RETURNS>
GListStore *store
</FUNCTION>
<FUNCTION>
<NAME>g_list_store_splice</NAME>
<RETURNS>void                     </RETURNS>
GListStore *store, guint       position, guint       n_removals, gpointer   *additions, guint       n_additions
</FUNCTION>
<STRUCT>
<NAME>GListStore</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_LOADABLE_ICON</NAME>
#define G_TYPE_LOADABLE_ICON            (g_loadable_icon_get_type ())
</MACRO>
<MACRO>
<NAME>G_LOADABLE_ICON</NAME>
#define G_LOADABLE_ICON(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_LOADABLE_ICON, GLoadableIcon))
</MACRO>
<MACRO>
<NAME>G_IS_LOADABLE_ICON</NAME>
#define G_IS_LOADABLE_ICON(obj)	        (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_LOADABLE_ICON))
</MACRO>
<MACRO>
<NAME>G_LOADABLE_ICON_GET_IFACE</NAME>
#define G_LOADABLE_ICON_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_LOADABLE_ICON, GLoadableIconIface))
</MACRO>
<STRUCT>
<NAME>GLoadableIconIface</NAME>
struct _GLoadableIconIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  GInputStream * (* load)        (GLoadableIcon       *icon,
                                  int                  size,
                                  char               **type,
                                  GCancellable        *cancellable,
                                  GError             **error);
  void           (* load_async)  (GLoadableIcon       *icon,
                                  int                  size,
                                  GCancellable        *cancellable,
                                  GAsyncReadyCallback  callback,
                                  gpointer             user_data);
  GInputStream * (* load_finish) (GLoadableIcon       *icon,
                                  GAsyncResult        *res,
                                  char               **type,
                                  GError             **error);
};
</STRUCT>
<FUNCTION>
<NAME>g_loadable_icon_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_loadable_icon_load</NAME>
<RETURNS>GInputStream  *</RETURNS>
GLoadableIcon        *icon, int                   size, char                **type, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_loadable_icon_load_async</NAME>
<RETURNS>void           </RETURNS>
GLoadableIcon        *icon, int                   size, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_loadable_icon_load_finish</NAME>
<RETURNS>GInputStream  *</RETURNS>
GLoadableIcon        *icon, GAsyncResult         *res, char                **type, GError              **error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_MEMORY_INPUT_STREAM</NAME>
#define G_TYPE_MEMORY_INPUT_STREAM         (g_memory_input_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_MEMORY_INPUT_STREAM</NAME>
#define G_MEMORY_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_MEMORY_INPUT_STREAM, GMemoryInputStream))
</MACRO>
<MACRO>
<NAME>G_MEMORY_INPUT_STREAM_CLASS</NAME>
#define G_MEMORY_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_MEMORY_INPUT_STREAM, GMemoryInputStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_MEMORY_INPUT_STREAM</NAME>
#define G_IS_MEMORY_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_MEMORY_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_MEMORY_INPUT_STREAM_CLASS</NAME>
#define G_IS_MEMORY_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_MEMORY_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_MEMORY_INPUT_STREAM_GET_CLASS</NAME>
#define G_MEMORY_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_MEMORY_INPUT_STREAM, GMemoryInputStreamClass))
</MACRO>
<STRUCT>
<NAME>GMemoryInputStream</NAME>
struct _GMemoryInputStream
{
  GInputStream parent_instance;

  /*< private >*/
  GMemoryInputStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GMemoryInputStreamClass</NAME>
struct _GMemoryInputStreamClass
{
  GInputStreamClass parent_class;

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_memory_input_stream_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_memory_input_stream_new</NAME>
<RETURNS>GInputStream  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_memory_input_stream_new_from_data</NAME>
<RETURNS>GInputStream  * </RETURNS>
const void         *data, gssize              len, GDestroyNotify      destroy
</FUNCTION>
<FUNCTION>
<NAME>g_memory_input_stream_new_from_bytes</NAME>
<RETURNS>GInputStream  * </RETURNS>
GBytes            *bytes
</FUNCTION>
<FUNCTION>
<NAME>g_memory_input_stream_add_data</NAME>
<RETURNS>void            </RETURNS>
GMemoryInputStream *stream, const void         *data, gssize              len, GDestroyNotify      destroy
</FUNCTION>
<FUNCTION>
<NAME>g_memory_input_stream_add_bytes</NAME>
<RETURNS>void            </RETURNS>
GMemoryInputStream     *stream, GBytes                 *bytes
</FUNCTION>
<STRUCT>
<NAME>GMemoryInputStreamPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_MEMORY_OUTPUT_STREAM</NAME>
#define G_TYPE_MEMORY_OUTPUT_STREAM         (g_memory_output_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_MEMORY_OUTPUT_STREAM</NAME>
#define G_MEMORY_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_MEMORY_OUTPUT_STREAM, GMemoryOutputStream))
</MACRO>
<MACRO>
<NAME>G_MEMORY_OUTPUT_STREAM_CLASS</NAME>
#define G_MEMORY_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_MEMORY_OUTPUT_STREAM, GMemoryOutputStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_MEMORY_OUTPUT_STREAM</NAME>
#define G_IS_MEMORY_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_MEMORY_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_MEMORY_OUTPUT_STREAM_CLASS</NAME>
#define G_IS_MEMORY_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_MEMORY_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_MEMORY_OUTPUT_STREAM_GET_CLASS</NAME>
#define G_MEMORY_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_MEMORY_OUTPUT_STREAM, GMemoryOutputStreamClass))
</MACRO>
<STRUCT>
<NAME>GMemoryOutputStream</NAME>
struct _GMemoryOutputStream
{
  GOutputStream parent_instance;

  /*< private >*/
  GMemoryOutputStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GMemoryOutputStreamClass</NAME>
struct _GMemoryOutputStreamClass
{
  GOutputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<USER_FUNCTION>
<NAME>GReallocFunc</NAME>
<RETURNS>gpointer </RETURNS>
gpointer data,
                                   gsize    size
</USER_FUNCTION>
<FUNCTION>
<NAME>g_memory_output_stream_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_memory_output_stream_new</NAME>
<RETURNS>GOutputStream  *</RETURNS>
gpointer             data, gsize                size, GReallocFunc         realloc_function, GDestroyNotify       destroy_function
</FUNCTION>
<FUNCTION>
<NAME>g_memory_output_stream_new_resizable</NAME>
<RETURNS>GOutputStream  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_memory_output_stream_get_data</NAME>
<RETURNS>gpointer        </RETURNS>
GMemoryOutputStream *ostream
</FUNCTION>
<FUNCTION>
<NAME>g_memory_output_stream_get_size</NAME>
<RETURNS>gsize           </RETURNS>
GMemoryOutputStream *ostream
</FUNCTION>
<FUNCTION>
<NAME>g_memory_output_stream_get_data_size</NAME>
<RETURNS>gsize           </RETURNS>
GMemoryOutputStream *ostream
</FUNCTION>
<FUNCTION>
<NAME>g_memory_output_stream_steal_data</NAME>
<RETURNS>gpointer        </RETURNS>
GMemoryOutputStream *ostream
</FUNCTION>
<FUNCTION>
<NAME>g_memory_output_stream_steal_as_bytes</NAME>
<RETURNS>GBytes  *       </RETURNS>
GMemoryOutputStream *ostream
</FUNCTION>
<STRUCT>
<NAME>GMemoryOutputStreamPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_MENU</NAME>
#define G_TYPE_MENU          (g_menu_get_type ())
</MACRO>
<MACRO>
<NAME>G_MENU</NAME>
#define G_MENU(inst)         (G_TYPE_CHECK_INSTANCE_CAST ((inst), \
                              G_TYPE_MENU, GMenu))
</MACRO>
<MACRO>
<NAME>G_IS_MENU</NAME>
#define G_IS_MENU(inst)      (G_TYPE_CHECK_INSTANCE_TYPE ((inst), \
                              G_TYPE_MENU))
</MACRO>
<MACRO>
<NAME>G_TYPE_MENU_ITEM</NAME>
#define G_TYPE_MENU_ITEM     (g_menu_item_get_type ())
</MACRO>
<MACRO>
<NAME>G_MENU_ITEM</NAME>
#define G_MENU_ITEM(inst)    (G_TYPE_CHECK_INSTANCE_CAST ((inst), \
                              G_TYPE_MENU_ITEM, GMenuItem))
</MACRO>
<MACRO>
<NAME>G_IS_MENU_ITEM</NAME>
#define G_IS_MENU_ITEM(inst) (G_TYPE_CHECK_INSTANCE_TYPE ((inst), \
                              G_TYPE_MENU_ITEM))
</MACRO>
<FUNCTION>
<NAME>g_menu_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_menu_new</NAME>
<RETURNS>GMenu  *     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_menu_freeze</NAME>
<RETURNS>void         </RETURNS>
GMenu       *menu
</FUNCTION>
<FUNCTION>
<NAME>g_menu_insert_item</NAME>
<RETURNS>void         </RETURNS>
GMenu       *menu, gint         position, GMenuItem   *item
</FUNCTION>
<FUNCTION>
<NAME>g_menu_prepend_item</NAME>
<RETURNS>void         </RETURNS>
GMenu       *menu, GMenuItem   *item
</FUNCTION>
<FUNCTION>
<NAME>g_menu_append_item</NAME>
<RETURNS>void         </RETURNS>
GMenu       *menu, GMenuItem   *item
</FUNCTION>
<FUNCTION>
<NAME>g_menu_remove</NAME>
<RETURNS>void         </RETURNS>
GMenu       *menu, gint         position
</FUNCTION>
<FUNCTION>
<NAME>g_menu_remove_all</NAME>
<RETURNS>void         </RETURNS>
GMenu       *menu
</FUNCTION>
<FUNCTION>
<NAME>g_menu_insert</NAME>
<RETURNS>void         </RETURNS>
GMenu       *menu, gint         position, const gchar *label, const gchar *detailed_action
</FUNCTION>
<FUNCTION>
<NAME>g_menu_prepend</NAME>
<RETURNS>void         </RETURNS>
GMenu       *menu, const gchar *label, const gchar *detailed_action
</FUNCTION>
<FUNCTION>
<NAME>g_menu_append</NAME>
<RETURNS>void         </RETURNS>
GMenu       *menu, const gchar *label, const gchar *detailed_action
</FUNCTION>
<FUNCTION>
<NAME>g_menu_insert_section</NAME>
<RETURNS>void         </RETURNS>
GMenu       *menu, gint         position, const gchar *label, GMenuModel  *section
</FUNCTION>
<FUNCTION>
<NAME>g_menu_prepend_section</NAME>
<RETURNS>void         </RETURNS>
GMenu       *menu, const gchar *label, GMenuModel  *section
</FUNCTION>
<FUNCTION>
<NAME>g_menu_append_section</NAME>
<RETURNS>void         </RETURNS>
GMenu       *menu, const gchar *label, GMenuModel  *section
</FUNCTION>
<FUNCTION>
<NAME>g_menu_insert_submenu</NAME>
<RETURNS>void         </RETURNS>
GMenu       *menu, gint        position, const gchar *label, GMenuModel  *submenu
</FUNCTION>
<FUNCTION>
<NAME>g_menu_prepend_submenu</NAME>
<RETURNS>void         </RETURNS>
GMenu       *menu, const gchar *label, GMenuModel  *submenu
</FUNCTION>
<FUNCTION>
<NAME>g_menu_append_submenu</NAME>
<RETURNS>void         </RETURNS>
GMenu       *menu, const gchar *label, GMenuModel  *submenu
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_new</NAME>
<RETURNS>GMenuItem  * </RETURNS>
const gchar *label, const gchar *detailed_action
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_new_from_model</NAME>
<RETURNS>GMenuItem  * </RETURNS>
GMenuModel  *model, gint         item_index
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_new_submenu</NAME>
<RETURNS>GMenuItem  * </RETURNS>
const gchar *label, GMenuModel  *submenu
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_new_section</NAME>
<RETURNS>GMenuItem  * </RETURNS>
const gchar *label, GMenuModel  *section
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_get_attribute_value</NAME>
<RETURNS>GVariant  *  </RETURNS>
GMenuItem   *menu_item, const gchar *attribute, const GVariantType *expected_type
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_get_attribute</NAME>
<RETURNS>gboolean     </RETURNS>
GMenuItem   *menu_item, const gchar *attribute, const gchar *format_string, ...
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_get_link</NAME>
<RETURNS>GMenuModel  *</RETURNS>
GMenuItem   *menu_item, const gchar *link
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_set_attribute_value</NAME>
<RETURNS>void         </RETURNS>
GMenuItem   *menu_item, const gchar *attribute, GVariant    *value
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_set_attribute</NAME>
<RETURNS>void         </RETURNS>
GMenuItem   *menu_item, const gchar *attribute, const gchar *format_string, ...
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_set_link</NAME>
<RETURNS>void         </RETURNS>
GMenuItem   *menu_item, const gchar *link, GMenuModel  *model
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_set_label</NAME>
<RETURNS>void         </RETURNS>
GMenuItem   *menu_item, const gchar *label
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_set_submenu</NAME>
<RETURNS>void         </RETURNS>
GMenuItem   *menu_item, GMenuModel  *submenu
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_set_section</NAME>
<RETURNS>void         </RETURNS>
GMenuItem   *menu_item, GMenuModel  *section
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_set_action_and_target_value</NAME>
<RETURNS>void         </RETURNS>
GMenuItem   *menu_item, const gchar *action, GVariant    *target_value
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_set_action_and_target</NAME>
<RETURNS>void         </RETURNS>
GMenuItem   *menu_item, const gchar *action, const gchar *format_string, ...
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_set_detailed_action</NAME>
<RETURNS>void         </RETURNS>
GMenuItem   *menu_item, const gchar *detailed_action
</FUNCTION>
<FUNCTION>
<NAME>g_menu_item_set_icon</NAME>
<RETURNS>void         </RETURNS>
GMenuItem   *menu_item, GIcon       *icon
</FUNCTION>
<STRUCT>
<NAME>GMenu</NAME>
</STRUCT>
<STRUCT>
<NAME>GMenuItem</NAME>
</STRUCT>
<FUNCTION>
<NAME>g_dbus_connection_export_menu_model</NAME>
<RETURNS>guint                    </RETURNS>
GDBusConnection  *connection, const gchar      *object_path, GMenuModel       *menu, GError          **error
</FUNCTION>
<FUNCTION>
<NAME>g_dbus_connection_unexport_menu_model</NAME>
<RETURNS>void                     </RETURNS>
GDBusConnection  *connection, guint             export_id
</FUNCTION>
<MACRO>
<NAME>G_MENU_ATTRIBUTE_ACTION</NAME>
#define G_MENU_ATTRIBUTE_ACTION "action"
</MACRO>
<MACRO>
<NAME>G_MENU_ATTRIBUTE_ACTION_NAMESPACE</NAME>
#define G_MENU_ATTRIBUTE_ACTION_NAMESPACE "action-namespace"
</MACRO>
<MACRO>
<NAME>G_MENU_ATTRIBUTE_TARGET</NAME>
#define G_MENU_ATTRIBUTE_TARGET "target"
</MACRO>
<MACRO>
<NAME>G_MENU_ATTRIBUTE_LABEL</NAME>
#define G_MENU_ATTRIBUTE_LABEL "label"
</MACRO>
<MACRO>
<NAME>G_MENU_ATTRIBUTE_ICON</NAME>
#define G_MENU_ATTRIBUTE_ICON "icon"
</MACRO>
<MACRO>
<NAME>G_MENU_LINK_SUBMENU</NAME>
#define G_MENU_LINK_SUBMENU "submenu"
</MACRO>
<MACRO>
<NAME>G_MENU_LINK_SECTION</NAME>
#define G_MENU_LINK_SECTION "section"
</MACRO>
<MACRO>
<NAME>G_TYPE_MENU_MODEL</NAME>
#define G_TYPE_MENU_MODEL                                   (g_menu_model_get_type ())
</MACRO>
<MACRO>
<NAME>G_MENU_MODEL</NAME>
#define G_MENU_MODEL(inst)                                  (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_MENU_MODEL, GMenuModel))
</MACRO>
<MACRO>
<NAME>G_MENU_MODEL_CLASS</NAME>
#define G_MENU_MODEL_CLASS(class)                           (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_MENU_MODEL, GMenuModelClass))
</MACRO>
<MACRO>
<NAME>G_IS_MENU_MODEL</NAME>
#define G_IS_MENU_MODEL(inst)                               (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_MENU_MODEL))
</MACRO>
<MACRO>
<NAME>G_IS_MENU_MODEL_CLASS</NAME>
#define G_IS_MENU_MODEL_CLASS(class)                        (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_MENU_MODEL))
</MACRO>
<MACRO>
<NAME>G_MENU_MODEL_GET_CLASS</NAME>
#define G_MENU_MODEL_GET_CLASS(inst)                        (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_MENU_MODEL, GMenuModelClass))
</MACRO>
<STRUCT>
<NAME>GMenuModel</NAME>
struct _GMenuModel
{
  GObject            parent_instance;
  GMenuModelPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GMenuModelClass</NAME>
struct _GMenuModelClass
{
  GObjectClass parent_class;

  gboolean              (*is_mutable)                       (GMenuModel          *model);
  gint                  (*get_n_items)                      (GMenuModel          *model);
  void                  (*get_item_attributes)              (GMenuModel          *model,
                                                             gint                 item_index,
                                                             GHashTable         **attributes);
  GMenuAttributeIter *  (*iterate_item_attributes)          (GMenuModel          *model,
                                                             gint                 item_index);
  GVariant *            (*get_item_attribute_value)         (GMenuModel          *model,
                                                             gint                 item_index,
                                                             const gchar         *attribute,
                                                             const GVariantType  *expected_type);
  void                  (*get_item_links)                   (GMenuModel          *model,
                                                             gint                 item_index,
                                                             GHashTable         **links);
  GMenuLinkIter *       (*iterate_item_links)               (GMenuModel          *model,
                                                             gint                 item_index);
  GMenuModel *          (*get_item_link)                    (GMenuModel          *model,
                                                             gint                 item_index,
                                                             const gchar         *link);
};
</STRUCT>
<FUNCTION>
<NAME>g_menu_model_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_menu_model_is_mutable</NAME>
<RETURNS>gboolean                 </RETURNS>
GMenuModel         *model
</FUNCTION>
<FUNCTION>
<NAME>g_menu_model_get_n_items</NAME>
<RETURNS>gint                     </RETURNS>
GMenuModel         *model
</FUNCTION>
<FUNCTION>
<NAME>g_menu_model_iterate_item_attributes</NAME>
<RETURNS>GMenuAttributeIter  *    </RETURNS>
GMenuModel         *model, gint                item_index
</FUNCTION>
<FUNCTION>
<NAME>g_menu_model_get_item_attribute_value</NAME>
<RETURNS>GVariant  *              </RETURNS>
GMenuModel         *model, gint                item_index, const gchar        *attribute, const GVariantType *expected_type
</FUNCTION>
<FUNCTION>
<NAME>g_menu_model_get_item_attribute</NAME>
<RETURNS>gboolean                 </RETURNS>
GMenuModel         *model, gint                item_index, const gchar        *attribute, const gchar        *format_string, ...
</FUNCTION>
<FUNCTION>
<NAME>g_menu_model_iterate_item_links</NAME>
<RETURNS>GMenuLinkIter  *         </RETURNS>
GMenuModel         *model, gint                item_index
</FUNCTION>
<FUNCTION>
<NAME>g_menu_model_get_item_link</NAME>
<RETURNS>GMenuModel  *            </RETURNS>
GMenuModel         *model, gint                item_index, const gchar        *link
</FUNCTION>
<FUNCTION>
<NAME>g_menu_model_items_changed</NAME>
<RETURNS>void                     </RETURNS>
GMenuModel         *model, gint                position, gint                removed, gint                added
</FUNCTION>
<MACRO>
<NAME>G_TYPE_MENU_ATTRIBUTE_ITER</NAME>
#define G_TYPE_MENU_ATTRIBUTE_ITER                          (g_menu_attribute_iter_get_type ())
</MACRO>
<MACRO>
<NAME>G_MENU_ATTRIBUTE_ITER</NAME>
#define G_MENU_ATTRIBUTE_ITER(inst)                         (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_MENU_ATTRIBUTE_ITER, GMenuAttributeIter))
</MACRO>
<MACRO>
<NAME>G_MENU_ATTRIBUTE_ITER_CLASS</NAME>
#define G_MENU_ATTRIBUTE_ITER_CLASS(class)                  (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_MENU_ATTRIBUTE_ITER, GMenuAttributeIterClass))
</MACRO>
<MACRO>
<NAME>G_IS_MENU_ATTRIBUTE_ITER</NAME>
#define G_IS_MENU_ATTRIBUTE_ITER(inst)                      (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_MENU_ATTRIBUTE_ITER))
</MACRO>
<MACRO>
<NAME>G_IS_MENU_ATTRIBUTE_ITER_CLASS</NAME>
#define G_IS_MENU_ATTRIBUTE_ITER_CLASS(class)               (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_MENU_ATTRIBUTE_ITER))
</MACRO>
<MACRO>
<NAME>G_MENU_ATTRIBUTE_ITER_GET_CLASS</NAME>
#define G_MENU_ATTRIBUTE_ITER_GET_CLASS(inst)               (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_MENU_ATTRIBUTE_ITER, GMenuAttributeIterClass))
</MACRO>
<STRUCT>
<NAME>GMenuAttributeIter</NAME>
struct _GMenuAttributeIter
{
  GObject parent_instance;
  GMenuAttributeIterPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GMenuAttributeIterClass</NAME>
struct _GMenuAttributeIterClass
{
  GObjectClass parent_class;

  gboolean      (*get_next) (GMenuAttributeIter  *iter,
                             const gchar        **out_name,
                             GVariant           **value);
};
</STRUCT>
<FUNCTION>
<NAME>g_menu_attribute_iter_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_menu_attribute_iter_get_next</NAME>
<RETURNS>gboolean                 </RETURNS>
GMenuAttributeIter  *iter, const gchar        **out_name, GVariant           **value
</FUNCTION>
<FUNCTION>
<NAME>g_menu_attribute_iter_next</NAME>
<RETURNS>gboolean                 </RETURNS>
GMenuAttributeIter  *iter
</FUNCTION>
<FUNCTION>
<NAME>g_menu_attribute_iter_get_name</NAME>
<RETURNS>const gchar  *           </RETURNS>
GMenuAttributeIter  *iter
</FUNCTION>
<FUNCTION>
<NAME>g_menu_attribute_iter_get_value</NAME>
<RETURNS>GVariant  *              </RETURNS>
GMenuAttributeIter  *iter
</FUNCTION>
<MACRO>
<NAME>G_TYPE_MENU_LINK_ITER</NAME>
#define G_TYPE_MENU_LINK_ITER                               (g_menu_link_iter_get_type ())
</MACRO>
<MACRO>
<NAME>G_MENU_LINK_ITER</NAME>
#define G_MENU_LINK_ITER(inst)                              (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_MENU_LINK_ITER, GMenuLinkIter))
</MACRO>
<MACRO>
<NAME>G_MENU_LINK_ITER_CLASS</NAME>
#define G_MENU_LINK_ITER_CLASS(class)                       (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_MENU_LINK_ITER, GMenuLinkIterClass))
</MACRO>
<MACRO>
<NAME>G_IS_MENU_LINK_ITER</NAME>
#define G_IS_MENU_LINK_ITER(inst)                           (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_MENU_LINK_ITER))
</MACRO>
<MACRO>
<NAME>G_IS_MENU_LINK_ITER_CLASS</NAME>
#define G_IS_MENU_LINK_ITER_CLASS(class)                    (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_MENU_LINK_ITER))
</MACRO>
<MACRO>
<NAME>G_MENU_LINK_ITER_GET_CLASS</NAME>
#define G_MENU_LINK_ITER_GET_CLASS(inst)                    (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_MENU_LINK_ITER, GMenuLinkIterClass))
</MACRO>
<STRUCT>
<NAME>GMenuLinkIter</NAME>
struct _GMenuLinkIter
{
  GObject parent_instance;
  GMenuLinkIterPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GMenuLinkIterClass</NAME>
struct _GMenuLinkIterClass
{
  GObjectClass parent_class;

  gboolean      (*get_next) (GMenuLinkIter  *iter,
                             const gchar   **out_link,
                             GMenuModel    **value);
};
</STRUCT>
<FUNCTION>
<NAME>g_menu_link_iter_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_menu_link_iter_get_next</NAME>
<RETURNS>gboolean                 </RETURNS>
GMenuLinkIter  *iter, const gchar   **out_link, GMenuModel    **value
</FUNCTION>
<FUNCTION>
<NAME>g_menu_link_iter_next</NAME>
<RETURNS>gboolean                 </RETURNS>
GMenuLinkIter  *iter
</FUNCTION>
<FUNCTION>
<NAME>g_menu_link_iter_get_name</NAME>
<RETURNS>const gchar  *           </RETURNS>
GMenuLinkIter  *iter
</FUNCTION>
<FUNCTION>
<NAME>g_menu_link_iter_get_value</NAME>
<RETURNS>GMenuModel  *            </RETURNS>
GMenuLinkIter  *iter
</FUNCTION>
<STRUCT>
<NAME>GMenuAttributeIterPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GMenuLinkIterPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GMenuModelPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_MOUNT</NAME>
#define G_TYPE_MOUNT            (g_mount_get_type ())
</MACRO>
<MACRO>
<NAME>G_MOUNT</NAME>
#define G_MOUNT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_MOUNT, GMount))
</MACRO>
<MACRO>
<NAME>G_IS_MOUNT</NAME>
#define G_IS_MOUNT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_MOUNT))
</MACRO>
<MACRO>
<NAME>G_MOUNT_GET_IFACE</NAME>
#define G_MOUNT_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_MOUNT, GMountIface))
</MACRO>
<STRUCT>
<NAME>GMountIface</NAME>
struct _GMountIface
{
  GTypeInterface g_iface;

  /* signals */

  void        (* changed)                   (GMount              *mount);
  void        (* unmounted)                 (GMount              *mount);

  /* Virtual Table */

  GFile     * (* get_root)                  (GMount              *mount);
  char      * (* get_name)                  (GMount              *mount);
  GIcon     * (* get_icon)                  (GMount              *mount);
  char      * (* get_uuid)                  (GMount              *mount);
  GVolume   * (* get_volume)                (GMount              *mount);
  GDrive    * (* get_drive)                 (GMount              *mount);
  gboolean    (* can_unmount)               (GMount              *mount);
  gboolean    (* can_eject)                 (GMount              *mount);

  void        (* unmount)                   (GMount              *mount,
                                             GMountUnmountFlags   flags,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* unmount_finish)            (GMount              *mount,
                                             GAsyncResult        *result,
                                             GError             **error);

  void        (* eject)                     (GMount              *mount,
                                             GMountUnmountFlags   flags,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* eject_finish)              (GMount              *mount,
                                             GAsyncResult        *result,
                                             GError             **error);

  void        (* remount)                   (GMount              *mount,
                                             GMountMountFlags     flags,
                                             GMountOperation     *mount_operation,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* remount_finish)            (GMount              *mount,
                                             GAsyncResult        *result,
                                             GError             **error);

  void        (* guess_content_type)        (GMount              *mount,
                                             gboolean             force_rescan,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gchar    ** (* guess_content_type_finish) (GMount              *mount,
                                             GAsyncResult        *result,
                                             GError             **error);
  gchar    ** (* guess_content_type_sync)   (GMount              *mount,
                                             gboolean             force_rescan,
                                             GCancellable        *cancellable,
                                             GError             **error);

  /* Signal, not VFunc */
  void        (* pre_unmount)               (GMount              *mount);

  void        (* unmount_with_operation)    (GMount              *mount,
                                             GMountUnmountFlags   flags,
                                             GMountOperation     *mount_operation,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* unmount_with_operation_finish) (GMount          *mount,
                                             GAsyncResult        *result,
                                             GError             **error);

  void        (* eject_with_operation)      (GMount              *mount,
                                             GMountUnmountFlags   flags,
                                             GMountOperation     *mount_operation,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* eject_with_operation_finish) (GMount            *mount,
                                             GAsyncResult        *result,
                                             GError             **error);
  GFile     * (* get_default_location)      (GMount              *mount);

  const gchar * (* get_sort_key)            (GMount              *mount);
  GIcon       * (* get_symbolic_icon)       (GMount              *mount);
};
</STRUCT>
<FUNCTION>
<NAME>g_mount_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_mount_get_root</NAME>
<RETURNS>GFile      * </RETURNS>
GMount              *mount
</FUNCTION>
<FUNCTION>
<NAME>g_mount_get_default_location</NAME>
<RETURNS>GFile      * </RETURNS>
GMount              *mount
</FUNCTION>
<FUNCTION>
<NAME>g_mount_get_name</NAME>
<RETURNS>char       * </RETURNS>
GMount              *mount
</FUNCTION>
<FUNCTION>
<NAME>g_mount_get_icon</NAME>
<RETURNS>GIcon      * </RETURNS>
GMount              *mount
</FUNCTION>
<FUNCTION>
<NAME>g_mount_get_symbolic_icon</NAME>
<RETURNS>GIcon      * </RETURNS>
GMount              *mount
</FUNCTION>
<FUNCTION>
<NAME>g_mount_get_uuid</NAME>
<RETURNS>char       * </RETURNS>
GMount              *mount
</FUNCTION>
<FUNCTION>
<NAME>g_mount_get_volume</NAME>
<RETURNS>GVolume    * </RETURNS>
GMount              *mount
</FUNCTION>
<FUNCTION>
<NAME>g_mount_get_drive</NAME>
<RETURNS>GDrive     * </RETURNS>
GMount              *mount
</FUNCTION>
<FUNCTION>
<NAME>g_mount_can_unmount</NAME>
<RETURNS>gboolean     </RETURNS>
GMount              *mount
</FUNCTION>
<FUNCTION>
<NAME>g_mount_can_eject</NAME>
<RETURNS>gboolean     </RETURNS>
GMount              *mount
</FUNCTION>
<FUNCTION>
<NAME>g_mount_unmount</NAME>
<DEPRECATED/>
<RETURNS>void         </RETURNS>
GMount              *mount, GMountUnmountFlags   flags, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_mount_unmount_finish</NAME>
<DEPRECATED/>
<RETURNS>gboolean     </RETURNS>
GMount              *mount, GAsyncResult        *result, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_mount_eject</NAME>
<DEPRECATED/>
<RETURNS>void         </RETURNS>
GMount              *mount, GMountUnmountFlags   flags, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_mount_eject_finish</NAME>
<DEPRECATED/>
<RETURNS>gboolean     </RETURNS>
GMount              *mount, GAsyncResult        *result, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_mount_remount</NAME>
<RETURNS>void         </RETURNS>
GMount              *mount, GMountMountFlags     flags, GMountOperation     *mount_operation, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_mount_remount_finish</NAME>
<RETURNS>gboolean     </RETURNS>
GMount              *mount, GAsyncResult        *result, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_mount_guess_content_type</NAME>
<RETURNS>void         </RETURNS>
GMount              *mount, gboolean             force_rescan, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_mount_guess_content_type_finish</NAME>
<RETURNS>gchar     ** </RETURNS>
GMount              *mount, GAsyncResult        *result, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_mount_guess_content_type_sync</NAME>
<RETURNS>gchar     ** </RETURNS>
GMount              *mount, gboolean             force_rescan, GCancellable        *cancellable, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_mount_is_shadowed</NAME>
<RETURNS>gboolean     </RETURNS>
GMount              *mount
</FUNCTION>
<FUNCTION>
<NAME>g_mount_shadow</NAME>
<RETURNS>void         </RETURNS>
GMount              *mount
</FUNCTION>
<FUNCTION>
<NAME>g_mount_unshadow</NAME>
<RETURNS>void         </RETURNS>
GMount              *mount
</FUNCTION>
<FUNCTION>
<NAME>g_mount_unmount_with_operation</NAME>
<RETURNS>void         </RETURNS>
GMount              *mount, GMountUnmountFlags   flags, GMountOperation     *mount_operation, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_mount_unmount_with_operation_finish</NAME>
<RETURNS>gboolean     </RETURNS>
GMount          *mount, GAsyncResult        *result, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_mount_eject_with_operation</NAME>
<RETURNS>void         </RETURNS>
GMount              *mount, GMountUnmountFlags   flags, GMountOperation     *mount_operation, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_mount_eject_with_operation_finish</NAME>
<RETURNS>gboolean     </RETURNS>
GMount            *mount, GAsyncResult        *result, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_mount_get_sort_key</NAME>
<RETURNS>const gchar  *</RETURNS>
GMount              *mount
</FUNCTION>
<MACRO>
<NAME>G_TYPE_MOUNT_OPERATION</NAME>
#define G_TYPE_MOUNT_OPERATION         (g_mount_operation_get_type ())
</MACRO>
<MACRO>
<NAME>G_MOUNT_OPERATION</NAME>
#define G_MOUNT_OPERATION(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_MOUNT_OPERATION, GMountOperation))
</MACRO>
<MACRO>
<NAME>G_MOUNT_OPERATION_CLASS</NAME>
#define G_MOUNT_OPERATION_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_MOUNT_OPERATION, GMountOperationClass))
</MACRO>
<MACRO>
<NAME>G_IS_MOUNT_OPERATION</NAME>
#define G_IS_MOUNT_OPERATION(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_MOUNT_OPERATION))
</MACRO>
<MACRO>
<NAME>G_IS_MOUNT_OPERATION_CLASS</NAME>
#define G_IS_MOUNT_OPERATION_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_MOUNT_OPERATION))
</MACRO>
<MACRO>
<NAME>G_MOUNT_OPERATION_GET_CLASS</NAME>
#define G_MOUNT_OPERATION_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_MOUNT_OPERATION, GMountOperationClass))
</MACRO>
<STRUCT>
<NAME>GMountOperation</NAME>
struct _GMountOperation
{
  GObject parent_instance;

  GMountOperationPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GMountOperationClass</NAME>
struct _GMountOperationClass
{
  GObjectClass parent_class;

  /* signals: */

  void (* ask_password) (GMountOperation       *op,
			 const char            *message,
			 const char            *default_user,
			 const char            *default_domain,
			 GAskPasswordFlags      flags);

  /**
   * GMountOperationClass::ask_question:
   * @op:
   * @message:
   * @choices: (array zero-terminated=1) (element-type utf8):
   */
  void (* ask_question) (GMountOperation       *op,
			 const char            *message,
			 const char            *choices[]);

  void (* reply)        (GMountOperation       *op,
			 GMountOperationResult  result);

  void (* aborted)      (GMountOperation       *op);

  /**
   * GMountOperationClass::show_processes:
   * @op:
   * @message:
   * @processes: (element-type GPid):
   * @choices: (array zero-terminated=1) (element-type utf8):
   *
   * Since: 2.22
   */
  void (* show_processes) (GMountOperation      *op,
                           const gchar          *message,
                           GArray               *processes,
                           const gchar          *choices[]);

  void (* show_unmount_progress) (GMountOperation *op,
                                  const gchar     *message,
                                  gint64           time_left,
                                  gint64           bytes_left);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
  void (*_g_reserved7) (void);
  void (*_g_reserved8) (void);
  void (*_g_reserved9) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_mount_operation_get_type</NAME>
<RETURNS>GType              </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_new</NAME>
<RETURNS>GMountOperation  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_get_username</NAME>
<RETURNS>const char  *  </RETURNS>
GMountOperation *op
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_set_username</NAME>
<RETURNS>void           </RETURNS>
GMountOperation *op, const char      *username
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_get_password</NAME>
<RETURNS>const char  *  </RETURNS>
GMountOperation *op
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_set_password</NAME>
<RETURNS>void           </RETURNS>
GMountOperation *op, const char      *password
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_get_anonymous</NAME>
<RETURNS>gboolean       </RETURNS>
GMountOperation *op
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_set_anonymous</NAME>
<RETURNS>void           </RETURNS>
GMountOperation *op, gboolean         anonymous
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_get_domain</NAME>
<RETURNS>const char  *  </RETURNS>
GMountOperation *op
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_set_domain</NAME>
<RETURNS>void           </RETURNS>
GMountOperation *op, const char      *domain
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_get_password_save</NAME>
<RETURNS>GPasswordSave  </RETURNS>
GMountOperation *op
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_set_password_save</NAME>
<RETURNS>void           </RETURNS>
GMountOperation *op, GPasswordSave    save
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_get_choice</NAME>
<RETURNS>int            </RETURNS>
GMountOperation *op
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_set_choice</NAME>
<RETURNS>void           </RETURNS>
GMountOperation *op, int              choice
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_reply</NAME>
<RETURNS>void           </RETURNS>
GMountOperation *op, GMountOperationResult result
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_get_is_tcrypt_hidden_volume</NAME>
<RETURNS>gboolean       </RETURNS>
GMountOperation *op
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_set_is_tcrypt_hidden_volume</NAME>
<RETURNS>void           </RETURNS>
GMountOperation *op, gboolean hidden_volume
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_get_is_tcrypt_system_volume</NAME>
<RETURNS>gboolean       </RETURNS>
GMountOperation *op
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_set_is_tcrypt_system_volume</NAME>
<RETURNS>void           </RETURNS>
GMountOperation *op, gboolean system_volume
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_get_pim</NAME>
<RETURNS>guint   </RETURNS>
GMountOperation *op
</FUNCTION>
<FUNCTION>
<NAME>g_mount_operation_set_pim</NAME>
<RETURNS>void           </RETURNS>
GMountOperation *op, guint pim
</FUNCTION>
<STRUCT>
<NAME>GMountOperationPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_NATIVE_SOCKET_ADDRESS</NAME>
#define G_TYPE_NATIVE_SOCKET_ADDRESS         (g_native_socket_address_get_type ())
</MACRO>
<MACRO>
<NAME>G_NATIVE_SOCKET_ADDRESS</NAME>
#define G_NATIVE_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NATIVE_SOCKET_ADDRESS, GNativeSocketAddress))
</MACRO>
<MACRO>
<NAME>G_NATIVE_SOCKET_ADDRESS_CLASS</NAME>
#define G_NATIVE_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NATIVE_SOCKET_ADDRESS, GNativeSocketAddressClass))
</MACRO>
<MACRO>
<NAME>G_IS_NATIVE_SOCKET_ADDRESS</NAME>
#define G_IS_NATIVE_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NATIVE_SOCKET_ADDRESS))
</MACRO>
<MACRO>
<NAME>G_IS_NATIVE_SOCKET_ADDRESS_CLASS</NAME>
#define G_IS_NATIVE_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NATIVE_SOCKET_ADDRESS))
</MACRO>
<MACRO>
<NAME>G_NATIVE_SOCKET_ADDRESS_GET_CLASS</NAME>
#define G_NATIVE_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NATIVE_SOCKET_ADDRESS, GNativeSocketAddressClass))
</MACRO>
<STRUCT>
<NAME>GNativeSocketAddress</NAME>
struct _GNativeSocketAddress
{
  GSocketAddress parent_instance;

  /*< private >*/
  GNativeSocketAddressPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GNativeSocketAddressClass</NAME>
struct _GNativeSocketAddressClass
{
  GSocketAddressClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>g_native_socket_address_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_native_socket_address_new</NAME>
<RETURNS>GSocketAddress  *</RETURNS>
gpointer        native, gsize           len
</FUNCTION>
<STRUCT>
<NAME>GNativeSocketAddressPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_NETWORK_ADDRESS</NAME>
#define G_TYPE_NETWORK_ADDRESS         (g_network_address_get_type ())
</MACRO>
<MACRO>
<NAME>G_NETWORK_ADDRESS</NAME>
#define G_NETWORK_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_ADDRESS, GNetworkAddress))
</MACRO>
<MACRO>
<NAME>G_NETWORK_ADDRESS_CLASS</NAME>
#define G_NETWORK_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass))
</MACRO>
<MACRO>
<NAME>G_IS_NETWORK_ADDRESS</NAME>
#define G_IS_NETWORK_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_ADDRESS))
</MACRO>
<MACRO>
<NAME>G_IS_NETWORK_ADDRESS_CLASS</NAME>
#define G_IS_NETWORK_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NETWORK_ADDRESS))
</MACRO>
<MACRO>
<NAME>G_NETWORK_ADDRESS_GET_CLASS</NAME>
#define G_NETWORK_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass))
</MACRO>
<STRUCT>
<NAME>GNetworkAddress</NAME>
struct _GNetworkAddress
{
  GObject parent_instance;

  /*< private >*/
  GNetworkAddressPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GNetworkAddressClass</NAME>
struct _GNetworkAddressClass
{
  GObjectClass parent_class;

};
</STRUCT>
<FUNCTION>
<NAME>g_network_address_get_type</NAME>
<RETURNS>GType                </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_network_address_new</NAME>
<RETURNS>GSocketConnectable  *</RETURNS>
const gchar      *hostname, guint16           port
</FUNCTION>
<FUNCTION>
<NAME>g_network_address_new_loopback</NAME>
<RETURNS>GSocketConnectable  *</RETURNS>
guint16           port
</FUNCTION>
<FUNCTION>
<NAME>g_network_address_parse</NAME>
<RETURNS>GSocketConnectable  *</RETURNS>
const gchar      *host_and_port, guint16           default_port, GError          **error
</FUNCTION>
<FUNCTION>
<NAME>g_network_address_parse_uri</NAME>
<RETURNS>GSocketConnectable  *</RETURNS>
const gchar      *uri, guint16           default_port, GError          **error
</FUNCTION>
<FUNCTION>
<NAME>g_network_address_get_hostname</NAME>
<RETURNS>const gchar         *</RETURNS>
GNetworkAddress  *addr
</FUNCTION>
<FUNCTION>
<NAME>g_network_address_get_port</NAME>
<RETURNS>guint16              </RETURNS>
GNetworkAddress  *addr
</FUNCTION>
<FUNCTION>
<NAME>g_network_address_get_scheme</NAME>
<RETURNS>const gchar         *</RETURNS>
GNetworkAddress  *addr
</FUNCTION>
<STRUCT>
<NAME>GNetworkAddressPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_NETWORK_MONITOR_EXTENSION_POINT_NAME</NAME>
#define G_NETWORK_MONITOR_EXTENSION_POINT_NAME "gio-network-monitor"
</MACRO>
<MACRO>
<NAME>G_TYPE_NETWORK_MONITOR</NAME>
#define G_TYPE_NETWORK_MONITOR             (g_network_monitor_get_type ())
</MACRO>
<MACRO>
<NAME>G_NETWORK_MONITOR</NAME>
#define G_NETWORK_MONITOR(o)               (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_MONITOR, GNetworkMonitor))
</MACRO>
<MACRO>
<NAME>G_IS_NETWORK_MONITOR</NAME>
#define G_IS_NETWORK_MONITOR(o)            (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_MONITOR))
</MACRO>
<MACRO>
<NAME>G_NETWORK_MONITOR_GET_INTERFACE</NAME>
#define G_NETWORK_MONITOR_GET_INTERFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), G_TYPE_NETWORK_MONITOR, GNetworkMonitorInterface))
</MACRO>
<STRUCT>
<NAME>GNetworkMonitorInterface</NAME>
struct _GNetworkMonitorInterface {
  GTypeInterface g_iface;

  void     (*network_changed)  (GNetworkMonitor      *monitor,
				gboolean              network_available);

  gboolean (*can_reach)        (GNetworkMonitor      *monitor,
				GSocketConnectable   *connectable,
				GCancellable         *cancellable,
				GError              **error);
  void     (*can_reach_async)  (GNetworkMonitor      *monitor,
				GSocketConnectable   *connectable,
				GCancellable         *cancellable,
				GAsyncReadyCallback   callback,
				gpointer              user_data);
  gboolean (*can_reach_finish) (GNetworkMonitor      *monitor,
				GAsyncResult         *result,
				GError              **error);
};
</STRUCT>
<FUNCTION>
<NAME>g_network_monitor_get_type</NAME>
<RETURNS>GType                  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_network_monitor_get_default</NAME>
<RETURNS>GNetworkMonitor       *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_network_monitor_get_network_available</NAME>
<RETURNS>gboolean               </RETURNS>
GNetworkMonitor     *monitor
</FUNCTION>
<FUNCTION>
<NAME>g_network_monitor_get_network_metered</NAME>
<RETURNS>gboolean               </RETURNS>
GNetworkMonitor     *monitor
</FUNCTION>
<FUNCTION>
<NAME>g_network_monitor_get_connectivity</NAME>
<RETURNS>GNetworkConnectivity   </RETURNS>
GNetworkMonitor     *monitor
</FUNCTION>
<FUNCTION>
<NAME>g_network_monitor_can_reach</NAME>
<RETURNS>gboolean               </RETURNS>
GNetworkMonitor     *monitor, GSocketConnectable  *connectable, GCancellable        *cancellable, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_network_monitor_can_reach_async</NAME>
<RETURNS>void                   </RETURNS>
GNetworkMonitor     *monitor, GSocketConnectable  *connectable, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_network_monitor_can_reach_finish</NAME>
<RETURNS>gboolean               </RETURNS>
GNetworkMonitor     *monitor, GAsyncResult        *result, GError             **error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_NETWORK_SERVICE</NAME>
#define G_TYPE_NETWORK_SERVICE         (g_network_service_get_type ())
</MACRO>
<MACRO>
<NAME>G_NETWORK_SERVICE</NAME>
#define G_NETWORK_SERVICE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_SERVICE, GNetworkService))
</MACRO>
<MACRO>
<NAME>G_NETWORK_SERVICE_CLASS</NAME>
#define G_NETWORK_SERVICE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NETWORK_SERVICE, GNetworkServiceClass))
</MACRO>
<MACRO>
<NAME>G_IS_NETWORK_SERVICE</NAME>
#define G_IS_NETWORK_SERVICE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_SERVICE))
</MACRO>
<MACRO>
<NAME>G_IS_NETWORK_SERVICE_CLASS</NAME>
#define G_IS_NETWORK_SERVICE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NETWORK_SERVICE))
</MACRO>
<MACRO>
<NAME>G_NETWORK_SERVICE_GET_CLASS</NAME>
#define G_NETWORK_SERVICE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NETWORK_SERVICE, GNetworkServiceClass))
</MACRO>
<STRUCT>
<NAME>GNetworkService</NAME>
struct _GNetworkService
{
  GObject parent_instance;

  /*< private >*/
  GNetworkServicePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GNetworkServiceClass</NAME>
struct _GNetworkServiceClass
{
  GObjectClass parent_class;

};
</STRUCT>
<FUNCTION>
<NAME>g_network_service_get_type</NAME>
<RETURNS>GType                 </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_network_service_new</NAME>
<RETURNS>GSocketConnectable   *</RETURNS>
const gchar     *service, const gchar     *protocol, const gchar     *domain
</FUNCTION>
<FUNCTION>
<NAME>g_network_service_get_service</NAME>
<RETURNS>const gchar          *</RETURNS>
GNetworkService *srv
</FUNCTION>
<FUNCTION>
<NAME>g_network_service_get_protocol</NAME>
<RETURNS>const gchar          *</RETURNS>
GNetworkService *srv
</FUNCTION>
<FUNCTION>
<NAME>g_network_service_get_domain</NAME>
<RETURNS>const gchar          *</RETURNS>
GNetworkService *srv
</FUNCTION>
<FUNCTION>
<NAME>g_network_service_get_scheme</NAME>
<RETURNS>const gchar          *</RETURNS>
GNetworkService *srv
</FUNCTION>
<FUNCTION>
<NAME>g_network_service_set_scheme</NAME>
<RETURNS>void                  </RETURNS>
GNetworkService *srv, const gchar *scheme
</FUNCTION>
<STRUCT>
<NAME>GNetworkServicePrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_NOTIFICATION</NAME>
#define G_TYPE_NOTIFICATION         (g_notification_get_type ())
</MACRO>
<MACRO>
<NAME>G_NOTIFICATION</NAME>
#define G_NOTIFICATION(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NOTIFICATION, GNotification))
</MACRO>
<MACRO>
<NAME>G_IS_NOTIFICATION</NAME>
#define G_IS_NOTIFICATION(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NOTIFICATION))
</MACRO>
<FUNCTION>
<NAME>g_notification_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_notification_new</NAME>
<RETURNS>GNotification  *         </RETURNS>
const gchar *title
</FUNCTION>
<FUNCTION>
<NAME>g_notification_set_title</NAME>
<RETURNS>void                     </RETURNS>
GNotification *notification, const gchar   *title
</FUNCTION>
<FUNCTION>
<NAME>g_notification_set_body</NAME>
<RETURNS>void                     </RETURNS>
GNotification *notification, const gchar   *body
</FUNCTION>
<FUNCTION>
<NAME>g_notification_set_icon</NAME>
<RETURNS>void                     </RETURNS>
GNotification *notification, GIcon         *icon
</FUNCTION>
<FUNCTION>
<NAME>g_notification_set_urgent</NAME>
<DEPRECATED/>
<RETURNS>void                     </RETURNS>
GNotification *notification, gboolean       urgent
</FUNCTION>
<FUNCTION>
<NAME>g_notification_set_priority</NAME>
<RETURNS>void                     </RETURNS>
GNotification         *notification, GNotificationPriority  priority
</FUNCTION>
<FUNCTION>
<NAME>g_notification_add_button</NAME>
<RETURNS>void                     </RETURNS>
GNotification *notification, const gchar   *label, const gchar   *detailed_action
</FUNCTION>
<FUNCTION>
<NAME>g_notification_add_button_with_target</NAME>
<RETURNS>void                     </RETURNS>
GNotification *notification, const gchar   *label, const gchar   *action, const gchar   *target_format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_notification_add_button_with_target_value</NAME>
<RETURNS>void                     </RETURNS>
GNotification *notification, const gchar   *label, const gchar   *action, GVariant      *target
</FUNCTION>
<FUNCTION>
<NAME>g_notification_set_default_action</NAME>
<RETURNS>void                     </RETURNS>
GNotification *notification, const gchar   *detailed_action
</FUNCTION>
<FUNCTION>
<NAME>g_notification_set_default_action_and_target</NAME>
<RETURNS>void                     </RETURNS>
GNotification *notification, const gchar   *action, const gchar   *target_format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_notification_set_default_action_and_target_value</NAME>
<RETURNS>void                  </RETURNS>
GNotification *notification, const gchar   *action, GVariant      *target
</FUNCTION>
<FUNCTION>
<NAME>g_openuri_portal_open_uri</NAME>
<RETURNS>gboolean  </RETURNS>
const char  *uri, const char  *parent_window, GError     **error
</FUNCTION>
<FUNCTION>
<NAME>g_openuri_portal_open_uri_async</NAME>
<RETURNS>void      </RETURNS>
const char          *uri, const char          *parent_window, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_openuri_portal_open_uri_finish</NAME>
<RETURNS>gboolean  </RETURNS>
GAsyncResult        *result, GError             **error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_OUTPUT_STREAM</NAME>
#define G_TYPE_OUTPUT_STREAM         (g_output_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_OUTPUT_STREAM</NAME>
#define G_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_OUTPUT_STREAM, GOutputStream))
</MACRO>
<MACRO>
<NAME>G_OUTPUT_STREAM_CLASS</NAME>
#define G_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_OUTPUT_STREAM, GOutputStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_OUTPUT_STREAM</NAME>
#define G_IS_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_OUTPUT_STREAM_CLASS</NAME>
#define G_IS_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_OUTPUT_STREAM_GET_CLASS</NAME>
#define G_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_OUTPUT_STREAM, GOutputStreamClass))
</MACRO>
<STRUCT>
<NAME>GOutputStream</NAME>
struct _GOutputStream
{
  GObject parent_instance;

  /*< private >*/
  GOutputStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GOutputStreamClass</NAME>
struct _GOutputStreamClass
{
  GObjectClass parent_class;

  /* Sync ops: */

  gssize      (* write_fn)      (GOutputStream            *stream,
                                 const void               *buffer,
                                 gsize                     count,
                                 GCancellable             *cancellable,
                                 GError                  **error);
  gssize      (* splice)        (GOutputStream            *stream,
                                 GInputStream             *source,
                                 GOutputStreamSpliceFlags  flags,
                                 GCancellable             *cancellable,
                                 GError                  **error);
  gboolean    (* flush)	        (GOutputStream            *stream,
                                 GCancellable             *cancellable,
                                 GError                  **error);
  gboolean    (* close_fn)      (GOutputStream            *stream,
                                 GCancellable             *cancellable,
                                 GError                  **error);

  /* Async ops: (optional in derived classes) */

  void        (* write_async)   (GOutputStream            *stream,
                                 const void               *buffer,
                                 gsize                     count,
                                 int                       io_priority,
                                 GCancellable             *cancellable,
                                 GAsyncReadyCallback       callback,
                                 gpointer                  user_data);
  gssize      (* write_finish)  (GOutputStream            *stream,
                                 GAsyncResult             *result,
                                 GError                  **error);
  void        (* splice_async)  (GOutputStream            *stream,
                                 GInputStream             *source,
                                 GOutputStreamSpliceFlags  flags,
                                 int                       io_priority,
                                 GCancellable             *cancellable,
                                 GAsyncReadyCallback       callback,
                                 gpointer                  user_data);
  gssize      (* splice_finish) (GOutputStream            *stream,
                                 GAsyncResult             *result,
                                 GError                  **error);
  void        (* flush_async)   (GOutputStream            *stream,
                                 int                       io_priority,
                                 GCancellable             *cancellable,
                                 GAsyncReadyCallback       callback,
                                 gpointer                  user_data);
  gboolean    (* flush_finish)  (GOutputStream            *stream,
                                 GAsyncResult             *result,
                                 GError                  **error);
  void        (* close_async)   (GOutputStream            *stream,
                                 int                       io_priority,
                                 GCancellable             *cancellable,
                                 GAsyncReadyCallback       callback,
                                 gpointer                  user_data);
  gboolean    (* close_finish)  (GOutputStream            *stream,
                                 GAsyncResult             *result,
                                 GError                  **error);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
  void (*_g_reserved7) (void);
  void (*_g_reserved8) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_output_stream_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_write</NAME>
<RETURNS>gssize    </RETURNS>
GOutputStream             *stream, const void                *buffer, gsize                      count, GCancellable              *cancellable, GError                   **error
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_write_all</NAME>
<RETURNS>gboolean  </RETURNS>
GOutputStream             *stream, const void                *buffer, gsize                      count, gsize                     *bytes_written, GCancellable              *cancellable, GError                   **error
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_printf</NAME>
<RETURNS>gboolean  </RETURNS>
GOutputStream             *stream, gsize                     *bytes_written, GCancellable              *cancellable, GError                   **error, const gchar               *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_vprintf</NAME>
<RETURNS>gboolean  </RETURNS>
GOutputStream             *stream, gsize                     *bytes_written, GCancellable              *cancellable, GError                   **error, const gchar               *format, va_list                    args
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_write_bytes</NAME>
<RETURNS>gssize    </RETURNS>
GOutputStream             *stream, GBytes                    *bytes, GCancellable              *cancellable, GError                   **error
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_splice</NAME>
<RETURNS>gssize    </RETURNS>
GOutputStream             *stream, GInputStream              *source, GOutputStreamSpliceFlags   flags, GCancellable              *cancellable, GError                   **error
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_flush</NAME>
<RETURNS>gboolean  </RETURNS>
GOutputStream             *stream, GCancellable              *cancellable, GError                   **error
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_close</NAME>
<RETURNS>gboolean  </RETURNS>
GOutputStream             *stream, GCancellable              *cancellable, GError                   **error
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_write_async</NAME>
<RETURNS>void      </RETURNS>
GOutputStream             *stream, const void                *buffer, gsize                      count, int                        io_priority, GCancellable              *cancellable, GAsyncReadyCallback        callback, gpointer                   user_data
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_write_finish</NAME>
<RETURNS>gssize    </RETURNS>
GOutputStream             *stream, GAsyncResult              *result, GError                   **error
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_write_all_async</NAME>
<RETURNS>void      </RETURNS>
GOutputStream           *stream, const void              *buffer, gsize                    count, int                      io_priority, GCancellable            *cancellable, GAsyncReadyCallback      callback, gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_write_all_finish</NAME>
<RETURNS>gboolean  </RETURNS>
GOutputStream          *stream, GAsyncResult           *result, gsize                  *bytes_written, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_write_bytes_async</NAME>
<RETURNS>void      </RETURNS>
GOutputStream             *stream, GBytes                    *bytes, int                        io_priority, GCancellable              *cancellable, GAsyncReadyCallback        callback, gpointer                   user_data
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_write_bytes_finish</NAME>
<RETURNS>gssize    </RETURNS>
GOutputStream             *stream, GAsyncResult              *result, GError                   **error
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_splice_async</NAME>
<RETURNS>void      </RETURNS>
GOutputStream             *stream, GInputStream              *source, GOutputStreamSpliceFlags   flags, int                        io_priority, GCancellable              *cancellable, GAsyncReadyCallback        callback, gpointer                   user_data
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_splice_finish</NAME>
<RETURNS>gssize    </RETURNS>
GOutputStream             *stream, GAsyncResult              *result, GError                   **error
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_flush_async</NAME>
<RETURNS>void      </RETURNS>
GOutputStream             *stream, int                        io_priority, GCancellable              *cancellable, GAsyncReadyCallback        callback, gpointer                   user_data
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_flush_finish</NAME>
<RETURNS>gboolean  </RETURNS>
GOutputStream             *stream, GAsyncResult              *result, GError                   **error
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_close_async</NAME>
<RETURNS>void      </RETURNS>
GOutputStream             *stream, int                        io_priority, GCancellable              *cancellable, GAsyncReadyCallback        callback, gpointer                   user_data
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_close_finish</NAME>
<RETURNS>gboolean  </RETURNS>
GOutputStream             *stream, GAsyncResult              *result, GError                   **error
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_is_closed</NAME>
<RETURNS>gboolean  </RETURNS>
GOutputStream             *stream
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_is_closing</NAME>
<RETURNS>gboolean  </RETURNS>
GOutputStream             *stream
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_has_pending</NAME>
<RETURNS>gboolean  </RETURNS>
GOutputStream             *stream
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_set_pending</NAME>
<RETURNS>gboolean  </RETURNS>
GOutputStream             *stream, GError                   **error
</FUNCTION>
<FUNCTION>
<NAME>g_output_stream_clear_pending</NAME>
<RETURNS>void      </RETURNS>
GOutputStream             *stream
</FUNCTION>
<STRUCT>
<NAME>GOutputStreamPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_PERMISSION</NAME>
#define G_TYPE_PERMISSION             (g_permission_get_type ())
</MACRO>
<MACRO>
<NAME>G_PERMISSION</NAME>
#define G_PERMISSION(inst)            (G_TYPE_CHECK_INSTANCE_CAST ((inst),   \
                                       G_TYPE_PERMISSION, GPermission))
</MACRO>
<MACRO>
<NAME>G_PERMISSION_CLASS</NAME>
#define G_PERMISSION_CLASS(class)     (G_TYPE_CHECK_CLASS_CAST ((class),     \
                                       G_TYPE_PERMISSION, GPermissionClass))
</MACRO>
<MACRO>
<NAME>G_IS_PERMISSION</NAME>
#define G_IS_PERMISSION(inst)         (G_TYPE_CHECK_INSTANCE_TYPE ((inst),   \
                                       G_TYPE_PERMISSION))
</MACRO>
<MACRO>
<NAME>G_IS_PERMISSION_CLASS</NAME>
#define G_IS_PERMISSION_CLASS(class)  (G_TYPE_CHECK_CLASS_TYPE ((class),     \
                                       G_TYPE_PERMISSION))
</MACRO>
<MACRO>
<NAME>G_PERMISSION_GET_CLASS</NAME>
#define G_PERMISSION_GET_CLASS(inst)  (G_TYPE_INSTANCE_GET_CLASS ((inst),    \
                                       G_TYPE_PERMISSION, GPermissionClass))
</MACRO>
<STRUCT>
<NAME>GPermission</NAME>
struct _GPermission
{
  GObject parent_instance;

  /*< private >*/
  GPermissionPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GPermissionClass</NAME>
struct _GPermissionClass {
  GObjectClass parent_class;

  gboolean (*acquire)        (GPermission          *permission,
                              GCancellable         *cancellable,
                              GError              **error);
  void     (*acquire_async)  (GPermission          *permission,
                              GCancellable         *cancellable,
                              GAsyncReadyCallback   callback,
                              gpointer              user_data);
  gboolean (*acquire_finish) (GPermission          *permission,
                              GAsyncResult         *result,
                              GError              **error);

  gboolean (*release)        (GPermission          *permission,
                              GCancellable         *cancellable,
                              GError              **error);
  void     (*release_async)  (GPermission          *permission,
                              GCancellable         *cancellable,
                              GAsyncReadyCallback   callback,
                              gpointer              user_data);
  gboolean (*release_finish) (GPermission          *permission,
                              GAsyncResult         *result,
                              GError              **error);

  gpointer reserved[16];
};
</STRUCT>
<FUNCTION>
<NAME>g_permission_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_permission_acquire</NAME>
<RETURNS>gboolean         </RETURNS>
GPermission          *permission, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_permission_acquire_async</NAME>
<RETURNS>void             </RETURNS>
GPermission          *permission, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_permission_acquire_finish</NAME>
<RETURNS>gboolean         </RETURNS>
GPermission          *permission, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_permission_release</NAME>
<RETURNS>gboolean         </RETURNS>
GPermission          *permission, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_permission_release_async</NAME>
<RETURNS>void             </RETURNS>
GPermission          *permission, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_permission_release_finish</NAME>
<RETURNS>gboolean         </RETURNS>
GPermission          *permission, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_permission_get_allowed</NAME>
<RETURNS>gboolean         </RETURNS>
GPermission   *permission
</FUNCTION>
<FUNCTION>
<NAME>g_permission_get_can_acquire</NAME>
<RETURNS>gboolean         </RETURNS>
GPermission   *permission
</FUNCTION>
<FUNCTION>
<NAME>g_permission_get_can_release</NAME>
<RETURNS>gboolean         </RETURNS>
GPermission   *permission
</FUNCTION>
<FUNCTION>
<NAME>g_permission_impl_update</NAME>
<RETURNS>void             </RETURNS>
GPermission  *permission, gboolean      allowed, gboolean      can_acquire, gboolean      can_release
</FUNCTION>
<STRUCT>
<NAME>GPermissionPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_POLLABLE_INPUT_STREAM</NAME>
#define G_TYPE_POLLABLE_INPUT_STREAM               (g_pollable_input_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_POLLABLE_INPUT_STREAM</NAME>
#define G_POLLABLE_INPUT_STREAM(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_POLLABLE_INPUT_STREAM, GPollableInputStream))
</MACRO>
<MACRO>
<NAME>G_IS_POLLABLE_INPUT_STREAM</NAME>
#define G_IS_POLLABLE_INPUT_STREAM(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_POLLABLE_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_POLLABLE_INPUT_STREAM_GET_INTERFACE</NAME>
#define G_POLLABLE_INPUT_STREAM_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_POLLABLE_INPUT_STREAM, GPollableInputStreamInterface))
</MACRO>
<STRUCT>
<NAME>GPollableInputStreamInterface</NAME>
struct _GPollableInputStreamInterface
{
  GTypeInterface g_iface;

  /* Virtual Table */
  gboolean     (*can_poll)         (GPollableInputStream  *stream);

  gboolean     (*is_readable)      (GPollableInputStream  *stream);
  GSource *    (*create_source)    (GPollableInputStream  *stream,
				    GCancellable          *cancellable);
  gssize       (*read_nonblocking) (GPollableInputStream  *stream,
				    void                  *buffer,
				    gsize                  count,
				    GError               **error);
};
</STRUCT>
<FUNCTION>
<NAME>g_pollable_input_stream_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_pollable_input_stream_can_poll</NAME>
<RETURNS>gboolean  </RETURNS>
GPollableInputStream  *stream
</FUNCTION>
<FUNCTION>
<NAME>g_pollable_input_stream_is_readable</NAME>
<RETURNS>gboolean  </RETURNS>
GPollableInputStream  *stream
</FUNCTION>
<FUNCTION>
<NAME>g_pollable_input_stream_create_source</NAME>
<RETURNS>GSource  *</RETURNS>
GPollableInputStream  *stream, GCancellable          *cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_pollable_input_stream_read_nonblocking</NAME>
<RETURNS>gssize    </RETURNS>
GPollableInputStream  *stream, void                  *buffer, gsize                  count, GCancellable          *cancellable, GError               **error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_POLLABLE_OUTPUT_STREAM</NAME>
#define G_TYPE_POLLABLE_OUTPUT_STREAM               (g_pollable_output_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_POLLABLE_OUTPUT_STREAM</NAME>
#define G_POLLABLE_OUTPUT_STREAM(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_POLLABLE_OUTPUT_STREAM, GPollableOutputStream))
</MACRO>
<MACRO>
<NAME>G_IS_POLLABLE_OUTPUT_STREAM</NAME>
#define G_IS_POLLABLE_OUTPUT_STREAM(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_POLLABLE_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_POLLABLE_OUTPUT_STREAM_GET_INTERFACE</NAME>
#define G_POLLABLE_OUTPUT_STREAM_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_POLLABLE_OUTPUT_STREAM, GPollableOutputStreamInterface))
</MACRO>
<STRUCT>
<NAME>GPollableOutputStreamInterface</NAME>
struct _GPollableOutputStreamInterface
{
  GTypeInterface g_iface;

  /* Virtual Table */
  gboolean     (*can_poll)          (GPollableOutputStream  *stream);

  gboolean     (*is_writable)       (GPollableOutputStream  *stream);
  GSource *    (*create_source)     (GPollableOutputStream  *stream,
				     GCancellable           *cancellable);
  gssize       (*write_nonblocking) (GPollableOutputStream  *stream,
				     const void             *buffer,
				     gsize                   count,
				     GError                **error);
};
</STRUCT>
<FUNCTION>
<NAME>g_pollable_output_stream_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_pollable_output_stream_can_poll</NAME>
<RETURNS>gboolean  </RETURNS>
GPollableOutputStream  *stream
</FUNCTION>
<FUNCTION>
<NAME>g_pollable_output_stream_is_writable</NAME>
<RETURNS>gboolean  </RETURNS>
GPollableOutputStream  *stream
</FUNCTION>
<FUNCTION>
<NAME>g_pollable_output_stream_create_source</NAME>
<RETURNS>GSource  *</RETURNS>
GPollableOutputStream  *stream, GCancellable           *cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_pollable_output_stream_write_nonblocking</NAME>
<RETURNS>gssize    </RETURNS>
GPollableOutputStream  *stream, const void             *buffer, gsize                   count, GCancellable           *cancellable, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_pollable_source_new</NAME>
<RETURNS>GSource  *</RETURNS>
GObject        *pollable_stream
</FUNCTION>
<FUNCTION>
<NAME>g_pollable_source_new_full</NAME>
<RETURNS>GSource  *</RETURNS>
gpointer        pollable_stream, GSource        *child_source, GCancellable   *cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_pollable_stream_read</NAME>
<RETURNS>gssize    </RETURNS>
GInputStream   *stream, void           *buffer, gsize           count, gboolean        blocking, GCancellable   *cancellable, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_pollable_stream_write</NAME>
<RETURNS>gssize    </RETURNS>
GOutputStream  *stream, const void     *buffer, gsize           count, gboolean        blocking, GCancellable   *cancellable, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_pollable_stream_write_all</NAME>
<RETURNS>gboolean  </RETURNS>
GOutputStream  *stream, const void     *buffer, gsize           count, gboolean        blocking, gsize          *bytes_written, GCancellable   *cancellable, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>glib_should_use_portal</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>glib_network_available_in_sandbox</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_PROPERTY_ACTION</NAME>
#define G_TYPE_PROPERTY_ACTION                              (g_property_action_get_type ())
</MACRO>
<MACRO>
<NAME>G_PROPERTY_ACTION</NAME>
#define G_PROPERTY_ACTION(inst)                             (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_PROPERTY_ACTION, GPropertyAction))
</MACRO>
<MACRO>
<NAME>G_IS_PROPERTY_ACTION</NAME>
#define G_IS_PROPERTY_ACTION(inst)                          (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_PROPERTY_ACTION))
</MACRO>
<FUNCTION>
<NAME>g_property_action_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_property_action_new</NAME>
<RETURNS>GPropertyAction  *       </RETURNS>
const gchar *name, gpointer     object, const gchar *property_name
</FUNCTION>
<MACRO>
<NAME>G_TYPE_PROXY</NAME>
#define G_TYPE_PROXY		(g_proxy_get_type ())
</MACRO>
<MACRO>
<NAME>G_PROXY</NAME>
#define G_PROXY(o)		(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_PROXY, GProxy))
</MACRO>
<MACRO>
<NAME>G_IS_PROXY</NAME>
#define G_IS_PROXY(o)		(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_PROXY))
</MACRO>
<MACRO>
<NAME>G_PROXY_GET_IFACE</NAME>
#define G_PROXY_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_PROXY, GProxyInterface))
</MACRO>
<MACRO>
<NAME>G_PROXY_EXTENSION_POINT_NAME</NAME>
#define G_PROXY_EXTENSION_POINT_NAME "gio-proxy"
</MACRO>
<STRUCT>
<NAME>GProxyInterface</NAME>
struct _GProxyInterface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  GIOStream * (* connect)           (GProxy               *proxy,
				     GIOStream            *connection,
				     GProxyAddress        *proxy_address,
				     GCancellable         *cancellable,
				     GError              **error);

  void        (* connect_async)     (GProxy               *proxy,
				     GIOStream            *connection,
				     GProxyAddress	  *proxy_address,
				     GCancellable         *cancellable,
				     GAsyncReadyCallback   callback,
				     gpointer              user_data);

  GIOStream * (* connect_finish)    (GProxy               *proxy,
				     GAsyncResult         *result,
				     GError              **error);

  gboolean    (* supports_hostname) (GProxy             *proxy);
};
</STRUCT>
<FUNCTION>
<NAME>g_proxy_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_get_default_for_protocol</NAME>
<RETURNS>GProxy     *</RETURNS>
const gchar *protocol
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_connect</NAME>
<RETURNS>GIOStream  *</RETURNS>
GProxy               *proxy, GIOStream            *connection, GProxyAddress        *proxy_address, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_connect_async</NAME>
<RETURNS>void        </RETURNS>
GProxy               *proxy, GIOStream            *connection, GProxyAddress        *proxy_address, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_connect_finish</NAME>
<RETURNS>GIOStream  *</RETURNS>
GProxy               *proxy, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_supports_hostname</NAME>
<RETURNS>gboolean    </RETURNS>
GProxy               *proxy
</FUNCTION>
<MACRO>
<NAME>G_TYPE_PROXY_ADDRESS</NAME>
#define G_TYPE_PROXY_ADDRESS         (g_proxy_address_get_type ())
</MACRO>
<MACRO>
<NAME>G_PROXY_ADDRESS</NAME>
#define G_PROXY_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_PROXY_ADDRESS, GProxyAddress))
</MACRO>
<MACRO>
<NAME>G_PROXY_ADDRESS_CLASS</NAME>
#define G_PROXY_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_PROXY_ADDRESS, GProxyAddressClass))
</MACRO>
<MACRO>
<NAME>G_IS_PROXY_ADDRESS</NAME>
#define G_IS_PROXY_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_PROXY_ADDRESS))
</MACRO>
<MACRO>
<NAME>G_IS_PROXY_ADDRESS_CLASS</NAME>
#define G_IS_PROXY_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_PROXY_ADDRESS))
</MACRO>
<MACRO>
<NAME>G_PROXY_ADDRESS_GET_CLASS</NAME>
#define G_PROXY_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_PROXY_ADDRESS, GProxyAddressClass))
</MACRO>
<STRUCT>
<NAME>GProxyAddress</NAME>
struct _GProxyAddress
{
  GInetSocketAddress parent_instance;

  /*< private >*/
  GProxyAddressPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GProxyAddressClass</NAME>
struct _GProxyAddressClass
{
  GInetSocketAddressClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>g_proxy_address_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_address_new</NAME>
<RETURNS>GSocketAddress  *</RETURNS>
GInetAddress *inetaddr, guint16       port, const gchar  *protocol, const gchar  *dest_hostname, guint16       dest_port, const gchar  *username, const gchar  *password
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_address_get_protocol</NAME>
<RETURNS>const gchar     *</RETURNS>
GProxyAddress *proxy
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_address_get_destination_protocol</NAME>
<RETURNS>const gchar     *</RETURNS>
GProxyAddress *proxy
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_address_get_destination_hostname</NAME>
<RETURNS>const gchar     *</RETURNS>
GProxyAddress *proxy
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_address_get_destination_port</NAME>
<RETURNS>guint16          </RETURNS>
GProxyAddress *proxy
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_address_get_username</NAME>
<RETURNS>const gchar     *</RETURNS>
GProxyAddress *proxy
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_address_get_password</NAME>
<RETURNS>const gchar     *</RETURNS>
GProxyAddress *proxy
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_address_get_uri</NAME>
<RETURNS>const gchar     *</RETURNS>
GProxyAddress *proxy
</FUNCTION>
<STRUCT>
<NAME>GProxyAddressPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_PROXY_ADDRESS_ENUMERATOR</NAME>
#define G_TYPE_PROXY_ADDRESS_ENUMERATOR         (g_proxy_address_enumerator_get_type ())
</MACRO>
<MACRO>
<NAME>G_PROXY_ADDRESS_ENUMERATOR</NAME>
#define G_PROXY_ADDRESS_ENUMERATOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_PROXY_ADDRESS_ENUMERATOR, GProxyAddressEnumerator))
</MACRO>
<MACRO>
<NAME>G_PROXY_ADDRESS_ENUMERATOR_CLASS</NAME>
#define G_PROXY_ADDRESS_ENUMERATOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_PROXY_ADDRESS_ENUMERATOR, GProxyAddressEnumeratorClass))
</MACRO>
<MACRO>
<NAME>G_IS_PROXY_ADDRESS_ENUMERATOR</NAME>
#define G_IS_PROXY_ADDRESS_ENUMERATOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_PROXY_ADDRESS_ENUMERATOR))
</MACRO>
<MACRO>
<NAME>G_IS_PROXY_ADDRESS_ENUMERATOR_CLASS</NAME>
#define G_IS_PROXY_ADDRESS_ENUMERATOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_PROXY_ADDRESS_ENUMERATOR))
</MACRO>
<MACRO>
<NAME>G_PROXY_ADDRESS_ENUMERATOR_GET_CLASS</NAME>
#define G_PROXY_ADDRESS_ENUMERATOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_PROXY_ADDRESS_ENUMERATOR, GProxyAddressEnumeratorClass))
</MACRO>
<STRUCT>
<NAME>GProxyAddressEnumerator</NAME>
struct _GProxyAddressEnumerator
{
  GSocketAddressEnumerator parent_instance;
  GProxyAddressEnumeratorPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GProxyAddressEnumeratorClass</NAME>
struct _GProxyAddressEnumeratorClass
{
  GSocketAddressEnumeratorClass parent_class;

  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
  void (*_g_reserved7) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_proxy_address_enumerator_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GProxyAddressEnumeratorPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_PROXY_RESOLVER</NAME>
#define G_TYPE_PROXY_RESOLVER         (g_proxy_resolver_get_type ())
</MACRO>
<MACRO>
<NAME>G_PROXY_RESOLVER</NAME>
#define G_PROXY_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_PROXY_RESOLVER, GProxyResolver))
</MACRO>
<MACRO>
<NAME>G_IS_PROXY_RESOLVER</NAME>
#define G_IS_PROXY_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_PROXY_RESOLVER))
</MACRO>
<MACRO>
<NAME>G_PROXY_RESOLVER_GET_IFACE</NAME>
#define G_PROXY_RESOLVER_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), G_TYPE_PROXY_RESOLVER, GProxyResolverInterface))
</MACRO>
<MACRO>
<NAME>G_PROXY_RESOLVER_EXTENSION_POINT_NAME</NAME>
#define G_PROXY_RESOLVER_EXTENSION_POINT_NAME "gio-proxy-resolver"
</MACRO>
<STRUCT>
<NAME>GProxyResolverInterface</NAME>
struct _GProxyResolverInterface {
  GTypeInterface g_iface;

  /* Virtual Table */
  gboolean (* is_supported)  (GProxyResolver       *resolver);

  gchar	** (* lookup)        (GProxyResolver       *resolver,
			      const gchar          *uri,
			      GCancellable         *cancellable,
			      GError              **error);

  void     (* lookup_async)  (GProxyResolver       *resolver,
			      const gchar          *uri,
			      GCancellable         *cancellable,
			      GAsyncReadyCallback   callback,
			      gpointer              user_data);

  gchar	** (* lookup_finish) (GProxyResolver       *resolver,
			      GAsyncResult         *result,
			      GError              **error);
};
</STRUCT>
<FUNCTION>
<NAME>g_proxy_resolver_get_type</NAME>
<RETURNS>GType 		</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_resolver_get_default</NAME>
<RETURNS>GProxyResolver  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_resolver_is_supported</NAME>
<RETURNS>gboolean         </RETURNS>
GProxyResolver       *resolver
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_resolver_lookup</NAME>
<RETURNS>gchar 	      **</RETURNS>
GProxyResolver       *resolver, const gchar          *uri, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_resolver_lookup_async</NAME>
<RETURNS>void 		</RETURNS>
GProxyResolver       *resolver, const gchar          *uri, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_proxy_resolver_lookup_finish</NAME>
<RETURNS>gchar 	      **</RETURNS>
GProxyResolver       *resolver, GAsyncResult         *result, GError              **error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_REMOTE_ACTION_GROUP</NAME>
#define G_TYPE_REMOTE_ACTION_GROUP                          (g_remote_action_group_get_type ())
</MACRO>
<MACRO>
<NAME>G_REMOTE_ACTION_GROUP</NAME>
#define G_REMOTE_ACTION_GROUP(inst)                         (G_TYPE_CHECK_INSTANCE_CAST ((inst),                      \
                                                             G_TYPE_REMOTE_ACTION_GROUP, GRemoteActionGroup))
</MACRO>
<MACRO>
<NAME>G_IS_REMOTE_ACTION_GROUP</NAME>
#define G_IS_REMOTE_ACTION_GROUP(inst)                      (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                      \
                                                             G_TYPE_REMOTE_ACTION_GROUP))
</MACRO>
<MACRO>
<NAME>G_REMOTE_ACTION_GROUP_GET_IFACE</NAME>
#define G_REMOTE_ACTION_GROUP_GET_IFACE(inst)               (G_TYPE_INSTANCE_GET_INTERFACE ((inst),                   \
                                                             G_TYPE_REMOTE_ACTION_GROUP,                              \
                                                             GRemoteActionGroupInterface))
</MACRO>
<STRUCT>
<NAME>GRemoteActionGroupInterface</NAME>
struct _GRemoteActionGroupInterface
{
  GTypeInterface g_iface;

  void (* activate_action_full)     (GRemoteActionGroup *remote,
                                     const gchar        *action_name,
                                     GVariant           *parameter,
                                     GVariant           *platform_data);

  void (* change_action_state_full) (GRemoteActionGroup *remote,
                                     const gchar        *action_name,
                                     GVariant           *value,
                                     GVariant           *platform_data);
};
</STRUCT>
<FUNCTION>
<NAME>g_remote_action_group_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_remote_action_group_activate_action_full</NAME>
<RETURNS>void                     </RETURNS>
GRemoteActionGroup *remote, const gchar        *action_name, GVariant           *parameter, GVariant           *platform_data
</FUNCTION>
<FUNCTION>
<NAME>g_remote_action_group_change_action_state_full</NAME>
<RETURNS>void                     </RETURNS>
GRemoteActionGroup *remote, const gchar        *action_name, GVariant           *value, GVariant           *platform_data
</FUNCTION>
<MACRO>
<NAME>G_TYPE_RESOLVER</NAME>
#define G_TYPE_RESOLVER         (g_resolver_get_type ())
</MACRO>
<MACRO>
<NAME>G_RESOLVER</NAME>
#define G_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_RESOLVER, GResolver))
</MACRO>
<MACRO>
<NAME>G_RESOLVER_CLASS</NAME>
#define G_RESOLVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_RESOLVER, GResolverClass))
</MACRO>
<MACRO>
<NAME>G_IS_RESOLVER</NAME>
#define G_IS_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_RESOLVER))
</MACRO>
<MACRO>
<NAME>G_IS_RESOLVER_CLASS</NAME>
#define G_IS_RESOLVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_RESOLVER))
</MACRO>
<MACRO>
<NAME>G_RESOLVER_GET_CLASS</NAME>
#define G_RESOLVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_RESOLVER, GResolverClass))
</MACRO>
<STRUCT>
<NAME>GResolver</NAME>
struct _GResolver {
  GObject parent_instance;

  GResolverPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GResolverClass</NAME>
struct _GResolverClass {
  GObjectClass parent_class;

  /* Signals */
  void    ( *reload)                   (GResolver            *resolver);

  /* Virtual methods */
  GList * ( *lookup_by_name)           (GResolver            *resolver,
					const gchar          *hostname,
					GCancellable         *cancellable,
					GError              **error);
  void    ( *lookup_by_name_async)     (GResolver            *resolver,
					const gchar          *hostname,
					GCancellable         *cancellable,
					GAsyncReadyCallback   callback,
					gpointer              user_data);
  GList * ( *lookup_by_name_finish)    (GResolver            *resolver,
					GAsyncResult         *result,
					GError              **error);

  gchar * ( *lookup_by_address)        (GResolver            *resolver,
					GInetAddress         *address,
					GCancellable         *cancellable,
					GError              **error);
  void    ( *lookup_by_address_async)  (GResolver            *resolver,
					GInetAddress         *address,
					GCancellable         *cancellable,
					GAsyncReadyCallback   callback,
					gpointer              user_data);
  gchar * ( *lookup_by_address_finish) (GResolver            *resolver,
					GAsyncResult         *result,
					GError              **error);

  GList * ( *lookup_service)           (GResolver            *resolver,
					const gchar          *rrname,
					GCancellable         *cancellable,
					GError              **error);
  void    ( *lookup_service_async)     (GResolver            *resolver,
					const gchar          *rrname,
					GCancellable         *cancellable,
					GAsyncReadyCallback   callback,
					gpointer              user_data);
  GList * ( *lookup_service_finish)    (GResolver            *resolver,
					GAsyncResult         *result,
					GError              **error);

  GList * ( *lookup_records)           (GResolver            *resolver,
                                        const gchar          *rrname,
                                        GResolverRecordType   record_type,
                                        GCancellable         *cancellable,
                                        GError              **error);

  void    ( *lookup_records_async)     (GResolver            *resolver,
                                        const gchar          *rrname,
                                        GResolverRecordType   record_type,
                                        GCancellable         *cancellable,
                                        GAsyncReadyCallback   callback,
                                        gpointer              user_data);

  GList * ( *lookup_records_finish)    (GResolver            *resolver,
                                        GAsyncResult         *result,
                                        GError              **error);

  /* Padding for future expansion */
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);

};
</STRUCT>
<FUNCTION>
<NAME>g_resolver_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_resolver_get_default</NAME>
<RETURNS>GResolver  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_resolver_set_default</NAME>
<RETURNS>void        </RETURNS>
GResolver            *resolver
</FUNCTION>
<FUNCTION>
<NAME>g_resolver_lookup_by_name</NAME>
<RETURNS>GList      *</RETURNS>
GResolver            *resolver, const gchar          *hostname, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_resolver_lookup_by_name_async</NAME>
<RETURNS>void        </RETURNS>
GResolver            *resolver, const gchar          *hostname, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_resolver_lookup_by_name_finish</NAME>
<RETURNS>GList      *</RETURNS>
GResolver            *resolver, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_resolver_free_addresses</NAME>
<RETURNS>void        </RETURNS>
GList                *addresses
</FUNCTION>
<FUNCTION>
<NAME>g_resolver_lookup_by_address</NAME>
<RETURNS>gchar      *</RETURNS>
GResolver            *resolver, GInetAddress         *address, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_resolver_lookup_by_address_async</NAME>
<RETURNS>void        </RETURNS>
GResolver            *resolver, GInetAddress         *address, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_resolver_lookup_by_address_finish</NAME>
<RETURNS>gchar      *</RETURNS>
GResolver            *resolver, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_resolver_lookup_service</NAME>
<RETURNS>GList      *</RETURNS>
GResolver            *resolver, const gchar          *service, const gchar          *protocol, const gchar          *domain, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_resolver_lookup_service_async</NAME>
<RETURNS>void        </RETURNS>
GResolver            *resolver, const gchar          *service, const gchar          *protocol, const gchar          *domain, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_resolver_lookup_service_finish</NAME>
<RETURNS>GList      *</RETURNS>
GResolver            *resolver, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_resolver_lookup_records</NAME>
<RETURNS>GList      *</RETURNS>
GResolver            *resolver, const gchar          *rrname, GResolverRecordType   record_type, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_resolver_lookup_records_async</NAME>
<RETURNS>void        </RETURNS>
GResolver            *resolver, const gchar          *rrname, GResolverRecordType   record_type, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_resolver_lookup_records_finish</NAME>
<RETURNS>GList      *</RETURNS>
GResolver            *resolver, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_resolver_free_targets</NAME>
<RETURNS>void        </RETURNS>
GList                *targets
</FUNCTION>
<MACRO>
<NAME>G_RESOLVER_ERROR</NAME>
#define G_RESOLVER_ERROR (g_resolver_error_quark ())
</MACRO>
<FUNCTION>
<NAME>g_resolver_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GResolverPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_RESOURCE</NAME>
#define G_TYPE_RESOURCE (g_resource_get_type ())
</MACRO>
<MACRO>
<NAME>G_RESOURCE_ERROR</NAME>
#define G_RESOURCE_ERROR (g_resource_error_quark ())
</MACRO>
<FUNCTION>
<NAME>g_resource_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GStaticResource</NAME>
struct _GStaticResource {
  /*< private >*/
  const guint8 *data;
  gsize data_len;
  GResource *resource;
  GStaticResource *next;
  gpointer padding;
};
</STRUCT>
<FUNCTION>
<NAME>g_resource_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_resource_new_from_data</NAME>
<RETURNS>GResource  *   </RETURNS>
GBytes                *data, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_resource_ref</NAME>
<RETURNS>GResource  *   </RETURNS>
GResource             *resource
</FUNCTION>
<FUNCTION>
<NAME>g_resource_unref</NAME>
<RETURNS>void           </RETURNS>
GResource             *resource
</FUNCTION>
<FUNCTION>
<NAME>g_resource_load</NAME>
<RETURNS>GResource  *   </RETURNS>
const gchar           *filename, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_resource_open_stream</NAME>
<RETURNS>GInputStream  *</RETURNS>
GResource             *resource, const char            *path, GResourceLookupFlags   lookup_flags, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_resource_lookup_data</NAME>
<RETURNS>GBytes  *      </RETURNS>
GResource             *resource, const char            *path, GResourceLookupFlags   lookup_flags, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_resource_enumerate_children</NAME>
<RETURNS>char  **       </RETURNS>
GResource             *resource, const char            *path, GResourceLookupFlags   lookup_flags, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_resource_get_info</NAME>
<RETURNS>gboolean       </RETURNS>
GResource             *resource, const char            *path, GResourceLookupFlags   lookup_flags, gsize                 *size, guint32               *flags, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_resources_register</NAME>
<RETURNS>void           </RETURNS>
GResource             *resource
</FUNCTION>
<FUNCTION>
<NAME>g_resources_unregister</NAME>
<RETURNS>void           </RETURNS>
GResource             *resource
</FUNCTION>
<FUNCTION>
<NAME>g_resources_open_stream</NAME>
<RETURNS>GInputStream  *</RETURNS>
const char            *path, GResourceLookupFlags   lookup_flags, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_resources_lookup_data</NAME>
<RETURNS>GBytes  *      </RETURNS>
const char            *path, GResourceLookupFlags   lookup_flags, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_resources_enumerate_children</NAME>
<RETURNS>char  **       </RETURNS>
const char            *path, GResourceLookupFlags   lookup_flags, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_resources_get_info</NAME>
<RETURNS>gboolean       </RETURNS>
const char            *path, GResourceLookupFlags   lookup_flags, gsize                 *size, guint32               *flags, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_static_resource_init</NAME>
<RETURNS>void           </RETURNS>
GStaticResource *static_resource
</FUNCTION>
<FUNCTION>
<NAME>g_static_resource_fini</NAME>
<RETURNS>void           </RETURNS>
GStaticResource *static_resource
</FUNCTION>
<FUNCTION>
<NAME>g_static_resource_get_resource</NAME>
<RETURNS>GResource     *</RETURNS>
GStaticResource *static_resource
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SEEKABLE</NAME>
#define G_TYPE_SEEKABLE            (g_seekable_get_type ())
</MACRO>
<MACRO>
<NAME>G_SEEKABLE</NAME>
#define G_SEEKABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_SEEKABLE, GSeekable))
</MACRO>
<MACRO>
<NAME>G_IS_SEEKABLE</NAME>
#define G_IS_SEEKABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_SEEKABLE))
</MACRO>
<MACRO>
<NAME>G_SEEKABLE_GET_IFACE</NAME>
#define G_SEEKABLE_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_SEEKABLE, GSeekableIface))
</MACRO>
<STRUCT>
<NAME>GSeekableIface</NAME>
struct _GSeekableIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  goffset     (* tell)	         (GSeekable    *seekable);

  gboolean    (* can_seek)       (GSeekable    *seekable);
  gboolean    (* seek)	         (GSeekable    *seekable,
				  goffset       offset,
				  GSeekType     type,
				  GCancellable *cancellable,
				  GError      **error);

  gboolean    (* can_truncate)   (GSeekable    *seekable);
  gboolean    (* truncate_fn)    (GSeekable    *seekable,
				  goffset       offset,
				  GCancellable *cancellable,
				  GError       **error);

  /* TODO: Async seek/truncate */
};
</STRUCT>
<FUNCTION>
<NAME>g_seekable_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_seekable_tell</NAME>
<RETURNS>goffset   </RETURNS>
GSeekable     *seekable
</FUNCTION>
<FUNCTION>
<NAME>g_seekable_can_seek</NAME>
<RETURNS>gboolean  </RETURNS>
GSeekable     *seekable
</FUNCTION>
<FUNCTION>
<NAME>g_seekable_seek</NAME>
<RETURNS>gboolean  </RETURNS>
GSeekable     *seekable, goffset        offset, GSeekType      type, GCancellable  *cancellable, GError       **error
</FUNCTION>
<FUNCTION>
<NAME>g_seekable_can_truncate</NAME>
<RETURNS>gboolean  </RETURNS>
GSeekable     *seekable
</FUNCTION>
<FUNCTION>
<NAME>g_seekable_truncate</NAME>
<RETURNS>gboolean  </RETURNS>
GSeekable     *seekable, goffset        offset, GCancellable  *cancellable, GError       **error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SETTINGS</NAME>
#define G_TYPE_SETTINGS                                     (g_settings_get_type ())
</MACRO>
<MACRO>
<NAME>G_SETTINGS</NAME>
#define G_SETTINGS(inst)                                    (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SETTINGS, GSettings))
</MACRO>
<MACRO>
<NAME>G_SETTINGS_CLASS</NAME>
#define G_SETTINGS_CLASS(class)                             (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SETTINGS, GSettingsClass))
</MACRO>
<MACRO>
<NAME>G_IS_SETTINGS</NAME>
#define G_IS_SETTINGS(inst)                                 (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_SETTINGS))
</MACRO>
<MACRO>
<NAME>G_IS_SETTINGS_CLASS</NAME>
#define G_IS_SETTINGS_CLASS(class)                          (G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_SETTINGS))
</MACRO>
<MACRO>
<NAME>G_SETTINGS_GET_CLASS</NAME>
#define G_SETTINGS_GET_CLASS(inst)                          (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SETTINGS, GSettingsClass))
</MACRO>
<STRUCT>
<NAME>GSettingsClass</NAME>
struct _GSettingsClass
{
  GObjectClass parent_class;

  /* Signals */
  void        (*writable_changed)      (GSettings    *settings,
                                        const gchar  *key);
  void        (*changed)               (GSettings    *settings,
                                        const gchar  *key);
  gboolean    (*writable_change_event) (GSettings    *settings,
                                        GQuark        key);
  gboolean    (*change_event)          (GSettings    *settings,
                                        const GQuark *keys,
                                        gint          n_keys);

  gpointer padding[20];
};
</STRUCT>
<STRUCT>
<NAME>GSettings</NAME>
struct _GSettings
{
  GObject parent_instance;
  GSettingsPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>g_settings_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_settings_list_schemas</NAME>
<DEPRECATED/>
<RETURNS>const gchar  * const *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_settings_list_relocatable_schemas</NAME>
<DEPRECATED/>
<RETURNS>const gchar  * const *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_settings_new</NAME>
<RETURNS>GSettings  *             </RETURNS>
const gchar        *schema_id
</FUNCTION>
<FUNCTION>
<NAME>g_settings_new_with_path</NAME>
<RETURNS>GSettings  *             </RETURNS>
const gchar        *schema_id, const gchar        *path
</FUNCTION>
<FUNCTION>
<NAME>g_settings_new_with_backend</NAME>
<RETURNS>GSettings  *             </RETURNS>
const gchar        *schema_id, GSettingsBackend   *backend
</FUNCTION>
<FUNCTION>
<NAME>g_settings_new_with_backend_and_path</NAME>
<RETURNS>GSettings  *             </RETURNS>
const gchar        *schema_id, GSettingsBackend   *backend, const gchar        *path
</FUNCTION>
<FUNCTION>
<NAME>g_settings_new_full</NAME>
<RETURNS>GSettings  *             </RETURNS>
GSettingsSchema    *schema, GSettingsBackend   *backend, const gchar        *path
</FUNCTION>
<FUNCTION>
<NAME>g_settings_list_children</NAME>
<RETURNS>gchar  **                </RETURNS>
GSettings          *settings
</FUNCTION>
<FUNCTION>
<NAME>g_settings_list_keys</NAME>
<DEPRECATED/>
<RETURNS>gchar  **                </RETURNS>
GSettings          *settings
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_range</NAME>
<DEPRECATED/>
<RETURNS>GVariant  *              </RETURNS>
GSettings          *settings, const gchar        *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_range_check</NAME>
<DEPRECATED/>
<RETURNS>gboolean                 </RETURNS>
GSettings          *settings, const gchar        *key, GVariant           *value
</FUNCTION>
<FUNCTION>
<NAME>g_settings_set_value</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettings          *settings, const gchar        *key, GVariant           *value
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_value</NAME>
<RETURNS>GVariant  *              </RETURNS>
GSettings          *settings, const gchar        *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_user_value</NAME>
<RETURNS>GVariant  *              </RETURNS>
GSettings          *settings, const gchar        *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_default_value</NAME>
<RETURNS>GVariant  *              </RETURNS>
GSettings          *settings, const gchar        *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_set</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettings          *settings, const gchar        *key, const gchar        *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get</NAME>
<RETURNS>void                     </RETURNS>
GSettings          *settings, const gchar        *key, const gchar        *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_settings_reset</NAME>
<RETURNS>void                     </RETURNS>
GSettings          *settings, const gchar        *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_int</NAME>
<RETURNS>gint                     </RETURNS>
GSettings          *settings, const gchar        *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_set_int</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettings          *settings, const gchar        *key, gint                value
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_int64</NAME>
<RETURNS>gint64                   </RETURNS>
GSettings          *settings, const gchar        *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_set_int64</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettings          *settings, const gchar        *key, gint64              value
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_uint</NAME>
<RETURNS>guint                    </RETURNS>
GSettings          *settings, const gchar        *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_set_uint</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettings          *settings, const gchar        *key, guint               value
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_uint64</NAME>
<RETURNS>guint64                  </RETURNS>
GSettings          *settings, const gchar        *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_set_uint64</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettings          *settings, const gchar        *key, guint64             value
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_string</NAME>
<RETURNS>gchar  *                 </RETURNS>
GSettings          *settings, const gchar        *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_set_string</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettings          *settings, const gchar        *key, const gchar        *value
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_boolean</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettings          *settings, const gchar        *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_set_boolean</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettings          *settings, const gchar        *key, gboolean            value
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_double</NAME>
<RETURNS>gdouble                  </RETURNS>
GSettings          *settings, const gchar        *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_set_double</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettings          *settings, const gchar        *key, gdouble             value
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_strv</NAME>
<RETURNS>gchar  **                </RETURNS>
GSettings          *settings, const gchar        *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_set_strv</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettings          *settings, const gchar        *key, const gchar *const *value
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_enum</NAME>
<RETURNS>gint                     </RETURNS>
GSettings          *settings, const gchar        *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_set_enum</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettings          *settings, const gchar        *key, gint                value
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_flags</NAME>
<RETURNS>guint                    </RETURNS>
GSettings          *settings, const gchar        *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_set_flags</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettings          *settings, const gchar        *key, guint               value
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_child</NAME>
<RETURNS>GSettings  *             </RETURNS>
GSettings          *settings, const gchar        *name
</FUNCTION>
<FUNCTION>
<NAME>g_settings_is_writable</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettings          *settings, const gchar        *name
</FUNCTION>
<FUNCTION>
<NAME>g_settings_delay</NAME>
<RETURNS>void                     </RETURNS>
GSettings          *settings
</FUNCTION>
<FUNCTION>
<NAME>g_settings_apply</NAME>
<RETURNS>void                     </RETURNS>
GSettings          *settings
</FUNCTION>
<FUNCTION>
<NAME>g_settings_revert</NAME>
<RETURNS>void                     </RETURNS>
GSettings          *settings
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_has_unapplied</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettings          *settings
</FUNCTION>
<FUNCTION>
<NAME>g_settings_sync</NAME>
<RETURNS>void                     </RETURNS>
void
</FUNCTION>
<USER_FUNCTION>
<NAME>GSettingsBindSetMapping</NAME>
<RETURNS>GVariant *</RETURNS>
const GValue       *value,
                                                                         const GVariantType *expected_type,
                                                                         gpointer            user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GSettingsBindGetMapping</NAME>
<RETURNS>gboolean </RETURNS>
GValue             *value,
                                                                         GVariant           *variant,
                                                                         gpointer            user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GSettingsGetMapping</NAME>
<RETURNS>gboolean </RETURNS>
GVariant           *value,
                                                                         gpointer           *result,
                                                                         gpointer            user_data
</USER_FUNCTION>
<ENUM>
<NAME>GSettingsBindFlags</NAME>
typedef enum
{
  G_SETTINGS_BIND_DEFAULT,
  G_SETTINGS_BIND_GET            = (1<<0),
  G_SETTINGS_BIND_SET            = (1<<1),
  G_SETTINGS_BIND_NO_SENSITIVITY = (1<<2),
  G_SETTINGS_BIND_GET_NO_CHANGES = (1<<3),
  G_SETTINGS_BIND_INVERT_BOOLEAN = (1<<4)
} GSettingsBindFlags;
</ENUM>
<FUNCTION>
<NAME>g_settings_bind</NAME>
<RETURNS>void                     </RETURNS>
GSettings               *settings, const gchar             *key, gpointer                 object, const gchar             *property, GSettingsBindFlags       flags
</FUNCTION>
<FUNCTION>
<NAME>g_settings_bind_with_mapping</NAME>
<RETURNS>void                     </RETURNS>
GSettings               *settings, const gchar             *key, gpointer                 object, const gchar             *property, GSettingsBindFlags       flags, GSettingsBindGetMapping  get_mapping, GSettingsBindSetMapping  set_mapping, gpointer                 user_data, GDestroyNotify           destroy
</FUNCTION>
<FUNCTION>
<NAME>g_settings_bind_writable</NAME>
<RETURNS>void                     </RETURNS>
GSettings               *settings, const gchar             *key, gpointer                 object, const gchar             *property, gboolean                 inverted
</FUNCTION>
<FUNCTION>
<NAME>g_settings_unbind</NAME>
<RETURNS>void                     </RETURNS>
gpointer                 object, const gchar             *property
</FUNCTION>
<FUNCTION>
<NAME>g_settings_create_action</NAME>
<RETURNS>GAction  *               </RETURNS>
GSettings               *settings, const gchar             *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_get_mapped</NAME>
<RETURNS>gpointer                 </RETURNS>
GSettings               *settings, const gchar             *key, GSettingsGetMapping      mapping, gpointer                 user_data
</FUNCTION>
<STRUCT>
<NAME>GSettingsPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_SETTINGS_BACKEND</NAME>
#define G_TYPE_SETTINGS_BACKEND                             (g_settings_backend_get_type ())
</MACRO>
<MACRO>
<NAME>G_SETTINGS_BACKEND</NAME>
#define G_SETTINGS_BACKEND(inst)                            (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SETTINGS_BACKEND, GSettingsBackend))
</MACRO>
<MACRO>
<NAME>G_SETTINGS_BACKEND_CLASS</NAME>
#define G_SETTINGS_BACKEND_CLASS(class)                     (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SETTINGS_BACKEND, GSettingsBackendClass))
</MACRO>
<MACRO>
<NAME>G_IS_SETTINGS_BACKEND</NAME>
#define G_IS_SETTINGS_BACKEND(inst)                         (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SETTINGS_BACKEND))
</MACRO>
<MACRO>
<NAME>G_IS_SETTINGS_BACKEND_CLASS</NAME>
#define G_IS_SETTINGS_BACKEND_CLASS(class)                  (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_SETTINGS_BACKEND))
</MACRO>
<MACRO>
<NAME>G_SETTINGS_BACKEND_GET_CLASS</NAME>
#define G_SETTINGS_BACKEND_GET_CLASS(inst)                  (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SETTINGS_BACKEND, GSettingsBackendClass))
</MACRO>
<MACRO>
<NAME>G_SETTINGS_BACKEND_EXTENSION_POINT_NAME</NAME>
#define G_SETTINGS_BACKEND_EXTENSION_POINT_NAME "gsettings-backend"
</MACRO>
<STRUCT>
<NAME>GSettingsBackendClass</NAME>
struct _GSettingsBackendClass
{
  GObjectClass parent_class;

  GVariant *    (*read)             (GSettingsBackend    *backend,
                                     const gchar         *key,
                                     const GVariantType  *expected_type,
                                     gboolean             default_value);

  gboolean      (*get_writable)     (GSettingsBackend    *backend,
                                     const gchar         *key);

  gboolean      (*write)            (GSettingsBackend    *backend,
                                     const gchar         *key,
                                     GVariant            *value,
                                     gpointer             origin_tag);
  gboolean      (*write_tree)       (GSettingsBackend    *backend,
                                     GTree               *tree,
                                     gpointer             origin_tag);
  void          (*reset)            (GSettingsBackend    *backend,
                                     const gchar         *key,
                                     gpointer             origin_tag);

  void          (*subscribe)        (GSettingsBackend    *backend,
                                     const gchar         *name);
  void          (*unsubscribe)      (GSettingsBackend    *backend,
                                     const gchar         *name);
  void          (*sync)             (GSettingsBackend    *backend);

  GPermission * (*get_permission)   (GSettingsBackend    *backend,
                                     const gchar         *path);

  GVariant *    (*read_user_value)  (GSettingsBackend    *backend,
                                     const gchar         *key,
                                     const GVariantType  *expected_type);

  /*< private >*/
  gpointer padding[23];
};
</STRUCT>
<STRUCT>
<NAME>GSettingsBackend</NAME>
struct _GSettingsBackend
{
  GObject parent_instance;

  /*< private >*/
  GSettingsBackendPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>g_settings_backend_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_settings_backend_changed</NAME>
<RETURNS>void                     </RETURNS>
GSettingsBackend    *backend, const gchar         *key, gpointer             origin_tag
</FUNCTION>
<FUNCTION>
<NAME>g_settings_backend_path_changed</NAME>
<RETURNS>void                     </RETURNS>
GSettingsBackend    *backend, const gchar         *path, gpointer             origin_tag
</FUNCTION>
<FUNCTION>
<NAME>g_settings_backend_flatten_tree</NAME>
<RETURNS>void                     </RETURNS>
GTree               *tree, gchar              **path, const gchar       ***keys, GVariant          ***values
</FUNCTION>
<FUNCTION>
<NAME>g_settings_backend_keys_changed</NAME>
<RETURNS>void                     </RETURNS>
GSettingsBackend    *backend, const gchar         *path, gchar const * const *items, gpointer             origin_tag
</FUNCTION>
<FUNCTION>
<NAME>g_settings_backend_path_writable_changed</NAME>
<RETURNS>void                     </RETURNS>
GSettingsBackend    *backend, const gchar         *path
</FUNCTION>
<FUNCTION>
<NAME>g_settings_backend_writable_changed</NAME>
<RETURNS>void                     </RETURNS>
GSettingsBackend    *backend, const gchar         *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_backend_changed_tree</NAME>
<RETURNS>void                     </RETURNS>
GSettingsBackend    *backend, GTree               *tree, gpointer             origin_tag
</FUNCTION>
<FUNCTION>
<NAME>g_settings_backend_get_default</NAME>
<RETURNS>GSettingsBackend  *      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_keyfile_settings_backend_new</NAME>
<RETURNS>GSettingsBackend  *      </RETURNS>
const gchar         *filename, const gchar         *root_path, const gchar         *root_group
</FUNCTION>
<FUNCTION>
<NAME>g_null_settings_backend_new</NAME>
<RETURNS>GSettingsBackend  *      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_memory_settings_backend_new</NAME>
<RETURNS>GSettingsBackend  *      </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GSettingsBackendPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_SETTINGS_SCHEMA_SOURCE</NAME>
#define                 G_TYPE_SETTINGS_SCHEMA_SOURCE                   (g_settings_schema_source_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_settings_schema_source_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_source_get_default</NAME>
<RETURNS>GSettingsSchemaSource  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_source_ref</NAME>
<RETURNS>GSettingsSchemaSource  * </RETURNS>
GSettingsSchemaSource  *source
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_source_unref</NAME>
<RETURNS>void                     </RETURNS>
GSettingsSchemaSource  *source
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_source_new_from_directory</NAME>
<RETURNS>GSettingsSchemaSource  * </RETURNS>
const gchar            *directory, GSettingsSchemaSource  *parent, gboolean                trusted, GError                **error
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_source_lookup</NAME>
<RETURNS>GSettingsSchema  *       </RETURNS>
GSettingsSchemaSource  *source, const gchar            *schema_id, gboolean                recursive
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_source_list_schemas</NAME>
<RETURNS>void                     </RETURNS>
GSettingsSchemaSource   *source, gboolean                 recursive, gchar                 ***non_relocatable, gchar                 ***relocatable
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SETTINGS_SCHEMA</NAME>
#define                 G_TYPE_SETTINGS_SCHEMA                          (g_settings_schema_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_settings_schema_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_ref</NAME>
<RETURNS>GSettingsSchema  *       </RETURNS>
GSettingsSchema        *schema
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_unref</NAME>
<RETURNS>void                     </RETURNS>
GSettingsSchema        *schema
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_get_id</NAME>
<RETURNS>const gchar  *           </RETURNS>
GSettingsSchema        *schema
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_get_path</NAME>
<RETURNS>const gchar  *           </RETURNS>
GSettingsSchema        *schema
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_get_key</NAME>
<RETURNS>GSettingsSchemaKey  *    </RETURNS>
GSettingsSchema        *schema, const gchar            *name
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_has_key</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettingsSchema        *schema, const gchar            *name
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_list_keys</NAME>
<RETURNS>gchar **                 </RETURNS>
GSettingsSchema        *schema
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_list_children</NAME>
<RETURNS>gchar  **                </RETURNS>
GSettingsSchema        *schema
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SETTINGS_SCHEMA_KEY</NAME>
#define                 G_TYPE_SETTINGS_SCHEMA_KEY                      (g_settings_schema_key_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_settings_schema_key_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_key_ref</NAME>
<RETURNS>GSettingsSchemaKey  *    </RETURNS>
GSettingsSchemaKey     *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_key_unref</NAME>
<RETURNS>void                     </RETURNS>
GSettingsSchemaKey     *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_key_get_value_type</NAME>
<RETURNS>const GVariantType  *    </RETURNS>
GSettingsSchemaKey     *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_key_get_default_value</NAME>
<RETURNS>GVariant  *              </RETURNS>
GSettingsSchemaKey     *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_key_get_range</NAME>
<RETURNS>GVariant  *              </RETURNS>
GSettingsSchemaKey     *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_key_range_check</NAME>
<RETURNS>gboolean                 </RETURNS>
GSettingsSchemaKey     *key, GVariant               *value
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_key_get_name</NAME>
<RETURNS>const gchar  *           </RETURNS>
GSettingsSchemaKey     *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_key_get_summary</NAME>
<RETURNS>const gchar  *           </RETURNS>
GSettingsSchemaKey     *key
</FUNCTION>
<FUNCTION>
<NAME>g_settings_schema_key_get_description</NAME>
<RETURNS>const gchar  *           </RETURNS>
GSettingsSchemaKey     *key
</FUNCTION>
<STRUCT>
<NAME>GSettingsSchema</NAME>
</STRUCT>
<STRUCT>
<NAME>GSettingsSchemaKey</NAME>
</STRUCT>
<STRUCT>
<NAME>GSettingsSchemaSource</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_SIMPLE_ACTION</NAME>
#define G_TYPE_SIMPLE_ACTION                                (g_simple_action_get_type ())
</MACRO>
<MACRO>
<NAME>G_SIMPLE_ACTION</NAME>
#define G_SIMPLE_ACTION(inst)                               (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SIMPLE_ACTION, GSimpleAction))
</MACRO>
<MACRO>
<NAME>G_IS_SIMPLE_ACTION</NAME>
#define G_IS_SIMPLE_ACTION(inst)                            (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SIMPLE_ACTION))
</MACRO>
<FUNCTION>
<NAME>g_simple_action_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_simple_action_new</NAME>
<RETURNS>GSimpleAction  *         </RETURNS>
const gchar        *name, const GVariantType *parameter_type
</FUNCTION>
<FUNCTION>
<NAME>g_simple_action_new_stateful</NAME>
<RETURNS>GSimpleAction  *         </RETURNS>
const gchar        *name, const GVariantType *parameter_type, GVariant           *state
</FUNCTION>
<FUNCTION>
<NAME>g_simple_action_set_enabled</NAME>
<RETURNS>void                     </RETURNS>
GSimpleAction      *simple, gboolean            enabled
</FUNCTION>
<FUNCTION>
<NAME>g_simple_action_set_state</NAME>
<RETURNS>void                     </RETURNS>
GSimpleAction      *simple, GVariant           *value
</FUNCTION>
<FUNCTION>
<NAME>g_simple_action_set_state_hint</NAME>
<RETURNS>void                     </RETURNS>
GSimpleAction      *simple, GVariant           *state_hint
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SIMPLE_ACTION_GROUP</NAME>
#define G_TYPE_SIMPLE_ACTION_GROUP                          (g_simple_action_group_get_type ())
</MACRO>
<MACRO>
<NAME>G_SIMPLE_ACTION_GROUP</NAME>
#define G_SIMPLE_ACTION_GROUP(inst)                         (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SIMPLE_ACTION_GROUP, GSimpleActionGroup))
</MACRO>
<MACRO>
<NAME>G_SIMPLE_ACTION_GROUP_CLASS</NAME>
#define G_SIMPLE_ACTION_GROUP_CLASS(class)                  (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SIMPLE_ACTION_GROUP, GSimpleActionGroupClass))
</MACRO>
<MACRO>
<NAME>G_IS_SIMPLE_ACTION_GROUP</NAME>
#define G_IS_SIMPLE_ACTION_GROUP(inst)                      (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SIMPLE_ACTION_GROUP))
</MACRO>
<MACRO>
<NAME>G_IS_SIMPLE_ACTION_GROUP_CLASS</NAME>
#define G_IS_SIMPLE_ACTION_GROUP_CLASS(class)               (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_SIMPLE_ACTION_GROUP))
</MACRO>
<MACRO>
<NAME>G_SIMPLE_ACTION_GROUP_GET_CLASS</NAME>
#define G_SIMPLE_ACTION_GROUP_GET_CLASS(inst)               (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SIMPLE_ACTION_GROUP, GSimpleActionGroupClass))
</MACRO>
<STRUCT>
<NAME>GSimpleActionGroup</NAME>
struct _GSimpleActionGroup
{
  /*< private >*/
  GObject parent_instance;

  GSimpleActionGroupPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSimpleActionGroupClass</NAME>
struct _GSimpleActionGroupClass
{
  /*< private >*/
  GObjectClass parent_class;

  /*< private >*/
  gpointer padding[12];
};
</STRUCT>
<FUNCTION>
<NAME>g_simple_action_group_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_simple_action_group_new</NAME>
<RETURNS>GSimpleActionGroup  *    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_simple_action_group_lookup</NAME>
<DEPRECATED/>
<RETURNS>GAction  *               </RETURNS>
GSimpleActionGroup *simple, const gchar        *action_name
</FUNCTION>
<FUNCTION>
<NAME>g_simple_action_group_insert</NAME>
<DEPRECATED/>
<RETURNS>void                     </RETURNS>
GSimpleActionGroup *simple, GAction            *action
</FUNCTION>
<FUNCTION>
<NAME>g_simple_action_group_remove</NAME>
<DEPRECATED/>
<RETURNS>void                     </RETURNS>
GSimpleActionGroup *simple, const gchar        *action_name
</FUNCTION>
<FUNCTION>
<NAME>g_simple_action_group_add_entries</NAME>
<DEPRECATED/>
<RETURNS>void                     </RETURNS>
GSimpleActionGroup *simple, const GActionEntry *entries, gint                n_entries, gpointer            user_data
</FUNCTION>
<STRUCT>
<NAME>GSimpleActionGroupPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_SIMPLE_ASYNC_RESULT</NAME>
#define G_TYPE_SIMPLE_ASYNC_RESULT         (g_simple_async_result_get_type ())
</MACRO>
<MACRO>
<NAME>G_SIMPLE_ASYNC_RESULT</NAME>
#define G_SIMPLE_ASYNC_RESULT(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SIMPLE_ASYNC_RESULT, GSimpleAsyncResult))
</MACRO>
<MACRO>
<NAME>G_SIMPLE_ASYNC_RESULT_CLASS</NAME>
#define G_SIMPLE_ASYNC_RESULT_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_SIMPLE_ASYNC_RESULT, GSimpleAsyncResultClass))
</MACRO>
<MACRO>
<NAME>G_IS_SIMPLE_ASYNC_RESULT</NAME>
#define G_IS_SIMPLE_ASYNC_RESULT(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SIMPLE_ASYNC_RESULT))
</MACRO>
<MACRO>
<NAME>G_IS_SIMPLE_ASYNC_RESULT_CLASS</NAME>
#define G_IS_SIMPLE_ASYNC_RESULT_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_SIMPLE_ASYNC_RESULT))
</MACRO>
<MACRO>
<NAME>G_SIMPLE_ASYNC_RESULT_GET_CLASS</NAME>
#define G_SIMPLE_ASYNC_RESULT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_SIMPLE_ASYNC_RESULT, GSimpleAsyncResultClass))
</MACRO>
<FUNCTION>
<NAME>g_simple_async_result_get_type</NAME>
<RETURNS>GType                </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_new</NAME>
<DEPRECATED/>
<RETURNS>GSimpleAsyncResult  *</RETURNS>
GObject                 *source_object, GAsyncReadyCallback      callback, gpointer                 user_data, gpointer                 source_tag
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_new_error</NAME>
<DEPRECATED/>
<RETURNS>GSimpleAsyncResult  *</RETURNS>
GObject                 *source_object, GAsyncReadyCallback      callback, gpointer                 user_data, GQuark                   domain, gint                     code, const char              *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_new_from_error</NAME>
<DEPRECATED/>
<RETURNS>GSimpleAsyncResult  *</RETURNS>
GObject                 *source_object, GAsyncReadyCallback      callback, gpointer                 user_data, const GError            *error
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_new_take_error</NAME>
<DEPRECATED/>
<RETURNS>GSimpleAsyncResult  *</RETURNS>
GObject                 *source_object, GAsyncReadyCallback      callback, gpointer                 user_data, GError                  *error
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_set_op_res_gpointer</NAME>
<DEPRECATED/>
<RETURNS>void                 </RETURNS>
GSimpleAsyncResult      *simple, gpointer                 op_res, GDestroyNotify           destroy_op_res
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_get_op_res_gpointer</NAME>
<DEPRECATED/>
<RETURNS>gpointer             </RETURNS>
GSimpleAsyncResult      *simple
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_set_op_res_gssize</NAME>
<DEPRECATED/>
<RETURNS>void                 </RETURNS>
GSimpleAsyncResult      *simple, gssize                   op_res
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_get_op_res_gssize</NAME>
<DEPRECATED/>
<RETURNS>gssize               </RETURNS>
GSimpleAsyncResult      *simple
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_set_op_res_gboolean</NAME>
<DEPRECATED/>
<RETURNS>void                 </RETURNS>
GSimpleAsyncResult      *simple, gboolean                 op_res
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_get_op_res_gboolean</NAME>
<DEPRECATED/>
<RETURNS>gboolean             </RETURNS>
GSimpleAsyncResult      *simple
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_set_check_cancellable</NAME>
<RETURNS>void                 </RETURNS>
GSimpleAsyncResult *simple, GCancellable       *check_cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_get_source_tag</NAME>
<DEPRECATED/>
<RETURNS>gpointer             </RETURNS>
GSimpleAsyncResult      *simple
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_set_handle_cancellation</NAME>
<DEPRECATED/>
<RETURNS>void                 </RETURNS>
GSimpleAsyncResult      *simple, gboolean          handle_cancellation
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_complete</NAME>
<DEPRECATED/>
<RETURNS>void                 </RETURNS>
GSimpleAsyncResult      *simple
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_complete_in_idle</NAME>
<DEPRECATED/>
<RETURNS>void                 </RETURNS>
GSimpleAsyncResult      *simple
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_run_in_thread</NAME>
<DEPRECATED/>
<RETURNS>void                 </RETURNS>
GSimpleAsyncResult      *simple, GSimpleAsyncThreadFunc   func, int                      io_priority, GCancellable            *cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_set_from_error</NAME>
<DEPRECATED/>
<RETURNS>void                 </RETURNS>
GSimpleAsyncResult      *simple, const GError            *error
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_take_error</NAME>
<DEPRECATED/>
<RETURNS>void                 </RETURNS>
GSimpleAsyncResult      *simple, GError            *error
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_propagate_error</NAME>
<DEPRECATED/>
<RETURNS>gboolean             </RETURNS>
GSimpleAsyncResult      *simple, GError                 **dest
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_set_error</NAME>
<DEPRECATED/>
<RETURNS>void                 </RETURNS>
GSimpleAsyncResult      *simple, GQuark                   domain, gint                     code, const char              *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_set_error_va</NAME>
<DEPRECATED/>
<RETURNS>void                 </RETURNS>
GSimpleAsyncResult      *simple, GQuark                   domain, gint                     code, const char              *format, va_list                  args
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_result_is_valid</NAME>
<DEPRECATED/>
<RETURNS>gboolean             </RETURNS>
GAsyncResult            *result, GObject                 *source, gpointer                 source_tag
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_report_error_in_idle</NAME>
<DEPRECATED/>
<RETURNS>void  </RETURNS>
GObject            *object, GAsyncReadyCallback callback, gpointer            user_data, GQuark              domain, gint                code, const char         *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_report_gerror_in_idle</NAME>
<DEPRECATED/>
<RETURNS>void  </RETURNS>
GObject            *object, GAsyncReadyCallback callback, gpointer            user_data, const GError       *error
</FUNCTION>
<FUNCTION>
<NAME>g_simple_async_report_take_gerror_in_idle</NAME>
<DEPRECATED/>
<RETURNS>void  </RETURNS>
GObject            *object, GAsyncReadyCallback callback, gpointer            user_data, GError             *error
</FUNCTION>
<STRUCT>
<NAME>GSimpleAsyncResultClass</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_SIMPLE_IO_STREAM</NAME>
#define G_TYPE_SIMPLE_IO_STREAM                  (g_simple_io_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_SIMPLE_IO_STREAM</NAME>
#define G_SIMPLE_IO_STREAM(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_SIMPLE_IO_STREAM, GSimpleIOStream))
</MACRO>
<MACRO>
<NAME>G_IS_SIMPLE_IO_STREAM</NAME>
#define G_IS_SIMPLE_IO_STREAM(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_SIMPLE_IO_STREAM))
</MACRO>
<FUNCTION>
<NAME>g_simple_io_stream_get_type</NAME>
<RETURNS>GType                 </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_simple_io_stream_new</NAME>
<RETURNS>GIOStream            *</RETURNS>
GInputStream  *input_stream, GOutputStream *output_stream
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SIMPLE_PERMISSION</NAME>
#define G_TYPE_SIMPLE_PERMISSION      (g_simple_permission_get_type ())
</MACRO>
<MACRO>
<NAME>G_SIMPLE_PERMISSION</NAME>
#define G_SIMPLE_PERMISSION(inst)     (G_TYPE_CHECK_INSTANCE_CAST ((inst),   \
                                       G_TYPE_SIMPLE_PERMISSION,             \
                                       GSimplePermission))
</MACRO>
<MACRO>
<NAME>G_IS_SIMPLE_PERMISSION</NAME>
#define G_IS_SIMPLE_PERMISSION(inst)  (G_TYPE_CHECK_INSTANCE_TYPE ((inst),   \
                                       G_TYPE_SIMPLE_PERMISSION))
</MACRO>
<FUNCTION>
<NAME>g_simple_permission_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_simple_permission_new</NAME>
<RETURNS>GPermission  *           </RETURNS>
gboolean allowed
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SIMPLE_PROXY_RESOLVER</NAME>
#define G_TYPE_SIMPLE_PROXY_RESOLVER         (g_simple_proxy_resolver_get_type ())
</MACRO>
<MACRO>
<NAME>G_SIMPLE_PROXY_RESOLVER</NAME>
#define G_SIMPLE_PROXY_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SIMPLE_PROXY_RESOLVER, GSimpleProxyResolver))
</MACRO>
<MACRO>
<NAME>G_SIMPLE_PROXY_RESOLVER_CLASS</NAME>
#define G_SIMPLE_PROXY_RESOLVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_SIMPLE_PROXY_RESOLVER, GSimpleProxyResolverClass))
</MACRO>
<MACRO>
<NAME>G_IS_SIMPLE_PROXY_RESOLVER</NAME>
#define G_IS_SIMPLE_PROXY_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SIMPLE_PROXY_RESOLVER))
</MACRO>
<MACRO>
<NAME>G_IS_SIMPLE_PROXY_RESOLVER_CLASS</NAME>
#define G_IS_SIMPLE_PROXY_RESOLVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_SIMPLE_PROXY_RESOLVER))
</MACRO>
<MACRO>
<NAME>G_SIMPLE_PROXY_RESOLVER_GET_CLASS</NAME>
#define G_SIMPLE_PROXY_RESOLVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_SIMPLE_PROXY_RESOLVER, GSimpleProxyResolverClass))
</MACRO>
<STRUCT>
<NAME>GSimpleProxyResolver</NAME>
struct _GSimpleProxyResolver
{
  GObject parent_instance;

  /*< private >*/
  GSimpleProxyResolverPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSimpleProxyResolverClass</NAME>
struct _GSimpleProxyResolverClass
{
  GObjectClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_simple_proxy_resolver_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_simple_proxy_resolver_new</NAME>
<RETURNS>GProxyResolver  *</RETURNS>
const gchar           *default_proxy, gchar                **ignore_hosts
</FUNCTION>
<FUNCTION>
<NAME>g_simple_proxy_resolver_set_default_proxy</NAME>
<RETURNS>void             </RETURNS>
GSimpleProxyResolver  *resolver, const gchar           *default_proxy
</FUNCTION>
<FUNCTION>
<NAME>g_simple_proxy_resolver_set_ignore_hosts</NAME>
<RETURNS>void             </RETURNS>
GSimpleProxyResolver  *resolver, gchar                **ignore_hosts
</FUNCTION>
<FUNCTION>
<NAME>g_simple_proxy_resolver_set_uri_proxy</NAME>
<RETURNS>void             </RETURNS>
GSimpleProxyResolver  *resolver, const gchar           *uri_scheme, const gchar           *proxy
</FUNCTION>
<STRUCT>
<NAME>GSimpleProxyResolverPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_SOCKET</NAME>
#define G_TYPE_SOCKET                                       (g_socket_get_type ())
</MACRO>
<MACRO>
<NAME>G_SOCKET</NAME>
#define G_SOCKET(inst)                                      (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SOCKET, GSocket))
</MACRO>
<MACRO>
<NAME>G_SOCKET_CLASS</NAME>
#define G_SOCKET_CLASS(class)                               (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SOCKET, GSocketClass))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET</NAME>
#define G_IS_SOCKET(inst)                                   (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SOCKET))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET_CLASS</NAME>
#define G_IS_SOCKET_CLASS(class)                            (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_SOCKET))
</MACRO>
<MACRO>
<NAME>G_SOCKET_GET_CLASS</NAME>
#define G_SOCKET_GET_CLASS(inst)                            (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SOCKET, GSocketClass))
</MACRO>
<STRUCT>
<NAME>GSocketClass</NAME>
struct _GSocketClass
{
  GObjectClass parent_class;

  /*< private >*/

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
  void (*_g_reserved7) (void);
  void (*_g_reserved8) (void);
  void (*_g_reserved9) (void);
  void (*_g_reserved10) (void);
};
</STRUCT>
<STRUCT>
<NAME>GSocket</NAME>
struct _GSocket
{
  GObject parent_instance;
  GSocketPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>g_socket_get_type</NAME>
<RETURNS>GType                   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_socket_new</NAME>
<RETURNS>GSocket  *              </RETURNS>
GSocketFamily            family, GSocketType              type, GSocketProtocol          protocol, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_new_from_fd</NAME>
<RETURNS>GSocket  *              </RETURNS>
gint                     fd, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_fd</NAME>
<RETURNS>int                     </RETURNS>
GSocket                 *socket
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_family</NAME>
<RETURNS>GSocketFamily           </RETURNS>
GSocket                 *socket
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_socket_type</NAME>
<RETURNS>GSocketType             </RETURNS>
GSocket                 *socket
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_protocol</NAME>
<RETURNS>GSocketProtocol         </RETURNS>
GSocket                 *socket
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_local_address</NAME>
<RETURNS>GSocketAddress  *       </RETURNS>
GSocket                 *socket, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_remote_address</NAME>
<RETURNS>GSocketAddress  *       </RETURNS>
GSocket                 *socket, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_set_blocking</NAME>
<RETURNS>void                    </RETURNS>
GSocket                 *socket, gboolean                 blocking
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_blocking</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket
</FUNCTION>
<FUNCTION>
<NAME>g_socket_set_keepalive</NAME>
<RETURNS>void                    </RETURNS>
GSocket                 *socket, gboolean                 keepalive
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_keepalive</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_listen_backlog</NAME>
<RETURNS>gint                    </RETURNS>
GSocket                 *socket
</FUNCTION>
<FUNCTION>
<NAME>g_socket_set_listen_backlog</NAME>
<RETURNS>void                    </RETURNS>
GSocket                 *socket, gint                     backlog
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_timeout</NAME>
<RETURNS>guint                   </RETURNS>
GSocket                 *socket
</FUNCTION>
<FUNCTION>
<NAME>g_socket_set_timeout</NAME>
<RETURNS>void                    </RETURNS>
GSocket                 *socket, guint                    timeout
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_ttl</NAME>
<RETURNS>guint                   </RETURNS>
GSocket                 *socket
</FUNCTION>
<FUNCTION>
<NAME>g_socket_set_ttl</NAME>
<RETURNS>void                    </RETURNS>
GSocket                 *socket, guint                    ttl
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_broadcast</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket
</FUNCTION>
<FUNCTION>
<NAME>g_socket_set_broadcast</NAME>
<RETURNS>void                    </RETURNS>
GSocket                 *socket, gboolean		  broadcast
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_multicast_loopback</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket
</FUNCTION>
<FUNCTION>
<NAME>g_socket_set_multicast_loopback</NAME>
<RETURNS>void                    </RETURNS>
GSocket                 *socket, gboolean		  loopback
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_multicast_ttl</NAME>
<RETURNS>guint                   </RETURNS>
GSocket                 *socket
</FUNCTION>
<FUNCTION>
<NAME>g_socket_set_multicast_ttl</NAME>
<RETURNS>void                    </RETURNS>
GSocket                 *socket, guint                    ttl
</FUNCTION>
<FUNCTION>
<NAME>g_socket_is_connected</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket
</FUNCTION>
<FUNCTION>
<NAME>g_socket_bind</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket, GSocketAddress          *address, gboolean                 allow_reuse, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_join_multicast_group</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket, GInetAddress            *group, gboolean                 source_specific, const gchar             *iface, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_leave_multicast_group</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket, GInetAddress            *group, gboolean                 source_specific, const gchar             *iface, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_join_multicast_group_ssm</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket, GInetAddress            *group, GInetAddress            *source_specific, const gchar             *iface, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_leave_multicast_group_ssm</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket, GInetAddress            *group, GInetAddress            *source_specific, const gchar             *iface, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_connect</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket, GSocketAddress          *address, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_check_connect_result</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_available_bytes</NAME>
<RETURNS>gssize                  </RETURNS>
GSocket                 *socket
</FUNCTION>
<FUNCTION>
<NAME>g_socket_condition_check</NAME>
<RETURNS>GIOCondition            </RETURNS>
GSocket                 *socket, GIOCondition             condition
</FUNCTION>
<FUNCTION>
<NAME>g_socket_condition_wait</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket, GIOCondition             condition, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_condition_timed_wait</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket, GIOCondition             condition, gint64                   timeout, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_accept</NAME>
<RETURNS>GSocket  *              </RETURNS>
GSocket                 *socket, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_listen</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_receive</NAME>
<RETURNS>gssize                  </RETURNS>
GSocket                 *socket, gchar                   *buffer, gsize                    size, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_receive_from</NAME>
<RETURNS>gssize                  </RETURNS>
GSocket                 *socket, GSocketAddress         **address, gchar                   *buffer, gsize                    size, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_send</NAME>
<RETURNS>gssize                  </RETURNS>
GSocket                 *socket, const gchar             *buffer, gsize                    size, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_send_to</NAME>
<RETURNS>gssize                  </RETURNS>
GSocket                 *socket, GSocketAddress          *address, const gchar             *buffer, gsize                    size, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_receive_message</NAME>
<RETURNS>gssize                  </RETURNS>
GSocket                 *socket, GSocketAddress         **address, GInputVector            *vectors, gint                     num_vectors, GSocketControlMessage ***messages, gint                    *num_messages, gint                    *flags, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_send_message</NAME>
<RETURNS>gssize                  </RETURNS>
GSocket                 *socket, GSocketAddress          *address, GOutputVector           *vectors, gint                     num_vectors, GSocketControlMessage  **messages, gint                     num_messages, gint                     flags, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_receive_messages</NAME>
<RETURNS>gint                    </RETURNS>
GSocket                 *socket, GInputMessage           *messages, guint                    num_messages, gint                     flags, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_send_messages</NAME>
<RETURNS>gint                    </RETURNS>
GSocket                 *socket, GOutputMessage          *messages, guint                    num_messages, gint                     flags, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_close</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_shutdown</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket, gboolean                 shutdown_read, gboolean                 shutdown_write, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_is_closed</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket
</FUNCTION>
<FUNCTION>
<NAME>g_socket_create_source</NAME>
<RETURNS>GSource  *              </RETURNS>
GSocket                 *socket, GIOCondition             condition, GCancellable            *cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_socket_speaks_ipv4</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_credentials</NAME>
<RETURNS>GCredentials           *</RETURNS>
GSocket                 *socket, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_receive_with_blocking</NAME>
<RETURNS>gssize                  </RETURNS>
GSocket                 *socket, gchar                   *buffer, gsize                    size, gboolean                 blocking, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_send_with_blocking</NAME>
<RETURNS>gssize                  </RETURNS>
GSocket                 *socket, const gchar             *buffer, gsize                    size, gboolean                 blocking, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_get_option</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket, gint                     level, gint                     optname, gint                    *value, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_set_option</NAME>
<RETURNS>gboolean                </RETURNS>
GSocket                 *socket, gint                     level, gint                     optname, gint                     value, GError                 **error
</FUNCTION>
<STRUCT>
<NAME>GSocketPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_SOCKET_ADDRESS</NAME>
#define G_TYPE_SOCKET_ADDRESS         (g_socket_address_get_type ())
</MACRO>
<MACRO>
<NAME>G_SOCKET_ADDRESS</NAME>
#define G_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SOCKET_ADDRESS, GSocketAddress))
</MACRO>
<MACRO>
<NAME>G_SOCKET_ADDRESS_CLASS</NAME>
#define G_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_SOCKET_ADDRESS, GSocketAddressClass))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET_ADDRESS</NAME>
#define G_IS_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SOCKET_ADDRESS))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET_ADDRESS_CLASS</NAME>
#define G_IS_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_SOCKET_ADDRESS))
</MACRO>
<MACRO>
<NAME>G_SOCKET_ADDRESS_GET_CLASS</NAME>
#define G_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_SOCKET_ADDRESS, GSocketAddressClass))
</MACRO>
<STRUCT>
<NAME>GSocketAddress</NAME>
struct _GSocketAddress
{
  GObject parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GSocketAddressClass</NAME>
struct _GSocketAddressClass
{
  GObjectClass parent_class;

  GSocketFamily  (*get_family)      (GSocketAddress *address);

  gssize         (*get_native_size) (GSocketAddress *address);

  gboolean       (*to_native)       (GSocketAddress *address,
                                     gpointer        dest,
                                     gsize           destlen,
				     GError        **error);
};
</STRUCT>
<FUNCTION>
<NAME>g_socket_address_get_type</NAME>
<RETURNS>GType                  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_socket_address_get_family</NAME>
<RETURNS>GSocketFamily          </RETURNS>
GSocketAddress *address
</FUNCTION>
<FUNCTION>
<NAME>g_socket_address_new_from_native</NAME>
<RETURNS>GSocketAddress  *      </RETURNS>
gpointer        native, gsize           len
</FUNCTION>
<FUNCTION>
<NAME>g_socket_address_to_native</NAME>
<RETURNS>gboolean               </RETURNS>
GSocketAddress *address, gpointer        dest, gsize           destlen, GError        **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_address_get_native_size</NAME>
<RETURNS>gssize                 </RETURNS>
GSocketAddress *address
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SOCKET_ADDRESS_ENUMERATOR</NAME>
#define G_TYPE_SOCKET_ADDRESS_ENUMERATOR         (g_socket_address_enumerator_get_type ())
</MACRO>
<MACRO>
<NAME>G_SOCKET_ADDRESS_ENUMERATOR</NAME>
#define G_SOCKET_ADDRESS_ENUMERATOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SOCKET_ADDRESS_ENUMERATOR, GSocketAddressEnumerator))
</MACRO>
<MACRO>
<NAME>G_SOCKET_ADDRESS_ENUMERATOR_CLASS</NAME>
#define G_SOCKET_ADDRESS_ENUMERATOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_SOCKET_ADDRESS_ENUMERATOR, GSocketAddressEnumeratorClass))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET_ADDRESS_ENUMERATOR</NAME>
#define G_IS_SOCKET_ADDRESS_ENUMERATOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SOCKET_ADDRESS_ENUMERATOR))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET_ADDRESS_ENUMERATOR_CLASS</NAME>
#define G_IS_SOCKET_ADDRESS_ENUMERATOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_SOCKET_ADDRESS_ENUMERATOR))
</MACRO>
<MACRO>
<NAME>G_SOCKET_ADDRESS_ENUMERATOR_GET_CLASS</NAME>
#define G_SOCKET_ADDRESS_ENUMERATOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_SOCKET_ADDRESS_ENUMERATOR, GSocketAddressEnumeratorClass))
</MACRO>
<STRUCT>
<NAME>GSocketAddressEnumerator</NAME>
struct _GSocketAddressEnumerator
{
  GObject parent_instance;

};
</STRUCT>
<STRUCT>
<NAME>GSocketAddressEnumeratorClass</NAME>
struct _GSocketAddressEnumeratorClass
{
  GObjectClass parent_class;

  /* Virtual Table */

  GSocketAddress * (* next)        (GSocketAddressEnumerator  *enumerator,
				    GCancellable              *cancellable,
				    GError                   **error);

  void             (* next_async)  (GSocketAddressEnumerator  *enumerator,
				    GCancellable              *cancellable,
				    GAsyncReadyCallback        callback,
				    gpointer                   user_data);
  GSocketAddress * (* next_finish) (GSocketAddressEnumerator  *enumerator,
				    GAsyncResult              *result,
				    GError                   **error);
};
</STRUCT>
<FUNCTION>
<NAME>g_socket_address_enumerator_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_socket_address_enumerator_next</NAME>
<RETURNS>GSocketAddress  *</RETURNS>
GSocketAddressEnumerator  *enumerator, GCancellable              *cancellable, GError                   **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_address_enumerator_next_async</NAME>
<RETURNS>void             </RETURNS>
GSocketAddressEnumerator  *enumerator, GCancellable              *cancellable, GAsyncReadyCallback        callback, gpointer                   user_data
</FUNCTION>
<FUNCTION>
<NAME>g_socket_address_enumerator_next_finish</NAME>
<RETURNS>GSocketAddress  *</RETURNS>
GSocketAddressEnumerator  *enumerator, GAsyncResult              *result, GError                   **error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SOCKET_CLIENT</NAME>
#define G_TYPE_SOCKET_CLIENT                                (g_socket_client_get_type ())
</MACRO>
<MACRO>
<NAME>G_SOCKET_CLIENT</NAME>
#define G_SOCKET_CLIENT(inst)                               (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SOCKET_CLIENT, GSocketClient))
</MACRO>
<MACRO>
<NAME>G_SOCKET_CLIENT_CLASS</NAME>
#define G_SOCKET_CLIENT_CLASS(class)                        (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SOCKET_CLIENT, GSocketClientClass))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET_CLIENT</NAME>
#define G_IS_SOCKET_CLIENT(inst)                            (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SOCKET_CLIENT))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET_CLIENT_CLASS</NAME>
#define G_IS_SOCKET_CLIENT_CLASS(class)                     (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_SOCKET_CLIENT))
</MACRO>
<MACRO>
<NAME>G_SOCKET_CLIENT_GET_CLASS</NAME>
#define G_SOCKET_CLIENT_GET_CLASS(inst)                     (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SOCKET_CLIENT, GSocketClientClass))
</MACRO>
<STRUCT>
<NAME>GSocketClientClass</NAME>
struct _GSocketClientClass
{
  GObjectClass parent_class;

  void (* event) (GSocketClient       *client,
		  GSocketClientEvent  event,
		  GSocketConnectable  *connectable,
		  GIOStream           *connection);

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
};
</STRUCT>
<STRUCT>
<NAME>GSocketClient</NAME>
struct _GSocketClient
{
  GObject parent_instance;
  GSocketClientPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>g_socket_client_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_new</NAME>
<RETURNS>GSocketClient           *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_get_family</NAME>
<RETURNS>GSocketFamily            </RETURNS>
GSocketClient        *client
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_set_family</NAME>
<RETURNS>void                     </RETURNS>
GSocketClient        *client, GSocketFamily         family
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_get_socket_type</NAME>
<RETURNS>GSocketType              </RETURNS>
GSocketClient        *client
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_set_socket_type</NAME>
<RETURNS>void                     </RETURNS>
GSocketClient        *client, GSocketType           type
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_get_protocol</NAME>
<RETURNS>GSocketProtocol          </RETURNS>
GSocketClient        *client
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_set_protocol</NAME>
<RETURNS>void                     </RETURNS>
GSocketClient        *client, GSocketProtocol       protocol
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_get_local_address</NAME>
<RETURNS>GSocketAddress          *</RETURNS>
GSocketClient        *client
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_set_local_address</NAME>
<RETURNS>void                     </RETURNS>
GSocketClient        *client, GSocketAddress       *address
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_get_timeout</NAME>
<RETURNS>guint                    </RETURNS>
GSocketClient        *client
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_set_timeout</NAME>
<RETURNS>void                     </RETURNS>
GSocketClient        *client, guint                 timeout
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_get_enable_proxy</NAME>
<RETURNS>gboolean                 </RETURNS>
GSocketClient        *client
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_set_enable_proxy</NAME>
<RETURNS>void                     </RETURNS>
GSocketClient        *client, gboolean	      enable
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_get_tls</NAME>
<RETURNS>gboolean                 </RETURNS>
GSocketClient        *client
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_set_tls</NAME>
<RETURNS>void                     </RETURNS>
GSocketClient        *client, gboolean              tls
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_get_tls_validation_flags</NAME>
<RETURNS>GTlsCertificateFlags     </RETURNS>
GSocketClient        *client
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_set_tls_validation_flags</NAME>
<RETURNS>void                     </RETURNS>
GSocketClient        *client, GTlsCertificateFlags  flags
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_get_proxy_resolver</NAME>
<RETURNS>GProxyResolver          *</RETURNS>
GSocketClient        *client
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_set_proxy_resolver</NAME>
<RETURNS>void                     </RETURNS>
GSocketClient        *client, GProxyResolver       *proxy_resolver
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_connect</NAME>
<RETURNS>GSocketConnection  *     </RETURNS>
GSocketClient        *client, GSocketConnectable   *connectable, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_connect_to_host</NAME>
<RETURNS>GSocketConnection  *     </RETURNS>
GSocketClient        *client, const gchar          *host_and_port, guint16               default_port, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_connect_to_service</NAME>
<RETURNS>GSocketConnection  *     </RETURNS>
GSocketClient        *client, const gchar          *domain, const gchar          *service, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_connect_to_uri</NAME>
<RETURNS>GSocketConnection  *     </RETURNS>
GSocketClient        *client, const gchar          *uri, guint16               default_port, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_connect_async</NAME>
<RETURNS>void                     </RETURNS>
GSocketClient        *client, GSocketConnectable   *connectable, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_connect_finish</NAME>
<RETURNS>GSocketConnection  *     </RETURNS>
GSocketClient        *client, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_connect_to_host_async</NAME>
<RETURNS>void                     </RETURNS>
GSocketClient        *client, const gchar          *host_and_port, guint16               default_port, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_connect_to_host_finish</NAME>
<RETURNS>GSocketConnection  *     </RETURNS>
GSocketClient        *client, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_connect_to_service_async</NAME>
<RETURNS>void                     </RETURNS>
GSocketClient        *client, const gchar          *domain, const gchar          *service, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_connect_to_service_finish</NAME>
<RETURNS>GSocketConnection  *     </RETURNS>
GSocketClient        *client, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_connect_to_uri_async</NAME>
<RETURNS>void                     </RETURNS>
GSocketClient        *client, const gchar          *uri, guint16               default_port, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_connect_to_uri_finish</NAME>
<RETURNS>GSocketConnection  *     </RETURNS>
GSocketClient        *client, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_client_add_application_proxy</NAME>
<RETURNS>void 			</RETURNS>
GSocketClient        *client, const gchar          *protocol
</FUNCTION>
<STRUCT>
<NAME>GSocketClientPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_SOCKET_CONNECTABLE</NAME>
#define G_TYPE_SOCKET_CONNECTABLE            (g_socket_connectable_get_type ())
</MACRO>
<MACRO>
<NAME>G_SOCKET_CONNECTABLE</NAME>
#define G_SOCKET_CONNECTABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_SOCKET_CONNECTABLE, GSocketConnectable))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET_CONNECTABLE</NAME>
#define G_IS_SOCKET_CONNECTABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_SOCKET_CONNECTABLE))
</MACRO>
<MACRO>
<NAME>G_SOCKET_CONNECTABLE_GET_IFACE</NAME>
#define G_SOCKET_CONNECTABLE_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_SOCKET_CONNECTABLE, GSocketConnectableIface))
</MACRO>
<STRUCT>
<NAME>GSocketConnectableIface</NAME>
struct _GSocketConnectableIface
{
  GTypeInterface g_iface;

  /* Virtual Table */

  GSocketAddressEnumerator * (* enumerate)       (GSocketConnectable *connectable);

  GSocketAddressEnumerator * (* proxy_enumerate) (GSocketConnectable *connectable);

  gchar                    * (* to_string)       (GSocketConnectable *connectable);
};
</STRUCT>
<FUNCTION>
<NAME>g_socket_connectable_get_type</NAME>
<RETURNS>GType                      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_socket_connectable_enumerate</NAME>
<RETURNS>GSocketAddressEnumerator  *</RETURNS>
GSocketConnectable *connectable
</FUNCTION>
<FUNCTION>
<NAME>g_socket_connectable_proxy_enumerate</NAME>
<RETURNS>GSocketAddressEnumerator  *</RETURNS>
GSocketConnectable *connectable
</FUNCTION>
<FUNCTION>
<NAME>g_socket_connectable_to_string</NAME>
<RETURNS>gchar                     *</RETURNS>
GSocketConnectable *connectable
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SOCKET_CONNECTION</NAME>
#define G_TYPE_SOCKET_CONNECTION                            (g_socket_connection_get_type ())
</MACRO>
<MACRO>
<NAME>G_SOCKET_CONNECTION</NAME>
#define G_SOCKET_CONNECTION(inst)                           (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SOCKET_CONNECTION, GSocketConnection))
</MACRO>
<MACRO>
<NAME>G_SOCKET_CONNECTION_CLASS</NAME>
#define G_SOCKET_CONNECTION_CLASS(class)                    (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SOCKET_CONNECTION, GSocketConnectionClass))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET_CONNECTION</NAME>
#define G_IS_SOCKET_CONNECTION(inst)                        (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SOCKET_CONNECTION))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET_CONNECTION_CLASS</NAME>
#define G_IS_SOCKET_CONNECTION_CLASS(class)                 (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_SOCKET_CONNECTION))
</MACRO>
<MACRO>
<NAME>G_SOCKET_CONNECTION_GET_CLASS</NAME>
#define G_SOCKET_CONNECTION_GET_CLASS(inst)                 (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SOCKET_CONNECTION, GSocketConnectionClass))
</MACRO>
<STRUCT>
<NAME>GSocketConnectionClass</NAME>
struct _GSocketConnectionClass
{
  GIOStreamClass parent_class;

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
};
</STRUCT>
<STRUCT>
<NAME>GSocketConnection</NAME>
struct _GSocketConnection
{
  GIOStream parent_instance;
  GSocketConnectionPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>g_socket_connection_get_type</NAME>
<RETURNS>GType               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_socket_connection_is_connected</NAME>
<RETURNS>gboolean            </RETURNS>
GSocketConnection  *connection
</FUNCTION>
<FUNCTION>
<NAME>g_socket_connection_connect</NAME>
<RETURNS>gboolean            </RETURNS>
GSocketConnection  *connection, GSocketAddress     *address, GCancellable       *cancellable, GError            **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_connection_connect_async</NAME>
<RETURNS>void                </RETURNS>
GSocketConnection  *connection, GSocketAddress     *address, GCancellable       *cancellable, GAsyncReadyCallback callback, gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>g_socket_connection_connect_finish</NAME>
<RETURNS>gboolean            </RETURNS>
GSocketConnection  *connection, GAsyncResult       *result, GError            **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_connection_get_socket</NAME>
<RETURNS>GSocket            *</RETURNS>
GSocketConnection  *connection
</FUNCTION>
<FUNCTION>
<NAME>g_socket_connection_get_local_address</NAME>
<RETURNS>GSocketAddress     *</RETURNS>
GSocketConnection  *connection, GError            **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_connection_get_remote_address</NAME>
<RETURNS>GSocketAddress     *</RETURNS>
GSocketConnection  *connection, GError            **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_connection_factory_register_type</NAME>
<RETURNS>void                </RETURNS>
GType               g_type, GSocketFamily       family, GSocketType         type, gint                protocol
</FUNCTION>
<FUNCTION>
<NAME>g_socket_connection_factory_lookup_type</NAME>
<RETURNS>GType               </RETURNS>
GSocketFamily       family, GSocketType         type, gint                protocol_id
</FUNCTION>
<FUNCTION>
<NAME>g_socket_connection_factory_create_connection</NAME>
<RETURNS>GSocketConnection  *</RETURNS>
GSocket            *socket
</FUNCTION>
<STRUCT>
<NAME>GSocketConnectionPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_SOCKET_CONTROL_MESSAGE</NAME>
#define G_TYPE_SOCKET_CONTROL_MESSAGE                       (g_socket_control_message_get_type ())
</MACRO>
<MACRO>
<NAME>G_SOCKET_CONTROL_MESSAGE</NAME>
#define G_SOCKET_CONTROL_MESSAGE(inst)                      (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SOCKET_CONTROL_MESSAGE,                          \
                                                             GSocketControlMessage))
</MACRO>
<MACRO>
<NAME>G_SOCKET_CONTROL_MESSAGE_CLASS</NAME>
#define G_SOCKET_CONTROL_MESSAGE_CLASS(class)               (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SOCKET_CONTROL_MESSAGE,                          \
                                                             GSocketControlMessageClass))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET_CONTROL_MESSAGE</NAME>
#define G_IS_SOCKET_CONTROL_MESSAGE(inst)                   (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SOCKET_CONTROL_MESSAGE))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET_CONTROL_MESSAGE_CLASS</NAME>
#define G_IS_SOCKET_CONTROL_MESSAGE_CLASS(class)            (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_SOCKET_CONTROL_MESSAGE))
</MACRO>
<MACRO>
<NAME>G_SOCKET_CONTROL_MESSAGE_GET_CLASS</NAME>
#define G_SOCKET_CONTROL_MESSAGE_GET_CLASS(inst)            (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SOCKET_CONTROL_MESSAGE,                          \
                                                             GSocketControlMessageClass))
</MACRO>
<STRUCT>
<NAME>GSocketControlMessageClass</NAME>
struct _GSocketControlMessageClass
{
  GObjectClass parent_class;

  gsize                  (* get_size)  (GSocketControlMessage  *message);
  int                    (* get_level) (GSocketControlMessage  *message);
  int                    (* get_type)  (GSocketControlMessage  *message);
  void                   (* serialize) (GSocketControlMessage  *message,
					gpointer                data);
  GSocketControlMessage *(* deserialize) (int                   level,
					  int                   type,
					  gsize                 size,
					  gpointer              data);

  /*< private >*/

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<STRUCT>
<NAME>GSocketControlMessage</NAME>
struct _GSocketControlMessage
{
  GObject parent_instance;
  GSocketControlMessagePrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>g_socket_control_message_get_type</NAME>
<RETURNS>GType                   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_socket_control_message_get_size</NAME>
<RETURNS>gsize                   </RETURNS>
GSocketControlMessage *message
</FUNCTION>
<FUNCTION>
<NAME>g_socket_control_message_get_level</NAME>
<RETURNS>int                     </RETURNS>
GSocketControlMessage *message
</FUNCTION>
<FUNCTION>
<NAME>g_socket_control_message_get_msg_type</NAME>
<RETURNS>int                     </RETURNS>
GSocketControlMessage *message
</FUNCTION>
<FUNCTION>
<NAME>g_socket_control_message_serialize</NAME>
<RETURNS>void                    </RETURNS>
GSocketControlMessage *message, gpointer               data
</FUNCTION>
<FUNCTION>
<NAME>g_socket_control_message_deserialize</NAME>
<RETURNS>GSocketControlMessage  *</RETURNS>
int                    level, int                    type, gsize                  size, gpointer               data
</FUNCTION>
<STRUCT>
<NAME>GSocketControlMessagePrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_SOCKET_LISTENER</NAME>
#define G_TYPE_SOCKET_LISTENER                              (g_socket_listener_get_type ())
</MACRO>
<MACRO>
<NAME>G_SOCKET_LISTENER</NAME>
#define G_SOCKET_LISTENER(inst)                             (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SOCKET_LISTENER, GSocketListener))
</MACRO>
<MACRO>
<NAME>G_SOCKET_LISTENER_CLASS</NAME>
#define G_SOCKET_LISTENER_CLASS(class)                      (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SOCKET_LISTENER, GSocketListenerClass))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET_LISTENER</NAME>
#define G_IS_SOCKET_LISTENER(inst)                          (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SOCKET_LISTENER))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET_LISTENER_CLASS</NAME>
#define G_IS_SOCKET_LISTENER_CLASS(class)                   (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_SOCKET_LISTENER))
</MACRO>
<MACRO>
<NAME>G_SOCKET_LISTENER_GET_CLASS</NAME>
#define G_SOCKET_LISTENER_GET_CLASS(inst)                   (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SOCKET_LISTENER, GSocketListenerClass))
</MACRO>
<STRUCT>
<NAME>GSocketListenerClass</NAME>
struct _GSocketListenerClass
{
  GObjectClass parent_class;

  void (* changed) (GSocketListener *listener);

  void (* event) (GSocketListener      *listener,
                  GSocketListenerEvent  event,
                  GSocket              *socket);

  /* Padding for future expansion */
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
};
</STRUCT>
<STRUCT>
<NAME>GSocketListener</NAME>
struct _GSocketListener
{
  GObject parent_instance;
  GSocketListenerPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>g_socket_listener_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_socket_listener_new</NAME>
<RETURNS>GSocketListener  *       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_socket_listener_set_backlog</NAME>
<RETURNS>void                     </RETURNS>
GSocketListener     *listener, int                  listen_backlog
</FUNCTION>
<FUNCTION>
<NAME>g_socket_listener_add_socket</NAME>
<RETURNS>gboolean                 </RETURNS>
GSocketListener     *listener, GSocket             *socket, GObject             *source_object, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_listener_add_address</NAME>
<RETURNS>gboolean                 </RETURNS>
GSocketListener     *listener, GSocketAddress      *address, GSocketType          type, GSocketProtocol      protocol, GObject             *source_object, GSocketAddress     **effective_address, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_listener_add_inet_port</NAME>
<RETURNS>gboolean                 </RETURNS>
GSocketListener     *listener, guint16              port, GObject             *source_object, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_listener_add_any_inet_port</NAME>
<RETURNS>guint16                  </RETURNS>
GSocketListener     *listener, GObject             *source_object, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_listener_accept_socket</NAME>
<RETURNS>GSocket  *               </RETURNS>
GSocketListener      *listener, GObject             **source_object, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_listener_accept_socket_async</NAME>
<RETURNS>void                     </RETURNS>
GSocketListener      *listener, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_socket_listener_accept_socket_finish</NAME>
<RETURNS>GSocket  *               </RETURNS>
GSocketListener      *listener, GAsyncResult         *result, GObject             **source_object, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_listener_accept</NAME>
<RETURNS>GSocketConnection  *     </RETURNS>
GSocketListener      *listener, GObject             **source_object, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_listener_accept_async</NAME>
<RETURNS>void                     </RETURNS>
GSocketListener      *listener, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_socket_listener_accept_finish</NAME>
<RETURNS>GSocketConnection  *     </RETURNS>
GSocketListener      *listener, GAsyncResult         *result, GObject             **source_object, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_socket_listener_close</NAME>
<RETURNS>void                     </RETURNS>
GSocketListener      *listener
</FUNCTION>
<STRUCT>
<NAME>GSocketListenerPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_SOCKET_SERVICE</NAME>
#define G_TYPE_SOCKET_SERVICE                               (g_socket_service_get_type ())
</MACRO>
<MACRO>
<NAME>G_SOCKET_SERVICE</NAME>
#define G_SOCKET_SERVICE(inst)                              (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_SOCKET_SERVICE, GSocketService))
</MACRO>
<MACRO>
<NAME>G_SOCKET_SERVICE_CLASS</NAME>
#define G_SOCKET_SERVICE_CLASS(class)                       (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_SOCKET_SERVICE, GSocketServiceClass))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET_SERVICE</NAME>
#define G_IS_SOCKET_SERVICE(inst)                           (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_SOCKET_SERVICE))
</MACRO>
<MACRO>
<NAME>G_IS_SOCKET_SERVICE_CLASS</NAME>
#define G_IS_SOCKET_SERVICE_CLASS(class)                    (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_SOCKET_SERVICE))
</MACRO>
<MACRO>
<NAME>G_SOCKET_SERVICE_GET_CLASS</NAME>
#define G_SOCKET_SERVICE_GET_CLASS(inst)                    (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_SOCKET_SERVICE, GSocketServiceClass))
</MACRO>
<STRUCT>
<NAME>GSocketServiceClass</NAME>
struct _GSocketServiceClass
{
  GSocketListenerClass parent_class;

  gboolean (* incoming) (GSocketService    *service,
                         GSocketConnection *connection,
			 GObject           *source_object);

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
};
</STRUCT>
<STRUCT>
<NAME>GSocketService</NAME>
struct _GSocketService
{
  GSocketListener parent_instance;
  GSocketServicePrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>g_socket_service_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_socket_service_new</NAME>
<RETURNS>GSocketService  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_socket_service_start</NAME>
<RETURNS>void             </RETURNS>
GSocketService *service
</FUNCTION>
<FUNCTION>
<NAME>g_socket_service_stop</NAME>
<RETURNS>void             </RETURNS>
GSocketService *service
</FUNCTION>
<FUNCTION>
<NAME>g_socket_service_is_active</NAME>
<RETURNS>gboolean         </RETURNS>
GSocketService *service
</FUNCTION>
<STRUCT>
<NAME>GSocketServicePrivate</NAME>
</STRUCT>
<FUNCTION>
<NAME>g_srv_target_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SRV_TARGET</NAME>
#define G_TYPE_SRV_TARGET (g_srv_target_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_srv_target_new</NAME>
<RETURNS>GSrvTarget   *</RETURNS>
const gchar *hostname, guint16      port, guint16      priority, guint16      weight
</FUNCTION>
<FUNCTION>
<NAME>g_srv_target_copy</NAME>
<RETURNS>GSrvTarget   *</RETURNS>
GSrvTarget  *target
</FUNCTION>
<FUNCTION>
<NAME>g_srv_target_free</NAME>
<RETURNS>void          </RETURNS>
GSrvTarget  *target
</FUNCTION>
<FUNCTION>
<NAME>g_srv_target_get_hostname</NAME>
<RETURNS>const gchar  *</RETURNS>
GSrvTarget  *target
</FUNCTION>
<FUNCTION>
<NAME>g_srv_target_get_port</NAME>
<RETURNS>guint16       </RETURNS>
GSrvTarget  *target
</FUNCTION>
<FUNCTION>
<NAME>g_srv_target_get_priority</NAME>
<RETURNS>guint16       </RETURNS>
GSrvTarget  *target
</FUNCTION>
<FUNCTION>
<NAME>g_srv_target_get_weight</NAME>
<RETURNS>guint16       </RETURNS>
GSrvTarget  *target
</FUNCTION>
<FUNCTION>
<NAME>g_srv_target_list_sort</NAME>
<RETURNS>GList        *</RETURNS>
GList       *targets
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SUBPROCESS</NAME>
#define G_TYPE_SUBPROCESS         (g_subprocess_get_type ())
</MACRO>
<MACRO>
<NAME>G_SUBPROCESS</NAME>
#define G_SUBPROCESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SUBPROCESS, GSubprocess))
</MACRO>
<MACRO>
<NAME>G_IS_SUBPROCESS</NAME>
#define G_IS_SUBPROCESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SUBPROCESS))
</MACRO>
<FUNCTION>
<NAME>g_subprocess_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_new</NAME>
<RETURNS>GSubprocess  *    </RETURNS>
GSubprocessFlags        flags, GError                **error, const gchar            *argv0, ...
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_newv</NAME>
<RETURNS>GSubprocess  *    </RETURNS>
const gchar * const  *argv, GSubprocessFlags      flags, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_get_stdin_pipe</NAME>
<RETURNS>GOutputStream  *  </RETURNS>
GSubprocess          *subprocess
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_get_stdout_pipe</NAME>
<RETURNS>GInputStream  *   </RETURNS>
GSubprocess          *subprocess
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_get_stderr_pipe</NAME>
<RETURNS>GInputStream  *   </RETURNS>
GSubprocess          *subprocess
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_get_identifier</NAME>
<RETURNS>const gchar  *    </RETURNS>
GSubprocess          *subprocess
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_send_signal</NAME>
<RETURNS>void              </RETURNS>
GSubprocess          *subprocess, gint                  signal_num
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_force_exit</NAME>
<RETURNS>void              </RETURNS>
GSubprocess          *subprocess
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_wait</NAME>
<RETURNS>gboolean          </RETURNS>
GSubprocess          *subprocess, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_wait_async</NAME>
<RETURNS>void              </RETURNS>
GSubprocess          *subprocess, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_wait_finish</NAME>
<RETURNS>gboolean          </RETURNS>
GSubprocess          *subprocess, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_wait_check</NAME>
<RETURNS>gboolean          </RETURNS>
GSubprocess          *subprocess, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_wait_check_async</NAME>
<RETURNS>void              </RETURNS>
GSubprocess          *subprocess, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_wait_check_finish</NAME>
<RETURNS>gboolean          </RETURNS>
GSubprocess          *subprocess, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_get_status</NAME>
<RETURNS>gint              </RETURNS>
GSubprocess          *subprocess
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_get_successful</NAME>
<RETURNS>gboolean          </RETURNS>
GSubprocess          *subprocess
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_get_if_exited</NAME>
<RETURNS>gboolean          </RETURNS>
GSubprocess          *subprocess
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_get_exit_status</NAME>
<RETURNS>gint              </RETURNS>
GSubprocess          *subprocess
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_get_if_signaled</NAME>
<RETURNS>gboolean          </RETURNS>
GSubprocess          *subprocess
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_get_term_sig</NAME>
<RETURNS>gint              </RETURNS>
GSubprocess          *subprocess
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_communicate</NAME>
<RETURNS>gboolean          </RETURNS>
GSubprocess          *subprocess, GBytes               *stdin_buf, GCancellable         *cancellable, GBytes              **stdout_buf, GBytes              **stderr_buf, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_communicate_async</NAME>
<RETURNS>void             </RETURNS>
GSubprocess          *subprocess, GBytes               *stdin_buf, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_communicate_finish</NAME>
<RETURNS>gboolean         </RETURNS>
GSubprocess          *subprocess, GAsyncResult         *result, GBytes              **stdout_buf, GBytes              **stderr_buf, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_communicate_utf8</NAME>
<RETURNS>gboolean          </RETURNS>
GSubprocess          *subprocess, const char           *stdin_buf, GCancellable         *cancellable, char                **stdout_buf, char                **stderr_buf, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_communicate_utf8_async</NAME>
<RETURNS>void             </RETURNS>
GSubprocess          *subprocess, const char           *stdin_buf, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_communicate_utf8_finish</NAME>
<RETURNS>gboolean         </RETURNS>
GSubprocess          *subprocess, GAsyncResult         *result, char                **stdout_buf, char                **stderr_buf, GError              **error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SUBPROCESS_LAUNCHER</NAME>
#define G_TYPE_SUBPROCESS_LAUNCHER         (g_subprocess_launcher_get_type ())
</MACRO>
<MACRO>
<NAME>G_SUBPROCESS_LAUNCHER</NAME>
#define G_SUBPROCESS_LAUNCHER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SUBPROCESS_LAUNCHER, GSubprocessLauncher))
</MACRO>
<MACRO>
<NAME>G_IS_SUBPROCESS_LAUNCHER</NAME>
#define G_IS_SUBPROCESS_LAUNCHER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SUBPROCESS_LAUNCHER))
</MACRO>
<FUNCTION>
<NAME>g_subprocess_launcher_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_new</NAME>
<RETURNS>GSubprocessLauncher  *   </RETURNS>
GSubprocessFlags       flags
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_spawn</NAME>
<RETURNS>GSubprocess  *           </RETURNS>
GSubprocessLauncher   *self, GError               **error, const gchar           *argv0, ...
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_spawnv</NAME>
<RETURNS>GSubprocess  *           </RETURNS>
GSubprocessLauncher   *self, const gchar * const   *argv, GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_set_environ</NAME>
<RETURNS>void                     </RETURNS>
GSubprocessLauncher   *self, gchar                **env
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_setenv</NAME>
<RETURNS>void                     </RETURNS>
GSubprocessLauncher   *self, const gchar           *variable, const gchar           *value, gboolean               overwrite
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_unsetenv</NAME>
<RETURNS>void                     </RETURNS>
GSubprocessLauncher *self, const gchar         *variable
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_getenv</NAME>
<RETURNS>const gchar  *           </RETURNS>
GSubprocessLauncher   *self, const gchar           *variable
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_set_cwd</NAME>
<RETURNS>void                     </RETURNS>
GSubprocessLauncher   *self, const gchar           *cwd
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_set_flags</NAME>
<RETURNS>void                     </RETURNS>
GSubprocessLauncher   *self, GSubprocessFlags       flags
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_set_stdin_file_path</NAME>
<RETURNS>void                     </RETURNS>
GSubprocessLauncher   *self, const gchar           *path
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_take_stdin_fd</NAME>
<RETURNS>void                     </RETURNS>
GSubprocessLauncher   *self, gint                   fd
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_set_stdout_file_path</NAME>
<RETURNS>void                     </RETURNS>
GSubprocessLauncher   *self, const gchar           *path
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_take_stdout_fd</NAME>
<RETURNS>void                     </RETURNS>
GSubprocessLauncher   *self, gint                   fd
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_set_stderr_file_path</NAME>
<RETURNS>void                     </RETURNS>
GSubprocessLauncher   *self, const gchar           *path
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_take_stderr_fd</NAME>
<RETURNS>void                     </RETURNS>
GSubprocessLauncher   *self, gint                   fd
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_take_fd</NAME>
<RETURNS>void                     </RETURNS>
GSubprocessLauncher   *self, gint                   source_fd, gint                   target_fd
</FUNCTION>
<FUNCTION>
<NAME>g_subprocess_launcher_set_child_setup</NAME>
<RETURNS>void                     </RETURNS>
GSubprocessLauncher   *self, GSpawnChildSetupFunc   child_setup, gpointer               user_data, GDestroyNotify         destroy_notify
</FUNCTION>
<MACRO>
<NAME>G_TYPE_TASK</NAME>
#define G_TYPE_TASK         (g_task_get_type ())
</MACRO>
<MACRO>
<NAME>G_TASK</NAME>
#define G_TASK(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_TASK, GTask))
</MACRO>
<MACRO>
<NAME>G_TASK_CLASS</NAME>
#define G_TASK_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_TASK, GTaskClass))
</MACRO>
<MACRO>
<NAME>G_IS_TASK</NAME>
#define G_IS_TASK(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_TASK))
</MACRO>
<MACRO>
<NAME>G_IS_TASK_CLASS</NAME>
#define G_IS_TASK_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_TASK))
</MACRO>
<MACRO>
<NAME>G_TASK_GET_CLASS</NAME>
#define G_TASK_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_TASK, GTaskClass))
</MACRO>
<FUNCTION>
<NAME>g_task_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_task_new</NAME>
<RETURNS>GTask         *</RETURNS>
gpointer             source_object, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             callback_data
</FUNCTION>
<FUNCTION>
<NAME>g_task_report_error</NAME>
<RETURNS>void           </RETURNS>
gpointer             source_object, GAsyncReadyCallback  callback, gpointer             callback_data, gpointer             source_tag, GError              *error
</FUNCTION>
<FUNCTION>
<NAME>g_task_report_new_error</NAME>
<RETURNS>void           </RETURNS>
gpointer             source_object, GAsyncReadyCallback  callback, gpointer             callback_data, gpointer             source_tag, GQuark               domain, gint                 code, const char          *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_task_set_task_data</NAME>
<RETURNS>void           </RETURNS>
GTask               *task, gpointer             task_data, GDestroyNotify       task_data_destroy
</FUNCTION>
<FUNCTION>
<NAME>g_task_set_priority</NAME>
<RETURNS>void           </RETURNS>
GTask               *task, gint                 priority
</FUNCTION>
<FUNCTION>
<NAME>g_task_set_check_cancellable</NAME>
<RETURNS>void           </RETURNS>
GTask               *task, gboolean             check_cancellable
</FUNCTION>
<FUNCTION>
<NAME>g_task_set_source_tag</NAME>
<RETURNS>void           </RETURNS>
GTask               *task, gpointer             source_tag
</FUNCTION>
<FUNCTION>
<NAME>g_task_get_source_object</NAME>
<RETURNS>gpointer       </RETURNS>
GTask               *task
</FUNCTION>
<FUNCTION>
<NAME>g_task_get_task_data</NAME>
<RETURNS>gpointer       </RETURNS>
GTask               *task
</FUNCTION>
<FUNCTION>
<NAME>g_task_get_priority</NAME>
<RETURNS>gint           </RETURNS>
GTask               *task
</FUNCTION>
<FUNCTION>
<NAME>g_task_get_context</NAME>
<RETURNS>GMainContext  *</RETURNS>
GTask               *task
</FUNCTION>
<FUNCTION>
<NAME>g_task_get_cancellable</NAME>
<RETURNS>GCancellable  *</RETURNS>
GTask               *task
</FUNCTION>
<FUNCTION>
<NAME>g_task_get_check_cancellable</NAME>
<RETURNS>gboolean       </RETURNS>
GTask               *task
</FUNCTION>
<FUNCTION>
<NAME>g_task_get_source_tag</NAME>
<RETURNS>gpointer       </RETURNS>
GTask               *task
</FUNCTION>
<FUNCTION>
<NAME>g_task_is_valid</NAME>
<RETURNS>gboolean       </RETURNS>
gpointer             result, gpointer             source_object
</FUNCTION>
<USER_FUNCTION>
<NAME>GTaskThreadFunc</NAME>
<RETURNS>void </RETURNS>
GTask           *task,
                                           gpointer         source_object,
                                           gpointer         task_data,
                                           GCancellable    *cancellable
</USER_FUNCTION>
<FUNCTION>
<NAME>g_task_run_in_thread</NAME>
<RETURNS>void           </RETURNS>
GTask           *task, GTaskThreadFunc  task_func
</FUNCTION>
<FUNCTION>
<NAME>g_task_run_in_thread_sync</NAME>
<RETURNS>void           </RETURNS>
GTask           *task, GTaskThreadFunc  task_func
</FUNCTION>
<FUNCTION>
<NAME>g_task_set_return_on_cancel</NAME>
<RETURNS>gboolean       </RETURNS>
GTask           *task, gboolean         return_on_cancel
</FUNCTION>
<FUNCTION>
<NAME>g_task_get_return_on_cancel</NAME>
<RETURNS>gboolean       </RETURNS>
GTask           *task
</FUNCTION>
<FUNCTION>
<NAME>g_task_attach_source</NAME>
<RETURNS>void           </RETURNS>
GTask           *task, GSource         *source, GSourceFunc      callback
</FUNCTION>
<FUNCTION>
<NAME>g_task_return_pointer</NAME>
<RETURNS>void           </RETURNS>
GTask           *task, gpointer         result, GDestroyNotify   result_destroy
</FUNCTION>
<FUNCTION>
<NAME>g_task_return_boolean</NAME>
<RETURNS>void           </RETURNS>
GTask           *task, gboolean         result
</FUNCTION>
<FUNCTION>
<NAME>g_task_return_int</NAME>
<RETURNS>void           </RETURNS>
GTask           *task, gssize           result
</FUNCTION>
<FUNCTION>
<NAME>g_task_return_error</NAME>
<RETURNS>void           </RETURNS>
GTask           *task, GError          *error
</FUNCTION>
<FUNCTION>
<NAME>g_task_return_new_error</NAME>
<RETURNS>void           </RETURNS>
GTask           *task, GQuark           domain, gint             code, const char      *format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_task_return_error_if_cancelled</NAME>
<RETURNS>gboolean       </RETURNS>
GTask           *task
</FUNCTION>
<FUNCTION>
<NAME>g_task_propagate_pointer</NAME>
<RETURNS>gpointer       </RETURNS>
GTask           *task, GError         **error
</FUNCTION>
<FUNCTION>
<NAME>g_task_propagate_boolean</NAME>
<RETURNS>gboolean       </RETURNS>
GTask           *task, GError         **error
</FUNCTION>
<FUNCTION>
<NAME>g_task_propagate_int</NAME>
<RETURNS>gssize         </RETURNS>
GTask           *task, GError         **error
</FUNCTION>
<FUNCTION>
<NAME>g_task_had_error</NAME>
<RETURNS>gboolean       </RETURNS>
GTask           *task
</FUNCTION>
<FUNCTION>
<NAME>g_task_get_completed</NAME>
<RETURNS>gboolean       </RETURNS>
GTask           *task
</FUNCTION>
<STRUCT>
<NAME>GTaskClass</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_TCP_CONNECTION</NAME>
#define G_TYPE_TCP_CONNECTION                               (g_tcp_connection_get_type ())
</MACRO>
<MACRO>
<NAME>G_TCP_CONNECTION</NAME>
#define G_TCP_CONNECTION(inst)                              (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_TCP_CONNECTION, GTcpConnection))
</MACRO>
<MACRO>
<NAME>G_TCP_CONNECTION_CLASS</NAME>
#define G_TCP_CONNECTION_CLASS(class)                       (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_TCP_CONNECTION, GTcpConnectionClass))
</MACRO>
<MACRO>
<NAME>G_IS_TCP_CONNECTION</NAME>
#define G_IS_TCP_CONNECTION(inst)                           (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_TCP_CONNECTION))
</MACRO>
<MACRO>
<NAME>G_IS_TCP_CONNECTION_CLASS</NAME>
#define G_IS_TCP_CONNECTION_CLASS(class)                    (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_TCP_CONNECTION))
</MACRO>
<MACRO>
<NAME>G_TCP_CONNECTION_GET_CLASS</NAME>
#define G_TCP_CONNECTION_GET_CLASS(inst)                    (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_TCP_CONNECTION, GTcpConnectionClass))
</MACRO>
<STRUCT>
<NAME>GTcpConnectionClass</NAME>
struct _GTcpConnectionClass
{
  GSocketConnectionClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GTcpConnection</NAME>
struct _GTcpConnection
{
  GSocketConnection parent_instance;
  GTcpConnectionPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>g_tcp_connection_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_tcp_connection_set_graceful_disconnect</NAME>
<RETURNS>void      </RETURNS>
GTcpConnection *connection, gboolean        graceful_disconnect
</FUNCTION>
<FUNCTION>
<NAME>g_tcp_connection_get_graceful_disconnect</NAME>
<RETURNS>gboolean  </RETURNS>
GTcpConnection *connection
</FUNCTION>
<STRUCT>
<NAME>GTcpConnectionPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_TCP_WRAPPER_CONNECTION</NAME>
#define G_TYPE_TCP_WRAPPER_CONNECTION            (g_tcp_wrapper_connection_get_type ())
</MACRO>
<MACRO>
<NAME>G_TCP_WRAPPER_CONNECTION</NAME>
#define G_TCP_WRAPPER_CONNECTION(inst)           (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                  G_TYPE_TCP_WRAPPER_CONNECTION, GTcpWrapperConnection))
</MACRO>
<MACRO>
<NAME>G_TCP_WRAPPER_CONNECTION_CLASS</NAME>
#define G_TCP_WRAPPER_CONNECTION_CLASS(class)    (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                  G_TYPE_TCP_WRAPPER_CONNECTION, GTcpWrapperConnectionClass))
</MACRO>
<MACRO>
<NAME>G_IS_TCP_WRAPPER_CONNECTION</NAME>
#define G_IS_TCP_WRAPPER_CONNECTION(inst)        (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                  G_TYPE_TCP_WRAPPER_CONNECTION))
</MACRO>
<MACRO>
<NAME>G_IS_TCP_WRAPPER_CONNECTION_CLASS</NAME>
#define G_IS_TCP_WRAPPER_CONNECTION_CLASS(class) (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                  G_TYPE_TCP_WRAPPER_CONNECTION))
</MACRO>
<MACRO>
<NAME>G_TCP_WRAPPER_CONNECTION_GET_CLASS</NAME>
#define G_TCP_WRAPPER_CONNECTION_GET_CLASS(inst) (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                  G_TYPE_TCP_WRAPPER_CONNECTION, GTcpWrapperConnectionClass))
</MACRO>
<STRUCT>
<NAME>GTcpWrapperConnectionClass</NAME>
struct _GTcpWrapperConnectionClass
{
  GTcpConnectionClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GTcpWrapperConnection</NAME>
struct _GTcpWrapperConnection
{
  GTcpConnection parent_instance;
  GTcpWrapperConnectionPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>g_tcp_wrapper_connection_get_type</NAME>
<RETURNS>GType               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_tcp_wrapper_connection_new</NAME>
<RETURNS>GSocketConnection  *</RETURNS>
GIOStream             *base_io_stream, GSocket               *socket
</FUNCTION>
<FUNCTION>
<NAME>g_tcp_wrapper_connection_get_base_io_stream</NAME>
<RETURNS>GIOStream          *</RETURNS>
GTcpWrapperConnection *conn
</FUNCTION>
<STRUCT>
<NAME>GTcpWrapperConnectionPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_TEST_DBUS</NAME>
#define G_TYPE_TEST_DBUS \
    (g_test_dbus_get_type ())
</MACRO>
<MACRO>
<NAME>G_TEST_DBUS</NAME>
#define G_TEST_DBUS(obj) \
    (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_TEST_DBUS, \
        GTestDBus))
</MACRO>
<MACRO>
<NAME>G_IS_TEST_DBUS</NAME>
#define G_IS_TEST_DBUS(obj) \
    (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_TEST_DBUS))
</MACRO>
<FUNCTION>
<NAME>g_test_dbus_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_test_dbus_new</NAME>
<RETURNS>GTestDBus  *    </RETURNS>
GTestDBusFlags flags
</FUNCTION>
<FUNCTION>
<NAME>g_test_dbus_get_flags</NAME>
<RETURNS>GTestDBusFlags  </RETURNS>
GTestDBus     *self
</FUNCTION>
<FUNCTION>
<NAME>g_test_dbus_get_bus_address</NAME>
<RETURNS>const gchar  *  </RETURNS>
GTestDBus     *self
</FUNCTION>
<FUNCTION>
<NAME>g_test_dbus_add_service_dir</NAME>
<RETURNS>void            </RETURNS>
GTestDBus     *self, const gchar   *path
</FUNCTION>
<FUNCTION>
<NAME>g_test_dbus_up</NAME>
<RETURNS>void            </RETURNS>
GTestDBus     *self
</FUNCTION>
<FUNCTION>
<NAME>g_test_dbus_stop</NAME>
<RETURNS>void            </RETURNS>
GTestDBus     *self
</FUNCTION>
<FUNCTION>
<NAME>g_test_dbus_down</NAME>
<RETURNS>void            </RETURNS>
GTestDBus     *self
</FUNCTION>
<FUNCTION>
<NAME>g_test_dbus_unset</NAME>
<RETURNS>void            </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_THEMED_ICON</NAME>
#define G_TYPE_THEMED_ICON         (g_themed_icon_get_type ())
</MACRO>
<MACRO>
<NAME>G_THEMED_ICON</NAME>
#define G_THEMED_ICON(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_THEMED_ICON, GThemedIcon))
</MACRO>
<MACRO>
<NAME>G_THEMED_ICON_CLASS</NAME>
#define G_THEMED_ICON_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_THEMED_ICON, GThemedIconClass))
</MACRO>
<MACRO>
<NAME>G_IS_THEMED_ICON</NAME>
#define G_IS_THEMED_ICON(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_THEMED_ICON))
</MACRO>
<MACRO>
<NAME>G_IS_THEMED_ICON_CLASS</NAME>
#define G_IS_THEMED_ICON_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_THEMED_ICON))
</MACRO>
<MACRO>
<NAME>G_THEMED_ICON_GET_CLASS</NAME>
#define G_THEMED_ICON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_THEMED_ICON, GThemedIconClass))
</MACRO>
<FUNCTION>
<NAME>g_themed_icon_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_themed_icon_new</NAME>
<RETURNS>GIcon  *</RETURNS>
const char  *iconname
</FUNCTION>
<FUNCTION>
<NAME>g_themed_icon_new_with_default_fallbacks</NAME>
<RETURNS>GIcon  *</RETURNS>
const char  *iconname
</FUNCTION>
<FUNCTION>
<NAME>g_themed_icon_new_from_names</NAME>
<RETURNS>GIcon  *</RETURNS>
char       **iconnames, int          len
</FUNCTION>
<FUNCTION>
<NAME>g_themed_icon_prepend_name</NAME>
<RETURNS>void    </RETURNS>
GThemedIcon *icon, const char  *iconname
</FUNCTION>
<FUNCTION>
<NAME>g_themed_icon_append_name</NAME>
<RETURNS>void    </RETURNS>
GThemedIcon *icon, const char  *iconname
</FUNCTION>
<FUNCTION>
<NAME>g_themed_icon_get_names</NAME>
<RETURNS>const gchar * const *</RETURNS>
GThemedIcon *icon
</FUNCTION>
<STRUCT>
<NAME>GThemedIconClass</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_THREADED_SOCKET_SERVICE</NAME>
#define G_TYPE_THREADED_SOCKET_SERVICE                      (g_threaded_socket_service_get_type ())
</MACRO>
<MACRO>
<NAME>G_THREADED_SOCKET_SERVICE</NAME>
#define G_THREADED_SOCKET_SERVICE(inst)                     (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_THREADED_SOCKET_SERVICE,                         \
                                                             GThreadedSocketService))
</MACRO>
<MACRO>
<NAME>G_THREADED_SOCKET_SERVICE_CLASS</NAME>
#define G_THREADED_SOCKET_SERVICE_CLASS(class)              (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_THREADED_SOCKET_SERVICE,                         \
                                                             GThreadedSocketServiceClass))
</MACRO>
<MACRO>
<NAME>G_IS_THREADED_SOCKET_SERVICE</NAME>
#define G_IS_THREADED_SOCKET_SERVICE(inst)                  (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_THREADED_SOCKET_SERVICE))
</MACRO>
<MACRO>
<NAME>G_IS_THREADED_SOCKET_SERVICE_CLASS</NAME>
#define G_IS_THREADED_SOCKET_SERVICE_CLASS(class)           (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_THREADED_SOCKET_SERVICE))
</MACRO>
<MACRO>
<NAME>G_THREADED_SOCKET_SERVICE_GET_CLASS</NAME>
#define G_THREADED_SOCKET_SERVICE_GET_CLASS(inst)           (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_THREADED_SOCKET_SERVICE,                         \
                                                             GThreadedSocketServiceClass))
</MACRO>
<STRUCT>
<NAME>GThreadedSocketServiceClass</NAME>
struct _GThreadedSocketServiceClass
{
  GSocketServiceClass parent_class;

  gboolean (* run) (GThreadedSocketService *service,
                    GSocketConnection      *connection,
                    GObject                *source_object);

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<STRUCT>
<NAME>GThreadedSocketService</NAME>
struct _GThreadedSocketService
{
  GSocketService parent_instance;
  GThreadedSocketServicePrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>g_threaded_socket_service_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_threaded_socket_service_new</NAME>
<RETURNS>GSocketService  *        </RETURNS>
int max_threads
</FUNCTION>
<STRUCT>
<NAME>GThreadedSocketServicePrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TLS_BACKEND_EXTENSION_POINT_NAME</NAME>
#define G_TLS_BACKEND_EXTENSION_POINT_NAME "gio-tls-backend"
</MACRO>
<MACRO>
<NAME>G_TYPE_TLS_BACKEND</NAME>
#define G_TYPE_TLS_BACKEND               (g_tls_backend_get_type ())
</MACRO>
<MACRO>
<NAME>G_TLS_BACKEND</NAME>
#define G_TLS_BACKEND(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_TLS_BACKEND, GTlsBackend))
</MACRO>
<MACRO>
<NAME>G_IS_TLS_BACKEND</NAME>
#define G_IS_TLS_BACKEND(obj)	         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_TLS_BACKEND))
</MACRO>
<MACRO>
<NAME>G_TLS_BACKEND_GET_INTERFACE</NAME>
#define G_TLS_BACKEND_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_TLS_BACKEND, GTlsBackendInterface))
</MACRO>
<STRUCT>
<NAME>GTlsBackendInterface</NAME>
struct _GTlsBackendInterface
{
  GTypeInterface g_iface;

  /* methods */
  gboolean       ( *supports_tls)               (GTlsBackend *backend);
  GType          ( *get_certificate_type)       (void);
  GType          ( *get_client_connection_type) (void);
  GType          ( *get_server_connection_type) (void);
  GType          ( *get_file_database_type)     (void);
  GTlsDatabase * ( *get_default_database)       (GTlsBackend *backend);
  gboolean       ( *supports_dtls)              (GTlsBackend *backend);
  GType          ( *get_dtls_client_connection_type) (void);
  GType          ( *get_dtls_server_connection_type) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_tls_backend_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_tls_backend_get_default</NAME>
<RETURNS>GTlsBackend  *  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_tls_backend_get_default_database</NAME>
<RETURNS>GTlsDatabase  * </RETURNS>
GTlsBackend *backend
</FUNCTION>
<FUNCTION>
<NAME>g_tls_backend_supports_tls</NAME>
<RETURNS>gboolean        </RETURNS>
GTlsBackend *backend
</FUNCTION>
<FUNCTION>
<NAME>g_tls_backend_supports_dtls</NAME>
<RETURNS>gboolean        </RETURNS>
GTlsBackend *backend
</FUNCTION>
<FUNCTION>
<NAME>g_tls_backend_get_certificate_type</NAME>
<RETURNS>GType           </RETURNS>
GTlsBackend *backend
</FUNCTION>
<FUNCTION>
<NAME>g_tls_backend_get_client_connection_type</NAME>
<RETURNS>GType           </RETURNS>
GTlsBackend *backend
</FUNCTION>
<FUNCTION>
<NAME>g_tls_backend_get_server_connection_type</NAME>
<RETURNS>GType           </RETURNS>
GTlsBackend *backend
</FUNCTION>
<FUNCTION>
<NAME>g_tls_backend_get_file_database_type</NAME>
<RETURNS>GType           </RETURNS>
GTlsBackend *backend
</FUNCTION>
<FUNCTION>
<NAME>g_tls_backend_get_dtls_client_connection_type</NAME>
<RETURNS>GType           </RETURNS>
GTlsBackend *backend
</FUNCTION>
<FUNCTION>
<NAME>g_tls_backend_get_dtls_server_connection_type</NAME>
<RETURNS>GType           </RETURNS>
GTlsBackend *backend
</FUNCTION>
<STRUCT>
<NAME>GTlsBackend</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_TLS_CERTIFICATE</NAME>
#define G_TYPE_TLS_CERTIFICATE            (g_tls_certificate_get_type ())
</MACRO>
<MACRO>
<NAME>G_TLS_CERTIFICATE</NAME>
#define G_TLS_CERTIFICATE(inst)           (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_CERTIFICATE, GTlsCertificate))
</MACRO>
<MACRO>
<NAME>G_TLS_CERTIFICATE_CLASS</NAME>
#define G_TLS_CERTIFICATE_CLASS(class)    (G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_TLS_CERTIFICATE, GTlsCertificateClass))
</MACRO>
<MACRO>
<NAME>G_IS_TLS_CERTIFICATE</NAME>
#define G_IS_TLS_CERTIFICATE(inst)        (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_CERTIFICATE))
</MACRO>
<MACRO>
<NAME>G_IS_TLS_CERTIFICATE_CLASS</NAME>
#define G_IS_TLS_CERTIFICATE_CLASS(class) (G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_TLS_CERTIFICATE))
</MACRO>
<MACRO>
<NAME>G_TLS_CERTIFICATE_GET_CLASS</NAME>
#define G_TLS_CERTIFICATE_GET_CLASS(inst) (G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_TLS_CERTIFICATE, GTlsCertificateClass))
</MACRO>
<STRUCT>
<NAME>GTlsCertificate</NAME>
struct _GTlsCertificate {
  GObject parent_instance;

  GTlsCertificatePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GTlsCertificateClass</NAME>
struct _GTlsCertificateClass
{
  GObjectClass parent_class;

  GTlsCertificateFlags  (* verify) (GTlsCertificate     *cert,
				    GSocketConnectable  *identity,
				    GTlsCertificate     *trusted_ca);

  /*< private >*/
  /* Padding for future expansion */
  gpointer padding[8];
};
</STRUCT>
<FUNCTION>
<NAME>g_tls_certificate_get_type</NAME>
<RETURNS>GType                  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_tls_certificate_new_from_pem</NAME>
<RETURNS>GTlsCertificate       *</RETURNS>
const gchar         *data, gssize               length, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_certificate_new_from_file</NAME>
<RETURNS>GTlsCertificate       *</RETURNS>
const gchar         *file, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_certificate_new_from_files</NAME>
<RETURNS>GTlsCertificate       *</RETURNS>
const gchar         *cert_file, const gchar         *key_file, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_certificate_list_new_from_file</NAME>
<RETURNS>GList                 *</RETURNS>
const gchar         *file, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_certificate_get_issuer</NAME>
<RETURNS>GTlsCertificate       *</RETURNS>
GTlsCertificate     *cert
</FUNCTION>
<FUNCTION>
<NAME>g_tls_certificate_verify</NAME>
<RETURNS>GTlsCertificateFlags   </RETURNS>
GTlsCertificate     *cert, GSocketConnectable  *identity, GTlsCertificate     *trusted_ca
</FUNCTION>
<FUNCTION>
<NAME>g_tls_certificate_is_same</NAME>
<RETURNS>gboolean               </RETURNS>
GTlsCertificate     *cert_one, GTlsCertificate     *cert_two
</FUNCTION>
<STRUCT>
<NAME>GTlsCertificatePrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_TLS_CLIENT_CONNECTION</NAME>
#define G_TYPE_TLS_CLIENT_CONNECTION                (g_tls_client_connection_get_type ())
</MACRO>
<MACRO>
<NAME>G_TLS_CLIENT_CONNECTION</NAME>
#define G_TLS_CLIENT_CONNECTION(inst)               (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_CLIENT_CONNECTION, GTlsClientConnection))
</MACRO>
<MACRO>
<NAME>G_IS_TLS_CLIENT_CONNECTION</NAME>
#define G_IS_TLS_CLIENT_CONNECTION(inst)            (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_CLIENT_CONNECTION))
</MACRO>
<MACRO>
<NAME>G_TLS_CLIENT_CONNECTION_GET_INTERFACE</NAME>
#define G_TLS_CLIENT_CONNECTION_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_TLS_CLIENT_CONNECTION, GTlsClientConnectionInterface))
</MACRO>
<STRUCT>
<NAME>GTlsClientConnectionInterface</NAME>
struct _GTlsClientConnectionInterface
{
  GTypeInterface g_iface;

  void     ( *copy_session_state )     (GTlsClientConnection       *conn,
                                        GTlsClientConnection       *source);
};
</STRUCT>
<FUNCTION>
<NAME>g_tls_client_connection_get_type</NAME>
<RETURNS>GType                  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_tls_client_connection_new</NAME>
<RETURNS>GIOStream  *           </RETURNS>
GIOStream               *base_io_stream, GSocketConnectable      *server_identity, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_client_connection_get_validation_flags</NAME>
<RETURNS>GTlsCertificateFlags   </RETURNS>
GTlsClientConnection    *conn
</FUNCTION>
<FUNCTION>
<NAME>g_tls_client_connection_set_validation_flags</NAME>
<RETURNS>void                   </RETURNS>
GTlsClientConnection    *conn, GTlsCertificateFlags     flags
</FUNCTION>
<FUNCTION>
<NAME>g_tls_client_connection_get_server_identity</NAME>
<RETURNS>GSocketConnectable    *</RETURNS>
GTlsClientConnection    *conn
</FUNCTION>
<FUNCTION>
<NAME>g_tls_client_connection_set_server_identity</NAME>
<RETURNS>void                   </RETURNS>
GTlsClientConnection    *conn, GSocketConnectable      *identity
</FUNCTION>
<FUNCTION>
<NAME>g_tls_client_connection_get_use_ssl3</NAME>
<DEPRECATED/>
<RETURNS>gboolean               </RETURNS>
GTlsClientConnection    *conn
</FUNCTION>
<FUNCTION>
<NAME>g_tls_client_connection_set_use_ssl3</NAME>
<DEPRECATED/>
<RETURNS>void                   </RETURNS>
GTlsClientConnection    *conn, gboolean                 use_ssl3
</FUNCTION>
<FUNCTION>
<NAME>g_tls_client_connection_get_accepted_cas</NAME>
<RETURNS>GList  *               </RETURNS>
GTlsClientConnection    *conn
</FUNCTION>
<FUNCTION>
<NAME>g_tls_client_connection_copy_session_state</NAME>
<RETURNS>void                   </RETURNS>
GTlsClientConnection    *conn, GTlsClientConnection    *source
</FUNCTION>
<MACRO>
<NAME>G_TYPE_TLS_CONNECTION</NAME>
#define G_TYPE_TLS_CONNECTION            (g_tls_connection_get_type ())
</MACRO>
<MACRO>
<NAME>G_TLS_CONNECTION</NAME>
#define G_TLS_CONNECTION(inst)           (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_CONNECTION, GTlsConnection))
</MACRO>
<MACRO>
<NAME>G_TLS_CONNECTION_CLASS</NAME>
#define G_TLS_CONNECTION_CLASS(class)    (G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_TLS_CONNECTION, GTlsConnectionClass))
</MACRO>
<MACRO>
<NAME>G_IS_TLS_CONNECTION</NAME>
#define G_IS_TLS_CONNECTION(inst)        (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_CONNECTION))
</MACRO>
<MACRO>
<NAME>G_IS_TLS_CONNECTION_CLASS</NAME>
#define G_IS_TLS_CONNECTION_CLASS(class) (G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_TLS_CONNECTION))
</MACRO>
<MACRO>
<NAME>G_TLS_CONNECTION_GET_CLASS</NAME>
#define G_TLS_CONNECTION_GET_CLASS(inst) (G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_TLS_CONNECTION, GTlsConnectionClass))
</MACRO>
<STRUCT>
<NAME>GTlsConnection</NAME>
struct _GTlsConnection {
  GIOStream parent_instance;

  GTlsConnectionPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GTlsConnectionClass</NAME>
struct _GTlsConnectionClass
{
  GIOStreamClass parent_class;

  /* signals */
  gboolean          ( *accept_certificate) (GTlsConnection       *connection,
					    GTlsCertificate      *peer_cert,
					    GTlsCertificateFlags  errors);

  /* methods */
  gboolean ( *handshake )        (GTlsConnection       *conn,
				  GCancellable         *cancellable,
				  GError              **error);

  void     ( *handshake_async )  (GTlsConnection       *conn,
				  int                   io_priority,
				  GCancellable         *cancellable,
				  GAsyncReadyCallback   callback,
				  gpointer              user_data);
  gboolean ( *handshake_finish ) (GTlsConnection       *conn,
				  GAsyncResult         *result,
				  GError              **error);

  /*< private >*/
  /* Padding for future expansion */
  gpointer padding[8];
};
</STRUCT>
<FUNCTION>
<NAME>g_tls_connection_get_type</NAME>
<RETURNS>GType                  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_set_use_system_certdb</NAME>
<DEPRECATED/>
<RETURNS>void                   </RETURNS>
GTlsConnection       *conn, gboolean              use_system_certdb
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_get_use_system_certdb</NAME>
<DEPRECATED/>
<RETURNS>gboolean               </RETURNS>
GTlsConnection       *conn
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_set_database</NAME>
<RETURNS>void                   </RETURNS>
GTlsConnection       *conn, GTlsDatabase         *database
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_get_database</NAME>
<RETURNS>GTlsDatabase  *        </RETURNS>
GTlsConnection       *conn
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_set_certificate</NAME>
<RETURNS>void                   </RETURNS>
GTlsConnection       *conn, GTlsCertificate      *certificate
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_get_certificate</NAME>
<RETURNS>GTlsCertificate       *</RETURNS>
GTlsConnection       *conn
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_set_interaction</NAME>
<RETURNS>void                   </RETURNS>
GTlsConnection       *conn, GTlsInteraction      *interaction
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_get_interaction</NAME>
<RETURNS>GTlsInteraction  *     </RETURNS>
GTlsConnection       *conn
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_get_peer_certificate</NAME>
<RETURNS>GTlsCertificate       *</RETURNS>
GTlsConnection       *conn
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_get_peer_certificate_errors</NAME>
<RETURNS>GTlsCertificateFlags   </RETURNS>
GTlsConnection       *conn
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_set_require_close_notify</NAME>
<RETURNS>void                   </RETURNS>
GTlsConnection       *conn, gboolean              require_close_notify
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_get_require_close_notify</NAME>
<RETURNS>gboolean               </RETURNS>
GTlsConnection       *conn
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_set_rehandshake_mode</NAME>
<RETURNS>void                   </RETURNS>
GTlsConnection       *conn, GTlsRehandshakeMode   mode
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_get_rehandshake_mode</NAME>
<RETURNS>GTlsRehandshakeMode    </RETURNS>
GTlsConnection       *conn
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_handshake</NAME>
<RETURNS>gboolean               </RETURNS>
GTlsConnection       *conn, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_handshake_async</NAME>
<RETURNS>void                   </RETURNS>
GTlsConnection       *conn, int                   io_priority, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_handshake_finish</NAME>
<RETURNS>gboolean               </RETURNS>
GTlsConnection       *conn, GAsyncResult         *result, GError              **error
</FUNCTION>
<MACRO>
<NAME>G_TLS_ERROR</NAME>
#define G_TLS_ERROR (g_tls_error_quark ())
</MACRO>
<FUNCTION>
<NAME>g_tls_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_tls_connection_emit_accept_certificate</NAME>
<RETURNS>gboolean               </RETURNS>
GTlsConnection       *conn, GTlsCertificate      *peer_cert, GTlsCertificateFlags  errors
</FUNCTION>
<STRUCT>
<NAME>GTlsConnectionPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER</NAME>
#define G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER "1.3.6.1.5.5.7.3.1"
</MACRO>
<MACRO>
<NAME>G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT</NAME>
#define G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT "1.3.6.1.5.5.7.3.2"
</MACRO>
<MACRO>
<NAME>G_TYPE_TLS_DATABASE</NAME>
#define G_TYPE_TLS_DATABASE            (g_tls_database_get_type ())
</MACRO>
<MACRO>
<NAME>G_TLS_DATABASE</NAME>
#define G_TLS_DATABASE(inst)           (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_DATABASE, GTlsDatabase))
</MACRO>
<MACRO>
<NAME>G_TLS_DATABASE_CLASS</NAME>
#define G_TLS_DATABASE_CLASS(class)    (G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_TLS_DATABASE, GTlsDatabaseClass))
</MACRO>
<MACRO>
<NAME>G_IS_TLS_DATABASE</NAME>
#define G_IS_TLS_DATABASE(inst)        (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_DATABASE))
</MACRO>
<MACRO>
<NAME>G_IS_TLS_DATABASE_CLASS</NAME>
#define G_IS_TLS_DATABASE_CLASS(class) (G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_TLS_DATABASE))
</MACRO>
<MACRO>
<NAME>G_TLS_DATABASE_GET_CLASS</NAME>
#define G_TLS_DATABASE_GET_CLASS(inst) (G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_TLS_DATABASE, GTlsDatabaseClass))
</MACRO>
<STRUCT>
<NAME>GTlsDatabase</NAME>
struct _GTlsDatabase
{
  GObject parent_instance;

  GTlsDatabasePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GTlsDatabaseClass</NAME>
struct _GTlsDatabaseClass
{
  GObjectClass parent_class;

  /* virtual methods */

  GTlsCertificateFlags  (*verify_chain)                         (GTlsDatabase            *self,
                                                                 GTlsCertificate         *chain,
                                                                 const gchar             *purpose,
                                                                 GSocketConnectable      *identity,
                                                                 GTlsInteraction         *interaction,
                                                                 GTlsDatabaseVerifyFlags  flags,
                                                                 GCancellable            *cancellable,
                                                                 GError                 **error);

  void                  (*verify_chain_async)                   (GTlsDatabase            *self,
                                                                 GTlsCertificate         *chain,
                                                                 const gchar             *purpose,
                                                                 GSocketConnectable      *identity,
                                                                 GTlsInteraction         *interaction,
                                                                 GTlsDatabaseVerifyFlags  flags,
                                                                 GCancellable            *cancellable,
                                                                 GAsyncReadyCallback      callback,
                                                                 gpointer                 user_data);

  GTlsCertificateFlags  (*verify_chain_finish)                  (GTlsDatabase            *self,
                                                                 GAsyncResult            *result,
                                                                 GError                 **error);

  gchar*                (*create_certificate_handle)            (GTlsDatabase            *self,
                                                                 GTlsCertificate         *certificate);

  GTlsCertificate*      (*lookup_certificate_for_handle)        (GTlsDatabase            *self,
                                                                 const gchar             *handle,
                                                                 GTlsInteraction         *interaction,
                                                                 GTlsDatabaseLookupFlags  flags,
                                                                 GCancellable            *cancellable,
                                                                 GError                 **error);

  void                  (*lookup_certificate_for_handle_async)  (GTlsDatabase            *self,
                                                                 const gchar             *handle,
                                                                 GTlsInteraction         *interaction,
                                                                 GTlsDatabaseLookupFlags  flags,
                                                                 GCancellable            *cancellable,
                                                                 GAsyncReadyCallback      callback,
                                                                 gpointer                 user_data);

  GTlsCertificate*      (*lookup_certificate_for_handle_finish) (GTlsDatabase            *self,
                                                                 GAsyncResult            *result,
                                                                 GError                 **error);

  GTlsCertificate*      (*lookup_certificate_issuer)            (GTlsDatabase            *self,
                                                                 GTlsCertificate         *certificate,
                                                                 GTlsInteraction         *interaction,
                                                                 GTlsDatabaseLookupFlags  flags,
                                                                 GCancellable            *cancellable,
                                                                 GError                 **error);

  void                  (*lookup_certificate_issuer_async)      (GTlsDatabase            *self,
                                                                 GTlsCertificate         *certificate,
                                                                 GTlsInteraction         *interaction,
                                                                 GTlsDatabaseLookupFlags  flags,
                                                                 GCancellable            *cancellable,
                                                                 GAsyncReadyCallback      callback,
                                                                 gpointer                 user_data);

  GTlsCertificate*      (*lookup_certificate_issuer_finish)     (GTlsDatabase            *self,
                                                                 GAsyncResult            *result,
                                                                 GError                 **error);

  GList*                (*lookup_certificates_issued_by)        (GTlsDatabase            *self,
                                                                 GByteArray              *issuer_raw_dn,
                                                                 GTlsInteraction         *interaction,
                                                                 GTlsDatabaseLookupFlags  flags,
                                                                 GCancellable            *cancellable,
                                                                 GError                 **error);

  void                  (*lookup_certificates_issued_by_async)  (GTlsDatabase            *self,
                                                                 GByteArray              *issuer_raw_dn,
                                                                 GTlsInteraction         *interaction,
                                                                 GTlsDatabaseLookupFlags  flags,
                                                                 GCancellable            *cancellable,
                                                                 GAsyncReadyCallback      callback,
                                                                 gpointer                 user_data);

  GList*                (*lookup_certificates_issued_by_finish) (GTlsDatabase            *self,
                                                                 GAsyncResult            *result,
                                                                 GError                 **error);

  /*< private >*/
  /* Padding for future expansion */
  gpointer padding[16];
};
</STRUCT>
<FUNCTION>
<NAME>g_tls_database_get_type</NAME>
<RETURNS>GType                 </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_tls_database_verify_chain</NAME>
<RETURNS>GTlsCertificateFlags  </RETURNS>
GTlsDatabase            *self, GTlsCertificate         *chain, const gchar             *purpose, GSocketConnectable      *identity, GTlsInteraction         *interaction, GTlsDatabaseVerifyFlags  flags, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_database_verify_chain_async</NAME>
<RETURNS>void                  </RETURNS>
GTlsDatabase            *self, GTlsCertificate         *chain, const gchar             *purpose, GSocketConnectable      *identity, GTlsInteraction         *interaction, GTlsDatabaseVerifyFlags  flags, GCancellable            *cancellable, GAsyncReadyCallback      callback, gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>g_tls_database_verify_chain_finish</NAME>
<RETURNS>GTlsCertificateFlags  </RETURNS>
GTlsDatabase            *self, GAsyncResult            *result, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_database_create_certificate_handle</NAME>
<RETURNS>gchar *               </RETURNS>
GTlsDatabase            *self, GTlsCertificate         *certificate
</FUNCTION>
<FUNCTION>
<NAME>g_tls_database_lookup_certificate_for_handle</NAME>
<RETURNS>GTlsCertificate *     </RETURNS>
GTlsDatabase            *self, const gchar             *handle, GTlsInteraction         *interaction, GTlsDatabaseLookupFlags  flags, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_database_lookup_certificate_for_handle_async</NAME>
<RETURNS>void                  </RETURNS>
GTlsDatabase            *self, const gchar             *handle, GTlsInteraction         *interaction, GTlsDatabaseLookupFlags  flags, GCancellable            *cancellable, GAsyncReadyCallback      callback, gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>g_tls_database_lookup_certificate_for_handle_finish</NAME>
<RETURNS>GTlsCertificate *     </RETURNS>
GTlsDatabase            *self, GAsyncResult            *result, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_database_lookup_certificate_issuer</NAME>
<RETURNS>GTlsCertificate *     </RETURNS>
GTlsDatabase            *self, GTlsCertificate         *certificate, GTlsInteraction         *interaction, GTlsDatabaseLookupFlags  flags, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_database_lookup_certificate_issuer_async</NAME>
<RETURNS>void                  </RETURNS>
GTlsDatabase            *self, GTlsCertificate         *certificate, GTlsInteraction         *interaction, GTlsDatabaseLookupFlags  flags, GCancellable            *cancellable, GAsyncReadyCallback      callback, gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>g_tls_database_lookup_certificate_issuer_finish</NAME>
<RETURNS>GTlsCertificate *     </RETURNS>
GTlsDatabase            *self, GAsyncResult            *result, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_database_lookup_certificates_issued_by</NAME>
<RETURNS>GList *               </RETURNS>
GTlsDatabase            *self, GByteArray              *issuer_raw_dn, GTlsInteraction         *interaction, GTlsDatabaseLookupFlags  flags, GCancellable            *cancellable, GError                 **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_database_lookup_certificates_issued_by_async</NAME>
<RETURNS>void                  </RETURNS>
GTlsDatabase            *self, GByteArray              *issuer_raw_dn, GTlsInteraction         *interaction, GTlsDatabaseLookupFlags  flags, GCancellable            *cancellable, GAsyncReadyCallback      callback, gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>g_tls_database_lookup_certificates_issued_by_finish</NAME>
<RETURNS>GList *               </RETURNS>
GTlsDatabase            *self, GAsyncResult            *result, GError                 **error
</FUNCTION>
<STRUCT>
<NAME>GTlsDatabasePrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_TLS_FILE_DATABASE</NAME>
#define G_TYPE_TLS_FILE_DATABASE                (g_tls_file_database_get_type ())
</MACRO>
<MACRO>
<NAME>G_TLS_FILE_DATABASE</NAME>
#define G_TLS_FILE_DATABASE(inst)               (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_FILE_DATABASE, GTlsFileDatabase))
</MACRO>
<MACRO>
<NAME>G_IS_TLS_FILE_DATABASE</NAME>
#define G_IS_TLS_FILE_DATABASE(inst)            (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_FILE_DATABASE))
</MACRO>
<MACRO>
<NAME>G_TLS_FILE_DATABASE_GET_INTERFACE</NAME>
#define G_TLS_FILE_DATABASE_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_TLS_FILE_DATABASE, GTlsFileDatabaseInterface))
</MACRO>
<STRUCT>
<NAME>GTlsFileDatabaseInterface</NAME>
struct _GTlsFileDatabaseInterface
{
  GTypeInterface g_iface;

  /*< private >*/
  /* Padding for future expansion */
  gpointer padding[8];
};
</STRUCT>
<FUNCTION>
<NAME>g_tls_file_database_get_type</NAME>
<RETURNS>GType                         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_tls_file_database_new</NAME>
<RETURNS>GTlsDatabase *                </RETURNS>
const gchar  *anchors, GError      **error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_TLS_INTERACTION</NAME>
#define G_TYPE_TLS_INTERACTION         (g_tls_interaction_get_type ())
</MACRO>
<MACRO>
<NAME>G_TLS_INTERACTION</NAME>
#define G_TLS_INTERACTION(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_TLS_INTERACTION, GTlsInteraction))
</MACRO>
<MACRO>
<NAME>G_TLS_INTERACTION_CLASS</NAME>
#define G_TLS_INTERACTION_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_TLS_INTERACTION, GTlsInteractionClass))
</MACRO>
<MACRO>
<NAME>G_IS_TLS_INTERACTION</NAME>
#define G_IS_TLS_INTERACTION(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_TLS_INTERACTION))
</MACRO>
<MACRO>
<NAME>G_IS_TLS_INTERACTION_CLASS</NAME>
#define G_IS_TLS_INTERACTION_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_TLS_INTERACTION))
</MACRO>
<MACRO>
<NAME>G_TLS_INTERACTION_GET_CLASS</NAME>
#define G_TLS_INTERACTION_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_TLS_INTERACTION, GTlsInteractionClass))
</MACRO>
<STRUCT>
<NAME>GTlsInteraction</NAME>
struct _GTlsInteraction
{
  /*< private >*/
  GObject parent_instance;
  GTlsInteractionPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GTlsInteractionClass</NAME>
struct _GTlsInteractionClass
{
  /*< private >*/
  GObjectClass parent_class;

  /*< public >*/
  GTlsInteractionResult  (* ask_password)        (GTlsInteraction    *interaction,
                                                  GTlsPassword       *password,
                                                  GCancellable       *cancellable,
                                                  GError            **error);

  void                   (* ask_password_async)  (GTlsInteraction    *interaction,
                                                  GTlsPassword       *password,
                                                  GCancellable       *cancellable,
                                                  GAsyncReadyCallback callback,
                                                  gpointer            user_data);

  GTlsInteractionResult  (* ask_password_finish) (GTlsInteraction    *interaction,
                                                  GAsyncResult       *result,
                                                  GError            **error);

  GTlsInteractionResult  (* request_certificate)        (GTlsInteraction              *interaction,
                                                         GTlsConnection               *connection,
                                                         GTlsCertificateRequestFlags   flags,
                                                         GCancellable                 *cancellable,
                                                         GError                      **error);

  void                   (* request_certificate_async)  (GTlsInteraction              *interaction,
                                                         GTlsConnection               *connection,
                                                         GTlsCertificateRequestFlags   flags,
                                                         GCancellable                 *cancellable,
                                                         GAsyncReadyCallback           callback,
                                                         gpointer                      user_data);

  GTlsInteractionResult  (* request_certificate_finish) (GTlsInteraction              *interaction,
                                                         GAsyncResult                 *result,
                                                         GError                      **error);

  /*< private >*/
  /* Padding for future expansion */
  gpointer padding[21];
};
</STRUCT>
<FUNCTION>
<NAME>g_tls_interaction_get_type</NAME>
<RETURNS>GType                   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_tls_interaction_invoke_ask_password</NAME>
<RETURNS>GTlsInteractionResult   </RETURNS>
GTlsInteraction    *interaction, GTlsPassword       *password, GCancellable       *cancellable, GError            **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_interaction_ask_password</NAME>
<RETURNS>GTlsInteractionResult   </RETURNS>
GTlsInteraction    *interaction, GTlsPassword       *password, GCancellable       *cancellable, GError            **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_interaction_ask_password_async</NAME>
<RETURNS>void                    </RETURNS>
GTlsInteraction    *interaction, GTlsPassword       *password, GCancellable       *cancellable, GAsyncReadyCallback callback, gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>g_tls_interaction_ask_password_finish</NAME>
<RETURNS>GTlsInteractionResult   </RETURNS>
GTlsInteraction    *interaction, GAsyncResult       *result, GError            **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_interaction_invoke_request_certificate</NAME>
<RETURNS>GTlsInteractionResult   </RETURNS>
GTlsInteraction              *interaction, GTlsConnection               *connection, GTlsCertificateRequestFlags   flags, GCancellable                 *cancellable, GError                      **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_interaction_request_certificate</NAME>
<RETURNS>GTlsInteractionResult   </RETURNS>
GTlsInteraction              *interaction, GTlsConnection               *connection, GTlsCertificateRequestFlags   flags, GCancellable                 *cancellable, GError                      **error
</FUNCTION>
<FUNCTION>
<NAME>g_tls_interaction_request_certificate_async</NAME>
<RETURNS>void                    </RETURNS>
GTlsInteraction              *interaction, GTlsConnection               *connection, GTlsCertificateRequestFlags   flags, GCancellable                 *cancellable, GAsyncReadyCallback           callback, gpointer                      user_data
</FUNCTION>
<FUNCTION>
<NAME>g_tls_interaction_request_certificate_finish</NAME>
<RETURNS>GTlsInteractionResult   </RETURNS>
GTlsInteraction              *interaction, GAsyncResult                 *result, GError                      **error
</FUNCTION>
<STRUCT>
<NAME>GTlsInteractionPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_TLS_PASSWORD</NAME>
#define G_TYPE_TLS_PASSWORD         (g_tls_password_get_type ())
</MACRO>
<MACRO>
<NAME>G_TLS_PASSWORD</NAME>
#define G_TLS_PASSWORD(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_TLS_PASSWORD, GTlsPassword))
</MACRO>
<MACRO>
<NAME>G_TLS_PASSWORD_CLASS</NAME>
#define G_TLS_PASSWORD_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_TLS_PASSWORD, GTlsPasswordClass))
</MACRO>
<MACRO>
<NAME>G_IS_TLS_PASSWORD</NAME>
#define G_IS_TLS_PASSWORD(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_TLS_PASSWORD))
</MACRO>
<MACRO>
<NAME>G_IS_TLS_PASSWORD_CLASS</NAME>
#define G_IS_TLS_PASSWORD_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_TLS_PASSWORD))
</MACRO>
<MACRO>
<NAME>G_TLS_PASSWORD_GET_CLASS</NAME>
#define G_TLS_PASSWORD_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_TLS_PASSWORD, GTlsPasswordClass))
</MACRO>
<STRUCT>
<NAME>GTlsPassword</NAME>
struct _GTlsPassword
{
  GObject parent_instance;

  GTlsPasswordPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GTlsPasswordClass</NAME>
struct _GTlsPasswordClass
{
  GObjectClass parent_class;

  /* methods */

  const guchar *    ( *get_value)            (GTlsPassword  *password,
                                              gsize         *length);

  void              ( *set_value)            (GTlsPassword  *password,
                                              guchar        *value,
                                              gssize         length,
                                              GDestroyNotify destroy);

  const gchar*      ( *get_default_warning)  (GTlsPassword  *password);

  /*< private >*/
  /* Padding for future expansion */
  gpointer padding[4];
};
</STRUCT>
<FUNCTION>
<NAME>g_tls_password_get_type</NAME>
<RETURNS>GType              </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_tls_password_new</NAME>
<RETURNS>GTlsPassword  *    </RETURNS>
GTlsPasswordFlags  flags, const gchar       *description
</FUNCTION>
<FUNCTION>
<NAME>g_tls_password_get_value</NAME>
<RETURNS>const guchar  *    </RETURNS>
GTlsPassword      *password, gsize             *length
</FUNCTION>
<FUNCTION>
<NAME>g_tls_password_set_value</NAME>
<RETURNS>void               </RETURNS>
GTlsPassword      *password, const guchar      *value, gssize             length
</FUNCTION>
<FUNCTION>
<NAME>g_tls_password_set_value_full</NAME>
<RETURNS>void               </RETURNS>
GTlsPassword      *password, guchar            *value, gssize             length, GDestroyNotify     destroy
</FUNCTION>
<FUNCTION>
<NAME>g_tls_password_get_flags</NAME>
<RETURNS>GTlsPasswordFlags  </RETURNS>
GTlsPassword      *password
</FUNCTION>
<FUNCTION>
<NAME>g_tls_password_set_flags</NAME>
<RETURNS>void               </RETURNS>
GTlsPassword      *password, GTlsPasswordFlags  flags
</FUNCTION>
<FUNCTION>
<NAME>g_tls_password_get_description</NAME>
<RETURNS>const gchar *      </RETURNS>
GTlsPassword      *password
</FUNCTION>
<FUNCTION>
<NAME>g_tls_password_set_description</NAME>
<RETURNS>void               </RETURNS>
GTlsPassword      *password, const gchar       *description
</FUNCTION>
<FUNCTION>
<NAME>g_tls_password_get_warning</NAME>
<RETURNS>const gchar  *     </RETURNS>
GTlsPassword      *password
</FUNCTION>
<FUNCTION>
<NAME>g_tls_password_set_warning</NAME>
<RETURNS>void               </RETURNS>
GTlsPassword      *password, const gchar       *warning
</FUNCTION>
<STRUCT>
<NAME>GTlsPasswordPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_TLS_SERVER_CONNECTION</NAME>
#define G_TYPE_TLS_SERVER_CONNECTION                (g_tls_server_connection_get_type ())
</MACRO>
<MACRO>
<NAME>G_TLS_SERVER_CONNECTION</NAME>
#define G_TLS_SERVER_CONNECTION(inst)               (G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_SERVER_CONNECTION, GTlsServerConnection))
</MACRO>
<MACRO>
<NAME>G_IS_TLS_SERVER_CONNECTION</NAME>
#define G_IS_TLS_SERVER_CONNECTION(inst)            (G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_SERVER_CONNECTION))
</MACRO>
<MACRO>
<NAME>G_TLS_SERVER_CONNECTION_GET_INTERFACE</NAME>
#define G_TLS_SERVER_CONNECTION_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_TLS_SERVER_CONNECTION, GTlsServerConnectionInterface))
</MACRO>
<STRUCT>
<NAME>GTlsServerConnectionInterface</NAME>
struct _GTlsServerConnectionInterface
{
  GTypeInterface g_iface;

};
</STRUCT>
<FUNCTION>
<NAME>g_tls_server_connection_get_type</NAME>
<RETURNS>GType                  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_tls_server_connection_new</NAME>
<RETURNS>GIOStream  *           </RETURNS>
GIOStream        *base_io_stream, GTlsCertificate  *certificate, GError          **error
</FUNCTION>
<MACRO>
<NAME>G_TYPE_UNIX_CONNECTION</NAME>
#define G_TYPE_UNIX_CONNECTION                              (g_unix_connection_get_type ())
</MACRO>
<MACRO>
<NAME>G_UNIX_CONNECTION</NAME>
#define G_UNIX_CONNECTION(inst)                             (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_UNIX_CONNECTION, GUnixConnection))
</MACRO>
<MACRO>
<NAME>G_UNIX_CONNECTION_CLASS</NAME>
#define G_UNIX_CONNECTION_CLASS(class)                      (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_UNIX_CONNECTION, GUnixConnectionClass))
</MACRO>
<MACRO>
<NAME>G_IS_UNIX_CONNECTION</NAME>
#define G_IS_UNIX_CONNECTION(inst)                          (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_UNIX_CONNECTION))
</MACRO>
<MACRO>
<NAME>G_IS_UNIX_CONNECTION_CLASS</NAME>
#define G_IS_UNIX_CONNECTION_CLASS(class)                   (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_UNIX_CONNECTION))
</MACRO>
<MACRO>
<NAME>G_UNIX_CONNECTION_GET_CLASS</NAME>
#define G_UNIX_CONNECTION_GET_CLASS(inst)                   (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_UNIX_CONNECTION, GUnixConnectionClass))
</MACRO>
<STRUCT>
<NAME>GUnixConnectionClass</NAME>
struct _GUnixConnectionClass
{
  GSocketConnectionClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GUnixConnection</NAME>
struct _GUnixConnection
{
  GSocketConnection parent_instance;
  GUnixConnectionPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>g_unix_connection_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_unix_connection_send_fd</NAME>
<RETURNS>gboolean                 </RETURNS>
GUnixConnection      *connection, gint                  fd, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_unix_connection_receive_fd</NAME>
<RETURNS>gint                     </RETURNS>
GUnixConnection      *connection, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_unix_connection_send_credentials</NAME>
<RETURNS>gboolean                 </RETURNS>
GUnixConnection      *connection, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_unix_connection_send_credentials_async</NAME>
<RETURNS>void                     </RETURNS>
GUnixConnection      *connection, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_unix_connection_send_credentials_finish</NAME>
<RETURNS>gboolean                 </RETURNS>
GUnixConnection      *connection, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_unix_connection_receive_credentials</NAME>
<RETURNS>GCredentials            *</RETURNS>
GUnixConnection      *connection, GCancellable         *cancellable, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_unix_connection_receive_credentials_async</NAME>
<RETURNS>void                     </RETURNS>
GUnixConnection      *connection, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_unix_connection_receive_credentials_finish</NAME>
<RETURNS>GCredentials            *</RETURNS>
GUnixConnection      *connection, GAsyncResult         *result, GError              **error
</FUNCTION>
<STRUCT>
<NAME>GUnixConnectionPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_UNIX_CREDENTIALS_MESSAGE</NAME>
#define G_TYPE_UNIX_CREDENTIALS_MESSAGE         (g_unix_credentials_message_get_type ())
</MACRO>
<MACRO>
<NAME>G_UNIX_CREDENTIALS_MESSAGE</NAME>
#define G_UNIX_CREDENTIALS_MESSAGE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_CREDENTIALS_MESSAGE, GUnixCredentialsMessage))
</MACRO>
<MACRO>
<NAME>G_UNIX_CREDENTIALS_MESSAGE_CLASS</NAME>
#define G_UNIX_CREDENTIALS_MESSAGE_CLASS(c)     (G_TYPE_CHECK_CLASS_CAST ((c), G_TYPE_UNIX_CREDENTIALS_MESSAGE, GUnixCredentialsMessageClass))
</MACRO>
<MACRO>
<NAME>G_IS_UNIX_CREDENTIALS_MESSAGE</NAME>
#define G_IS_UNIX_CREDENTIALS_MESSAGE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_CREDENTIALS_MESSAGE))
</MACRO>
<MACRO>
<NAME>G_IS_UNIX_CREDENTIALS_MESSAGE_CLASS</NAME>
#define G_IS_UNIX_CREDENTIALS_MESSAGE_CLASS(c)  (G_TYPE_CHECK_CLASS_TYPE ((c), G_TYPE_UNIX_CREDENTIALS_MESSAGE))
</MACRO>
<MACRO>
<NAME>G_UNIX_CREDENTIALS_MESSAGE_GET_CLASS</NAME>
#define G_UNIX_CREDENTIALS_MESSAGE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_CREDENTIALS_MESSAGE, GUnixCredentialsMessageClass))
</MACRO>
<STRUCT>
<NAME>GUnixCredentialsMessageClass</NAME>
struct _GUnixCredentialsMessageClass
{
  GSocketControlMessageClass parent_class;

  /*< private >*/

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
};
</STRUCT>
<STRUCT>
<NAME>GUnixCredentialsMessage</NAME>
struct _GUnixCredentialsMessage
{
  GSocketControlMessage parent_instance;
  GUnixCredentialsMessagePrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>g_unix_credentials_message_get_type</NAME>
<RETURNS>GType                   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_unix_credentials_message_new</NAME>
<RETURNS>GSocketControlMessage  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_unix_credentials_message_new_with_credentials</NAME>
<RETURNS>GSocketControlMessage  *</RETURNS>
GCredentials *credentials
</FUNCTION>
<FUNCTION>
<NAME>g_unix_credentials_message_get_credentials</NAME>
<RETURNS>GCredentials           *</RETURNS>
GUnixCredentialsMessage *message
</FUNCTION>
<FUNCTION>
<NAME>g_unix_credentials_message_is_supported</NAME>
<RETURNS>gboolean                </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GUnixCredentialsMessagePrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_UNIX_FD_LIST</NAME>
#define G_TYPE_UNIX_FD_LIST                                 (g_unix_fd_list_get_type ())
</MACRO>
<MACRO>
<NAME>G_UNIX_FD_LIST</NAME>
#define G_UNIX_FD_LIST(inst)                                (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_UNIX_FD_LIST, GUnixFDList))
</MACRO>
<MACRO>
<NAME>G_UNIX_FD_LIST_CLASS</NAME>
#define G_UNIX_FD_LIST_CLASS(class)                         (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_UNIX_FD_LIST, GUnixFDListClass))
</MACRO>
<MACRO>
<NAME>G_IS_UNIX_FD_LIST</NAME>
#define G_IS_UNIX_FD_LIST(inst)                             (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_UNIX_FD_LIST))
</MACRO>
<MACRO>
<NAME>G_IS_UNIX_FD_LIST_CLASS</NAME>
#define G_IS_UNIX_FD_LIST_CLASS(class)                      (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_UNIX_FD_LIST))
</MACRO>
<MACRO>
<NAME>G_UNIX_FD_LIST_GET_CLASS</NAME>
#define G_UNIX_FD_LIST_GET_CLASS(inst)                      (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_UNIX_FD_LIST, GUnixFDListClass))
</MACRO>
<STRUCT>
<NAME>GUnixFDListClass</NAME>
struct _GUnixFDListClass
{
  GObjectClass parent_class;

  /*< private >*/

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<STRUCT>
<NAME>GUnixFDList</NAME>
struct _GUnixFDList
{
  GObject parent_instance;
  GUnixFDListPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>g_unix_fd_list_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_unix_fd_list_new</NAME>
<RETURNS>GUnixFDList  *           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_unix_fd_list_new_from_array</NAME>
<RETURNS>GUnixFDList  *           </RETURNS>
const gint   *fds, gint          n_fds
</FUNCTION>
<FUNCTION>
<NAME>g_unix_fd_list_append</NAME>
<RETURNS>gint                     </RETURNS>
GUnixFDList  *list, gint          fd, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_unix_fd_list_get_length</NAME>
<RETURNS>gint                     </RETURNS>
GUnixFDList  *list
</FUNCTION>
<FUNCTION>
<NAME>g_unix_fd_list_get</NAME>
<RETURNS>gint                     </RETURNS>
GUnixFDList  *list, gint          index_, GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_unix_fd_list_peek_fds</NAME>
<RETURNS>const gint  *            </RETURNS>
GUnixFDList  *list, gint         *length
</FUNCTION>
<FUNCTION>
<NAME>g_unix_fd_list_steal_fds</NAME>
<RETURNS>gint  *                  </RETURNS>
GUnixFDList  *list, gint         *length
</FUNCTION>
<STRUCT>
<NAME>GUnixFDListPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_UNIX_FD_MESSAGE</NAME>
#define G_TYPE_UNIX_FD_MESSAGE                              (g_unix_fd_message_get_type ())
</MACRO>
<MACRO>
<NAME>G_UNIX_FD_MESSAGE</NAME>
#define G_UNIX_FD_MESSAGE(inst)                             (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
                                                             G_TYPE_UNIX_FD_MESSAGE, GUnixFDMessage))
</MACRO>
<MACRO>
<NAME>G_UNIX_FD_MESSAGE_CLASS</NAME>
#define G_UNIX_FD_MESSAGE_CLASS(class)                      (G_TYPE_CHECK_CLASS_CAST ((class),                       \
                                                             G_TYPE_UNIX_FD_MESSAGE, GUnixFDMessageClass))
</MACRO>
<MACRO>
<NAME>G_IS_UNIX_FD_MESSAGE</NAME>
#define G_IS_UNIX_FD_MESSAGE(inst)                          (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
                                                             G_TYPE_UNIX_FD_MESSAGE))
</MACRO>
<MACRO>
<NAME>G_IS_UNIX_FD_MESSAGE_CLASS</NAME>
#define G_IS_UNIX_FD_MESSAGE_CLASS(class)                   (G_TYPE_CHECK_CLASS_TYPE ((class),                       \
                                                             G_TYPE_UNIX_FD_MESSAGE))
</MACRO>
<MACRO>
<NAME>G_UNIX_FD_MESSAGE_GET_CLASS</NAME>
#define G_UNIX_FD_MESSAGE_GET_CLASS(inst)                   (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
                                                             G_TYPE_UNIX_FD_MESSAGE, GUnixFDMessageClass))
</MACRO>
<STRUCT>
<NAME>GUnixFDMessageClass</NAME>
struct _GUnixFDMessageClass
{
  GSocketControlMessageClass parent_class;

  /*< private >*/

  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
};
</STRUCT>
<STRUCT>
<NAME>GUnixFDMessage</NAME>
struct _GUnixFDMessage
{
  GSocketControlMessage parent_instance;
  GUnixFDMessagePrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>g_unix_fd_message_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_unix_fd_message_new_with_fd_list</NAME>
<RETURNS>GSocketControlMessage  * </RETURNS>
GUnixFDList     *fd_list
</FUNCTION>
<FUNCTION>
<NAME>g_unix_fd_message_new</NAME>
<RETURNS>GSocketControlMessage  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_unix_fd_message_get_fd_list</NAME>
<RETURNS>GUnixFDList  *           </RETURNS>
GUnixFDMessage  *message
</FUNCTION>
<FUNCTION>
<NAME>g_unix_fd_message_steal_fds</NAME>
<RETURNS>gint  *                  </RETURNS>
GUnixFDMessage  *message, gint            *length
</FUNCTION>
<FUNCTION>
<NAME>g_unix_fd_message_append_fd</NAME>
<RETURNS>gboolean                 </RETURNS>
GUnixFDMessage  *message, gint             fd, GError         **error
</FUNCTION>
<STRUCT>
<NAME>GUnixFDMessagePrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_UNIX_INPUT_STREAM</NAME>
#define G_TYPE_UNIX_INPUT_STREAM         (g_unix_input_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_UNIX_INPUT_STREAM</NAME>
#define G_UNIX_INPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_INPUT_STREAM, GUnixInputStream))
</MACRO>
<MACRO>
<NAME>G_UNIX_INPUT_STREAM_CLASS</NAME>
#define G_UNIX_INPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_INPUT_STREAM, GUnixInputStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_UNIX_INPUT_STREAM</NAME>
#define G_IS_UNIX_INPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_UNIX_INPUT_STREAM_CLASS</NAME>
#define G_IS_UNIX_INPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_INPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_UNIX_INPUT_STREAM_GET_CLASS</NAME>
#define G_UNIX_INPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_INPUT_STREAM, GUnixInputStreamClass))
</MACRO>
<STRUCT>
<NAME>GUnixInputStream</NAME>
struct _GUnixInputStream
{
  GInputStream parent_instance;

  /*< private >*/
  GUnixInputStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GUnixInputStreamClass</NAME>
struct _GUnixInputStreamClass
{
  GInputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_unix_input_stream_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_unix_input_stream_new</NAME>
<RETURNS>GInputStream  * </RETURNS>
gint              fd, gboolean          close_fd
</FUNCTION>
<FUNCTION>
<NAME>g_unix_input_stream_set_close_fd</NAME>
<RETURNS>void            </RETURNS>
GUnixInputStream *stream, gboolean          close_fd
</FUNCTION>
<FUNCTION>
<NAME>g_unix_input_stream_get_close_fd</NAME>
<RETURNS>gboolean        </RETURNS>
GUnixInputStream *stream
</FUNCTION>
<FUNCTION>
<NAME>g_unix_input_stream_get_fd</NAME>
<RETURNS>gint            </RETURNS>
GUnixInputStream *stream
</FUNCTION>
<STRUCT>
<NAME>GUnixInputStreamPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_UNIX_MOUNT_ENTRY</NAME>
#define G_TYPE_UNIX_MOUNT_ENTRY (g_unix_mount_entry_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_unix_mount_entry_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_UNIX_MOUNT_POINT</NAME>
#define G_TYPE_UNIX_MOUNT_POINT (g_unix_mount_point_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_unix_mount_point_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_UNIX_MOUNT_MONITOR</NAME>
#define G_TYPE_UNIX_MOUNT_MONITOR        (g_unix_mount_monitor_get_type ())
</MACRO>
<MACRO>
<NAME>G_UNIX_MOUNT_MONITOR</NAME>
#define G_UNIX_MOUNT_MONITOR(o)          (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_MOUNT_MONITOR, GUnixMountMonitor))
</MACRO>
<MACRO>
<NAME>G_UNIX_MOUNT_MONITOR_CLASS</NAME>
#define G_UNIX_MOUNT_MONITOR_CLASS(k)    (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_MOUNT_MONITOR, GUnixMountMonitorClass))
</MACRO>
<MACRO>
<NAME>G_IS_UNIX_MOUNT_MONITOR</NAME>
#define G_IS_UNIX_MOUNT_MONITOR(o)       (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_MOUNT_MONITOR))
</MACRO>
<MACRO>
<NAME>G_IS_UNIX_MOUNT_MONITOR_CLASS</NAME>
#define G_IS_UNIX_MOUNT_MONITOR_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_MOUNT_MONITOR))
</MACRO>
<FUNCTION>
<NAME>g_unix_mount_free</NAME>
<RETURNS>void            </RETURNS>
GUnixMountEntry    *mount_entry
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_copy</NAME>
<RETURNS>GUnixMountEntry  *</RETURNS>
GUnixMountEntry    *mount_entry
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_point_free</NAME>
<RETURNS>void            </RETURNS>
GUnixMountPoint    *mount_point
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_point_copy</NAME>
<RETURNS>GUnixMountPoint  *</RETURNS>
GUnixMountPoint    *mount_point
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_compare</NAME>
<RETURNS>gint            </RETURNS>
GUnixMountEntry    *mount1, GUnixMountEntry    *mount2
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_get_mount_path</NAME>
<RETURNS>const char  *   </RETURNS>
GUnixMountEntry    *mount_entry
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_get_device_path</NAME>
<RETURNS>const char  *   </RETURNS>
GUnixMountEntry    *mount_entry
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_get_fs_type</NAME>
<RETURNS>const char  *   </RETURNS>
GUnixMountEntry    *mount_entry
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_get_options</NAME>
<RETURNS>const char  *   </RETURNS>
GUnixMountEntry    *mount_entry
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_is_readonly</NAME>
<RETURNS>gboolean        </RETURNS>
GUnixMountEntry    *mount_entry
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_is_system_internal</NAME>
<RETURNS>gboolean        </RETURNS>
GUnixMountEntry    *mount_entry
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_guess_can_eject</NAME>
<RETURNS>gboolean        </RETURNS>
GUnixMountEntry    *mount_entry
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_guess_should_display</NAME>
<RETURNS>gboolean        </RETURNS>
GUnixMountEntry    *mount_entry
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_guess_name</NAME>
<RETURNS>char  *         </RETURNS>
GUnixMountEntry    *mount_entry
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_guess_icon</NAME>
<RETURNS>GIcon  *        </RETURNS>
GUnixMountEntry    *mount_entry
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_guess_symbolic_icon</NAME>
<RETURNS>GIcon  *        </RETURNS>
GUnixMountEntry    *mount_entry
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_point_compare</NAME>
<RETURNS>gint            </RETURNS>
GUnixMountPoint    *mount1, GUnixMountPoint    *mount2
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_point_get_mount_path</NAME>
<RETURNS>const char  *   </RETURNS>
GUnixMountPoint    *mount_point
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_point_get_device_path</NAME>
<RETURNS>const char  *   </RETURNS>
GUnixMountPoint    *mount_point
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_point_get_fs_type</NAME>
<RETURNS>const char  *   </RETURNS>
GUnixMountPoint    *mount_point
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_point_get_options</NAME>
<RETURNS>const char  *   </RETURNS>
GUnixMountPoint    *mount_point
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_point_is_readonly</NAME>
<RETURNS>gboolean        </RETURNS>
GUnixMountPoint    *mount_point
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_point_is_user_mountable</NAME>
<RETURNS>gboolean        </RETURNS>
GUnixMountPoint    *mount_point
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_point_is_loopback</NAME>
<RETURNS>gboolean        </RETURNS>
GUnixMountPoint    *mount_point
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_point_guess_can_eject</NAME>
<RETURNS>gboolean        </RETURNS>
GUnixMountPoint    *mount_point
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_point_guess_name</NAME>
<RETURNS>char  *         </RETURNS>
GUnixMountPoint    *mount_point
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_point_guess_icon</NAME>
<RETURNS>GIcon  *        </RETURNS>
GUnixMountPoint    *mount_point
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_point_guess_symbolic_icon</NAME>
<RETURNS>GIcon  *        </RETURNS>
GUnixMountPoint    *mount_point
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_points_get</NAME>
<RETURNS>GList  *        </RETURNS>
guint64            *time_read
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mounts_get</NAME>
<RETURNS>GList  *        </RETURNS>
guint64            *time_read
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_at</NAME>
<RETURNS>GUnixMountEntry  *</RETURNS>
const char         *mount_path, guint64            *time_read
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_for</NAME>
<RETURNS>GUnixMountEntry  *</RETURNS>
const char         *file_path, guint64            *time_read
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mounts_changed_since</NAME>
<RETURNS>gboolean        </RETURNS>
guint64             time
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_points_changed_since</NAME>
<RETURNS>gboolean        </RETURNS>
guint64             time
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_monitor_get_type</NAME>
<RETURNS>GType               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_monitor_get</NAME>
<RETURNS>GUnixMountMonitor  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_monitor_new</NAME>
<DEPRECATED/>
<RETURNS>GUnixMountMonitor  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_unix_mount_monitor_set_rate_limit</NAME>
<DEPRECATED/>
<RETURNS>void                </RETURNS>
GUnixMountMonitor *mount_monitor, int                limit_msec
</FUNCTION>
<FUNCTION>
<NAME>g_unix_is_mount_path_system_internal</NAME>
<RETURNS>gboolean  </RETURNS>
const char *mount_path
</FUNCTION>
<FUNCTION>
<NAME>g_unix_is_system_fs_type</NAME>
<RETURNS>gboolean  </RETURNS>
const char *fs_type
</FUNCTION>
<FUNCTION>
<NAME>g_unix_is_system_device_path</NAME>
<RETURNS>gboolean  </RETURNS>
const char *device_path
</FUNCTION>
<STRUCT>
<NAME>GUnixMountEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GUnixMountMonitor</NAME>
</STRUCT>
<STRUCT>
<NAME>GUnixMountMonitorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GUnixMountPoint</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_UNIX_OUTPUT_STREAM</NAME>
#define G_TYPE_UNIX_OUTPUT_STREAM         (g_unix_output_stream_get_type ())
</MACRO>
<MACRO>
<NAME>G_UNIX_OUTPUT_STREAM</NAME>
#define G_UNIX_OUTPUT_STREAM(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_OUTPUT_STREAM, GUnixOutputStream))
</MACRO>
<MACRO>
<NAME>G_UNIX_OUTPUT_STREAM_CLASS</NAME>
#define G_UNIX_OUTPUT_STREAM_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_OUTPUT_STREAM, GUnixOutputStreamClass))
</MACRO>
<MACRO>
<NAME>G_IS_UNIX_OUTPUT_STREAM</NAME>
#define G_IS_UNIX_OUTPUT_STREAM(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_IS_UNIX_OUTPUT_STREAM_CLASS</NAME>
#define G_IS_UNIX_OUTPUT_STREAM_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_OUTPUT_STREAM))
</MACRO>
<MACRO>
<NAME>G_UNIX_OUTPUT_STREAM_GET_CLASS</NAME>
#define G_UNIX_OUTPUT_STREAM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_OUTPUT_STREAM, GUnixOutputStreamClass))
</MACRO>
<STRUCT>
<NAME>GUnixOutputStream</NAME>
struct _GUnixOutputStream
{
  GOutputStream parent_instance;

  /*< private >*/
  GUnixOutputStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GUnixOutputStreamClass</NAME>
struct _GUnixOutputStreamClass
{
  GOutputStreamClass parent_class;

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_unix_output_stream_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_unix_output_stream_new</NAME>
<RETURNS>GOutputStream  * </RETURNS>
gint     fd, gboolean close_fd
</FUNCTION>
<FUNCTION>
<NAME>g_unix_output_stream_set_close_fd</NAME>
<RETURNS>void             </RETURNS>
GUnixOutputStream *stream, gboolean           close_fd
</FUNCTION>
<FUNCTION>
<NAME>g_unix_output_stream_get_close_fd</NAME>
<RETURNS>gboolean         </RETURNS>
GUnixOutputStream *stream
</FUNCTION>
<FUNCTION>
<NAME>g_unix_output_stream_get_fd</NAME>
<RETURNS>gint             </RETURNS>
GUnixOutputStream *stream
</FUNCTION>
<STRUCT>
<NAME>GUnixOutputStreamPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_UNIX_SOCKET_ADDRESS</NAME>
#define G_TYPE_UNIX_SOCKET_ADDRESS         (g_unix_socket_address_get_type ())
</MACRO>
<MACRO>
<NAME>G_UNIX_SOCKET_ADDRESS</NAME>
#define G_UNIX_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddress))
</MACRO>
<MACRO>
<NAME>G_UNIX_SOCKET_ADDRESS_CLASS</NAME>
#define G_UNIX_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddressClass))
</MACRO>
<MACRO>
<NAME>G_IS_UNIX_SOCKET_ADDRESS</NAME>
#define G_IS_UNIX_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_SOCKET_ADDRESS))
</MACRO>
<MACRO>
<NAME>G_IS_UNIX_SOCKET_ADDRESS_CLASS</NAME>
#define G_IS_UNIX_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_SOCKET_ADDRESS))
</MACRO>
<MACRO>
<NAME>G_UNIX_SOCKET_ADDRESS_GET_CLASS</NAME>
#define G_UNIX_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddressClass))
</MACRO>
<STRUCT>
<NAME>GUnixSocketAddress</NAME>
struct _GUnixSocketAddress
{
  GSocketAddress parent_instance;

  /*< private >*/
  GUnixSocketAddressPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GUnixSocketAddressClass</NAME>
struct _GUnixSocketAddressClass
{
  GSocketAddressClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>g_unix_socket_address_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_unix_socket_address_new</NAME>
<RETURNS>GSocketAddress  *</RETURNS>
const gchar        *path
</FUNCTION>
<FUNCTION>
<NAME>g_unix_socket_address_new_abstract</NAME>
<DEPRECATED/>
<RETURNS>GSocketAddress  *</RETURNS>
const gchar        *path, gint                path_len
</FUNCTION>
<FUNCTION>
<NAME>g_unix_socket_address_new_with_type</NAME>
<RETURNS>GSocketAddress  *</RETURNS>
const gchar            *path, gint                    path_len, GUnixSocketAddressType  type
</FUNCTION>
<FUNCTION>
<NAME>g_unix_socket_address_get_path</NAME>
<RETURNS>const char  *    </RETURNS>
GUnixSocketAddress *address
</FUNCTION>
<FUNCTION>
<NAME>g_unix_socket_address_get_path_len</NAME>
<RETURNS>gsize            </RETURNS>
GUnixSocketAddress *address
</FUNCTION>
<FUNCTION>
<NAME>g_unix_socket_address_get_address_type</NAME>
<RETURNS>GUnixSocketAddressType  </RETURNS>
GUnixSocketAddress *address
</FUNCTION>
<FUNCTION>
<NAME>g_unix_socket_address_get_is_abstract</NAME>
<DEPRECATED/>
<RETURNS>gboolean         </RETURNS>
GUnixSocketAddress *address
</FUNCTION>
<FUNCTION>
<NAME>g_unix_socket_address_abstract_names_supported</NAME>
<RETURNS>gboolean         </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GUnixSocketAddressPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>G_TYPE_VFS</NAME>
#define G_TYPE_VFS         (g_vfs_get_type ())
</MACRO>
<MACRO>
<NAME>G_VFS</NAME>
#define G_VFS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_VFS, GVfs))
</MACRO>
<MACRO>
<NAME>G_VFS_CLASS</NAME>
#define G_VFS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_VFS, GVfsClass))
</MACRO>
<MACRO>
<NAME>G_VFS_GET_CLASS</NAME>
#define G_VFS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_VFS, GVfsClass))
</MACRO>
<MACRO>
<NAME>G_IS_VFS</NAME>
#define G_IS_VFS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_VFS))
</MACRO>
<MACRO>
<NAME>G_IS_VFS_CLASS</NAME>
#define G_IS_VFS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_VFS))
</MACRO>
<USER_FUNCTION>
<NAME>GVfsFileLookupFunc</NAME>
<RETURNS>GFile *</RETURNS>
GVfs       *vfs,
                                        const char *identifier,
                                        gpointer    user_data
</USER_FUNCTION>
<MACRO>
<NAME>G_VFS_EXTENSION_POINT_NAME</NAME>
#define G_VFS_EXTENSION_POINT_NAME "gio-vfs"
</MACRO>
<STRUCT>
<NAME>GVfs</NAME>
struct _GVfs
{
  GObject parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GVfsClass</NAME>
struct _GVfsClass
{
  GObjectClass parent_class;

  /* Virtual Table */

  gboolean              (* is_active)                 (GVfs       *vfs);
  GFile               * (* get_file_for_path)         (GVfs       *vfs,
                                                       const char *path);
  GFile               * (* get_file_for_uri)          (GVfs       *vfs,
                                                       const char *uri);
  const gchar * const * (* get_supported_uri_schemes) (GVfs       *vfs);
  GFile               * (* parse_name)                (GVfs       *vfs,
                                                       const char *parse_name);

  /*< private >*/
  void                  (* local_file_add_info)       (GVfs       *vfs,
						       const char *filename,
						       guint64     device,
						       GFileAttributeMatcher *attribute_matcher,
						       GFileInfo  *info,
						       GCancellable *cancellable,
						       gpointer   *extra_data,
						       GDestroyNotify *free_extra_data);
  void                  (* add_writable_namespaces)   (GVfs       *vfs,
						       GFileAttributeInfoList *list);
  gboolean              (* local_file_set_attributes) (GVfs       *vfs,
						       const char *filename,
						       GFileInfo  *info,
                                                       GFileQueryInfoFlags flags,
                                                       GCancellable *cancellable,
						       GError    **error);
  void                  (* local_file_removed)        (GVfs       *vfs,
						       const char *filename);
  void                  (* local_file_moved)          (GVfs       *vfs,
						       const char *source,
						       const char *dest);
  GIcon *               (* deserialize_icon)          (GVfs       *vfs,
                                                       GVariant   *value);
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_vfs_get_type</NAME>
<RETURNS>GType                  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_vfs_is_active</NAME>
<RETURNS>gboolean               </RETURNS>
GVfs       *vfs
</FUNCTION>
<FUNCTION>
<NAME>g_vfs_get_file_for_path</NAME>
<RETURNS>GFile  *               </RETURNS>
GVfs       *vfs, const char *path
</FUNCTION>
<FUNCTION>
<NAME>g_vfs_get_file_for_uri</NAME>
<RETURNS>GFile  *               </RETURNS>
GVfs       *vfs, const char *uri
</FUNCTION>
<FUNCTION>
<NAME>g_vfs_get_supported_uri_schemes</NAME>
<RETURNS>const gchar * const *</RETURNS>
GVfs       *vfs
</FUNCTION>
<FUNCTION>
<NAME>g_vfs_parse_name</NAME>
<RETURNS>GFile  *               </RETURNS>
GVfs       *vfs, const char *parse_name
</FUNCTION>
<FUNCTION>
<NAME>g_vfs_get_default</NAME>
<RETURNS>GVfs  *                </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_vfs_get_local</NAME>
<RETURNS>GVfs  *                </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_vfs_register_uri_scheme</NAME>
<RETURNS>gboolean               </RETURNS>
GVfs               *vfs, const char         *scheme, GVfsFileLookupFunc  uri_func, gpointer            uri_data, GDestroyNotify      uri_destroy, GVfsFileLookupFunc  parse_name_func, gpointer            parse_name_data, GDestroyNotify      parse_name_destroy
</FUNCTION>
<FUNCTION>
<NAME>g_vfs_unregister_uri_scheme</NAME>
<RETURNS>gboolean               </RETURNS>
GVfs               *vfs, const char         *scheme
</FUNCTION>
<MACRO>
<NAME>G_VOLUME_IDENTIFIER_KIND_HAL_UDI</NAME>
<DEPRECATED/>
#define G_VOLUME_IDENTIFIER_KIND_HAL_UDI "hal-udi"
</MACRO>
<MACRO>
<NAME>G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE</NAME>
<DEPRECATED/>
#define G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE "unix-device"
</MACRO>
<MACRO>
<NAME>G_VOLUME_IDENTIFIER_KIND_LABEL</NAME>
#define G_VOLUME_IDENTIFIER_KIND_LABEL "label"
</MACRO>
<MACRO>
<NAME>G_VOLUME_IDENTIFIER_KIND_UUID</NAME>
#define G_VOLUME_IDENTIFIER_KIND_UUID "uuid"
</MACRO>
<MACRO>
<NAME>G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT</NAME>
#define G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT "nfs-mount"
</MACRO>
<MACRO>
<NAME>G_VOLUME_IDENTIFIER_KIND_CLASS</NAME>
#define G_VOLUME_IDENTIFIER_KIND_CLASS "class"
</MACRO>
<MACRO>
<NAME>G_TYPE_VOLUME</NAME>
#define G_TYPE_VOLUME            (g_volume_get_type ())
</MACRO>
<MACRO>
<NAME>G_VOLUME</NAME>
#define G_VOLUME(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_VOLUME, GVolume))
</MACRO>
<MACRO>
<NAME>G_IS_VOLUME</NAME>
#define G_IS_VOLUME(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_VOLUME))
</MACRO>
<MACRO>
<NAME>G_VOLUME_GET_IFACE</NAME>
#define G_VOLUME_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_VOLUME, GVolumeIface))
</MACRO>
<STRUCT>
<NAME>GVolumeIface</NAME>
struct _GVolumeIface
{
  GTypeInterface g_iface;

  /* signals */

  void        (* changed)               (GVolume             *volume);
  void        (* removed)               (GVolume             *volume);

  /* Virtual Table */

  char      * (* get_name)              (GVolume             *volume);
  GIcon     * (* get_icon)              (GVolume             *volume);
  char      * (* get_uuid)              (GVolume             *volume);
  GDrive    * (* get_drive)             (GVolume             *volume);
  GMount    * (* get_mount)             (GVolume             *volume);
  gboolean    (* can_mount)             (GVolume             *volume);
  gboolean    (* can_eject)             (GVolume             *volume);
  void        (* mount_fn)              (GVolume             *volume,
                                         GMountMountFlags     flags,
                                         GMountOperation     *mount_operation,
                                         GCancellable        *cancellable,
                                         GAsyncReadyCallback  callback,
                                         gpointer             user_data);
  gboolean    (* mount_finish)          (GVolume             *volume,
                                         GAsyncResult        *result,
                                         GError             **error);
  void        (* eject)                 (GVolume             *volume,
                                         GMountUnmountFlags   flags,
                                         GCancellable        *cancellable,
                                         GAsyncReadyCallback  callback,
                                         gpointer             user_data);
  gboolean    (* eject_finish)          (GVolume             *volume,
                                         GAsyncResult        *result,
                                         GError             **error);

  char      * (* get_identifier)        (GVolume             *volume,
                                         const char          *kind);
  char     ** (* enumerate_identifiers) (GVolume             *volume);

  gboolean    (* should_automount)      (GVolume             *volume);

  GFile     * (* get_activation_root)   (GVolume             *volume);

  void        (* eject_with_operation)      (GVolume             *volume,
                                             GMountUnmountFlags   flags,
                                             GMountOperation     *mount_operation,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* eject_with_operation_finish) (GVolume           *volume,
                                             GAsyncResult        *result,
                                             GError             **error);

  const gchar * (* get_sort_key)        (GVolume             *volume);
  GIcon       * (* get_symbolic_icon)   (GVolume             *volume);
};
</STRUCT>
<FUNCTION>
<NAME>g_volume_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_volume_get_name</NAME>
<RETURNS>char  *   </RETURNS>
GVolume              *volume
</FUNCTION>
<FUNCTION>
<NAME>g_volume_get_icon</NAME>
<RETURNS>GIcon  *  </RETURNS>
GVolume              *volume
</FUNCTION>
<FUNCTION>
<NAME>g_volume_get_symbolic_icon</NAME>
<RETURNS>GIcon  *  </RETURNS>
GVolume              *volume
</FUNCTION>
<FUNCTION>
<NAME>g_volume_get_uuid</NAME>
<RETURNS>char  *   </RETURNS>
GVolume              *volume
</FUNCTION>
<FUNCTION>
<NAME>g_volume_get_drive</NAME>
<RETURNS>GDrive  * </RETURNS>
GVolume              *volume
</FUNCTION>
<FUNCTION>
<NAME>g_volume_get_mount</NAME>
<RETURNS>GMount  * </RETURNS>
GVolume              *volume
</FUNCTION>
<FUNCTION>
<NAME>g_volume_can_mount</NAME>
<RETURNS>gboolean  </RETURNS>
GVolume              *volume
</FUNCTION>
<FUNCTION>
<NAME>g_volume_can_eject</NAME>
<RETURNS>gboolean  </RETURNS>
GVolume              *volume
</FUNCTION>
<FUNCTION>
<NAME>g_volume_should_automount</NAME>
<RETURNS>gboolean  </RETURNS>
GVolume              *volume
</FUNCTION>
<FUNCTION>
<NAME>g_volume_mount</NAME>
<RETURNS>void      </RETURNS>
GVolume              *volume, GMountMountFlags      flags, GMountOperation      *mount_operation, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_volume_mount_finish</NAME>
<RETURNS>gboolean  </RETURNS>
GVolume              *volume, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_volume_eject</NAME>
<DEPRECATED/>
<RETURNS>void      </RETURNS>
GVolume              *volume, GMountUnmountFlags    flags, GCancellable         *cancellable, GAsyncReadyCallback   callback, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_volume_eject_finish</NAME>
<DEPRECATED/>
<RETURNS>gboolean  </RETURNS>
GVolume              *volume, GAsyncResult         *result, GError              **error
</FUNCTION>
<FUNCTION>
<NAME>g_volume_get_identifier</NAME>
<RETURNS>char  *   </RETURNS>
GVolume              *volume, const char           *kind
</FUNCTION>
<FUNCTION>
<NAME>g_volume_enumerate_identifiers</NAME>
<RETURNS>char  **  </RETURNS>
GVolume              *volume
</FUNCTION>
<FUNCTION>
<NAME>g_volume_get_activation_root</NAME>
<RETURNS>GFile  *  </RETURNS>
GVolume              *volume
</FUNCTION>
<FUNCTION>
<NAME>g_volume_eject_with_operation</NAME>
<RETURNS>void         </RETURNS>
GVolume             *volume, GMountUnmountFlags   flags, GMountOperation     *mount_operation, GCancellable        *cancellable, GAsyncReadyCallback  callback, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>g_volume_eject_with_operation_finish</NAME>
<RETURNS>gboolean     </RETURNS>
GVolume          *volume, GAsyncResult        *result, GError             **error
</FUNCTION>
<FUNCTION>
<NAME>g_volume_get_sort_key</NAME>
<RETURNS>const gchar  *</RETURNS>
GVolume              *volume
</FUNCTION>
<MACRO>
<NAME>G_TYPE_VOLUME_MONITOR</NAME>
#define G_TYPE_VOLUME_MONITOR         (g_volume_monitor_get_type ())
</MACRO>
<MACRO>
<NAME>G_VOLUME_MONITOR</NAME>
#define G_VOLUME_MONITOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_VOLUME_MONITOR, GVolumeMonitor))
</MACRO>
<MACRO>
<NAME>G_VOLUME_MONITOR_CLASS</NAME>
#define G_VOLUME_MONITOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_VOLUME_MONITOR, GVolumeMonitorClass))
</MACRO>
<MACRO>
<NAME>G_VOLUME_MONITOR_GET_CLASS</NAME>
#define G_VOLUME_MONITOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_VOLUME_MONITOR, GVolumeMonitorClass))
</MACRO>
<MACRO>
<NAME>G_IS_VOLUME_MONITOR</NAME>
#define G_IS_VOLUME_MONITOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_VOLUME_MONITOR))
</MACRO>
<MACRO>
<NAME>G_IS_VOLUME_MONITOR_CLASS</NAME>
#define G_IS_VOLUME_MONITOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_VOLUME_MONITOR))
</MACRO>
<MACRO>
<NAME>G_VOLUME_MONITOR_EXTENSION_POINT_NAME</NAME>
#define G_VOLUME_MONITOR_EXTENSION_POINT_NAME "gio-volume-monitor"
</MACRO>
<STRUCT>
<NAME>GVolumeMonitor</NAME>
struct _GVolumeMonitor
{
  GObject parent_instance;

  /*< private >*/
  gpointer priv;
};
</STRUCT>
<STRUCT>
<NAME>GVolumeMonitorClass</NAME>
struct _GVolumeMonitorClass
{
  GObjectClass parent_class;

  /*< public >*/
  /* signals */
  void      (* volume_added)         (GVolumeMonitor *volume_monitor,
                                      GVolume        *volume);
  void      (* volume_removed)       (GVolumeMonitor *volume_monitor,
                                      GVolume        *volume);
  void      (* volume_changed)       (GVolumeMonitor *volume_monitor,
                                      GVolume        *volume);

  void      (* mount_added)          (GVolumeMonitor *volume_monitor,
                                      GMount         *mount);
  void      (* mount_removed)        (GVolumeMonitor *volume_monitor,
                                      GMount         *mount);
  void      (* mount_pre_unmount)    (GVolumeMonitor *volume_monitor,
                                      GMount         *mount);
  void      (* mount_changed)        (GVolumeMonitor *volume_monitor,
                                      GMount         *mount);

  void      (* drive_connected)      (GVolumeMonitor *volume_monitor,
                                      GDrive	     *drive);
  void      (* drive_disconnected)   (GVolumeMonitor *volume_monitor,
                                      GDrive         *drive);
  void      (* drive_changed)        (GVolumeMonitor *volume_monitor,
                                      GDrive         *drive);

  /* Vtable */

  gboolean  (* is_supported)         (void);

  GList   * (* get_connected_drives) (GVolumeMonitor *volume_monitor);
  GList   * (* get_volumes)          (GVolumeMonitor *volume_monitor);
  GList   * (* get_mounts)           (GVolumeMonitor *volume_monitor);

  GVolume * (* get_volume_for_uuid)  (GVolumeMonitor *volume_monitor,
                                      const char     *uuid);

  GMount  * (* get_mount_for_uuid)   (GVolumeMonitor *volume_monitor,
                                      const char     *uuid);


  /* These arguments are unfortunately backwards by mistake (bug #520169). Deprecated in 2.20. */
  GVolume * (* adopt_orphan_mount)   (GMount         *mount,
                                      GVolumeMonitor *volume_monitor);

  /* signal added in 2.17 */
  void      (* drive_eject_button)   (GVolumeMonitor *volume_monitor,
                                      GDrive         *drive);

  /* signal added in 2.21 */
  void      (* drive_stop_button)   (GVolumeMonitor *volume_monitor,
                                     GDrive         *drive);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
};
</STRUCT>
<FUNCTION>
<NAME>g_volume_monitor_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_volume_monitor_get</NAME>
<RETURNS>GVolumeMonitor  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_volume_monitor_get_connected_drives</NAME>
<RETURNS>GList  *         </RETURNS>
GVolumeMonitor *volume_monitor
</FUNCTION>
<FUNCTION>
<NAME>g_volume_monitor_get_volumes</NAME>
<RETURNS>GList  *         </RETURNS>
GVolumeMonitor *volume_monitor
</FUNCTION>
<FUNCTION>
<NAME>g_volume_monitor_get_mounts</NAME>
<RETURNS>GList  *         </RETURNS>
GVolumeMonitor *volume_monitor
</FUNCTION>
<FUNCTION>
<NAME>g_volume_monitor_get_volume_for_uuid</NAME>
<RETURNS>GVolume  *       </RETURNS>
GVolumeMonitor *volume_monitor, const char     *uuid
</FUNCTION>
<FUNCTION>
<NAME>g_volume_monitor_get_mount_for_uuid</NAME>
<RETURNS>GMount  *        </RETURNS>
GVolumeMonitor *volume_monitor, const char     *uuid
</FUNCTION>
<FUNCTION>
<NAME>g_volume_monitor_adopt_orphan_mount</NAME>
<DEPRECATED/>
<RETURNS>GVolume  *       </RETURNS>
GMount         *mount
</FUNCTION>
<VARIABLE>
<NAME>ws2funcs</NAME>
extern GWin32WinsockFuncs ws2funcs;
</VARIABLE>
<MACRO>
<NAME>G_TYPE_ZLIB_COMPRESSOR</NAME>
#define G_TYPE_ZLIB_COMPRESSOR         (g_zlib_compressor_get_type ())
</MACRO>
<MACRO>
<NAME>G_ZLIB_COMPRESSOR</NAME>
#define G_ZLIB_COMPRESSOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_ZLIB_COMPRESSOR, GZlibCompressor))
</MACRO>
<MACRO>
<NAME>G_ZLIB_COMPRESSOR_CLASS</NAME>
#define G_ZLIB_COMPRESSOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_ZLIB_COMPRESSOR, GZlibCompressorClass))
</MACRO>
<MACRO>
<NAME>G_IS_ZLIB_COMPRESSOR</NAME>
#define G_IS_ZLIB_COMPRESSOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_ZLIB_COMPRESSOR))
</MACRO>
<MACRO>
<NAME>G_IS_ZLIB_COMPRESSOR_CLASS</NAME>
#define G_IS_ZLIB_COMPRESSOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_ZLIB_COMPRESSOR))
</MACRO>
<MACRO>
<NAME>G_ZLIB_COMPRESSOR_GET_CLASS</NAME>
#define G_ZLIB_COMPRESSOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_ZLIB_COMPRESSOR, GZlibCompressorClass))
</MACRO>
<STRUCT>
<NAME>GZlibCompressorClass</NAME>
struct _GZlibCompressorClass
{
  GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>g_zlib_compressor_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_zlib_compressor_new</NAME>
<RETURNS>GZlibCompressor  *</RETURNS>
GZlibCompressorFormat format, int level
</FUNCTION>
<FUNCTION>
<NAME>g_zlib_compressor_get_file_info</NAME>
<RETURNS>GFileInfo        *</RETURNS>
GZlibCompressor *compressor
</FUNCTION>
<FUNCTION>
<NAME>g_zlib_compressor_set_file_info</NAME>
<RETURNS>void              </RETURNS>
GZlibCompressor *compressor, GFileInfo       *file_info
</FUNCTION>
<MACRO>
<NAME>G_TYPE_ZLIB_DECOMPRESSOR</NAME>
#define G_TYPE_ZLIB_DECOMPRESSOR         (g_zlib_decompressor_get_type ())
</MACRO>
<MACRO>
<NAME>G_ZLIB_DECOMPRESSOR</NAME>
#define G_ZLIB_DECOMPRESSOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_ZLIB_DECOMPRESSOR, GZlibDecompressor))
</MACRO>
<MACRO>
<NAME>G_ZLIB_DECOMPRESSOR_CLASS</NAME>
#define G_ZLIB_DECOMPRESSOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_ZLIB_DECOMPRESSOR, GZlibDecompressorClass))
</MACRO>
<MACRO>
<NAME>G_IS_ZLIB_DECOMPRESSOR</NAME>
#define G_IS_ZLIB_DECOMPRESSOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_ZLIB_DECOMPRESSOR))
</MACRO>
<MACRO>
<NAME>G_IS_ZLIB_DECOMPRESSOR_CLASS</NAME>
#define G_IS_ZLIB_DECOMPRESSOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_ZLIB_DECOMPRESSOR))
</MACRO>
<MACRO>
<NAME>G_ZLIB_DECOMPRESSOR_GET_CLASS</NAME>
#define G_ZLIB_DECOMPRESSOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_ZLIB_DECOMPRESSOR, GZlibDecompressorClass))
</MACRO>
<STRUCT>
<NAME>GZlibDecompressorClass</NAME>
struct _GZlibDecompressorClass
{
  GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>g_zlib_decompressor_get_type</NAME>
<RETURNS>GType               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_zlib_decompressor_new</NAME>
<RETURNS>GZlibDecompressor  *</RETURNS>
GZlibCompressorFormat format
</FUNCTION>
<FUNCTION>
<NAME>g_zlib_decompressor_get_file_info</NAME>
<RETURNS>GFileInfo          *</RETURNS>
GZlibDecompressor *decompressor
</FUNCTION>
<FUNCTION>
<NAME>g_app_info_create_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_APP_INFO_CREATE_FLAGS</NAME>
#define G_TYPE_APP_INFO_CREATE_FLAGS (g_app_info_create_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_converter_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_CONVERTER_FLAGS</NAME>
#define G_TYPE_CONVERTER_FLAGS (g_converter_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_converter_result_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_CONVERTER_RESULT</NAME>
#define G_TYPE_CONVERTER_RESULT (g_converter_result_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_data_stream_byte_order_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DATA_STREAM_BYTE_ORDER</NAME>
#define G_TYPE_DATA_STREAM_BYTE_ORDER (g_data_stream_byte_order_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_data_stream_newline_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DATA_STREAM_NEWLINE_TYPE</NAME>
#define G_TYPE_DATA_STREAM_NEWLINE_TYPE (g_data_stream_newline_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_file_attribute_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_FILE_ATTRIBUTE_TYPE</NAME>
#define G_TYPE_FILE_ATTRIBUTE_TYPE (g_file_attribute_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_file_attribute_info_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_FILE_ATTRIBUTE_INFO_FLAGS</NAME>
#define G_TYPE_FILE_ATTRIBUTE_INFO_FLAGS (g_file_attribute_info_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_file_attribute_status_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_FILE_ATTRIBUTE_STATUS</NAME>
#define G_TYPE_FILE_ATTRIBUTE_STATUS (g_file_attribute_status_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_file_query_info_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_FILE_QUERY_INFO_FLAGS</NAME>
#define G_TYPE_FILE_QUERY_INFO_FLAGS (g_file_query_info_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_file_create_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_FILE_CREATE_FLAGS</NAME>
#define G_TYPE_FILE_CREATE_FLAGS (g_file_create_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_file_measure_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_FILE_MEASURE_FLAGS</NAME>
#define G_TYPE_FILE_MEASURE_FLAGS (g_file_measure_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_mount_mount_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_MOUNT_MOUNT_FLAGS</NAME>
#define G_TYPE_MOUNT_MOUNT_FLAGS (g_mount_mount_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_mount_unmount_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_MOUNT_UNMOUNT_FLAGS</NAME>
#define G_TYPE_MOUNT_UNMOUNT_FLAGS (g_mount_unmount_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_drive_start_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DRIVE_START_FLAGS</NAME>
#define G_TYPE_DRIVE_START_FLAGS (g_drive_start_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_drive_start_stop_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DRIVE_START_STOP_TYPE</NAME>
#define G_TYPE_DRIVE_START_STOP_TYPE (g_drive_start_stop_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_file_copy_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_FILE_COPY_FLAGS</NAME>
#define G_TYPE_FILE_COPY_FLAGS (g_file_copy_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_file_monitor_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_FILE_MONITOR_FLAGS</NAME>
#define G_TYPE_FILE_MONITOR_FLAGS (g_file_monitor_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_file_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_FILE_TYPE</NAME>
#define G_TYPE_FILE_TYPE (g_file_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_filesystem_preview_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_FILESYSTEM_PREVIEW_TYPE</NAME>
#define G_TYPE_FILESYSTEM_PREVIEW_TYPE (g_filesystem_preview_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_file_monitor_event_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_FILE_MONITOR_EVENT</NAME>
#define G_TYPE_FILE_MONITOR_EVENT (g_file_monitor_event_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_io_error_enum_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_IO_ERROR_ENUM</NAME>
#define G_TYPE_IO_ERROR_ENUM (g_io_error_enum_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_ask_password_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_ASK_PASSWORD_FLAGS</NAME>
#define G_TYPE_ASK_PASSWORD_FLAGS (g_ask_password_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_password_save_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_PASSWORD_SAVE</NAME>
#define G_TYPE_PASSWORD_SAVE (g_password_save_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_mount_operation_result_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_MOUNT_OPERATION_RESULT</NAME>
#define G_TYPE_MOUNT_OPERATION_RESULT (g_mount_operation_result_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_output_stream_splice_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_OUTPUT_STREAM_SPLICE_FLAGS</NAME>
#define G_TYPE_OUTPUT_STREAM_SPLICE_FLAGS (g_output_stream_splice_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_io_stream_splice_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_IO_STREAM_SPLICE_FLAGS</NAME>
#define G_TYPE_IO_STREAM_SPLICE_FLAGS (g_io_stream_splice_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_emblem_origin_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_EMBLEM_ORIGIN</NAME>
#define G_TYPE_EMBLEM_ORIGIN (g_emblem_origin_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_resolver_error_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_RESOLVER_ERROR</NAME>
#define G_TYPE_RESOLVER_ERROR (g_resolver_error_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_resolver_record_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_RESOLVER_RECORD_TYPE</NAME>
#define G_TYPE_RESOLVER_RECORD_TYPE (g_resolver_record_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_resource_error_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_RESOURCE_ERROR</NAME>
#define G_TYPE_RESOURCE_ERROR (g_resource_error_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_resource_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_RESOURCE_FLAGS</NAME>
#define G_TYPE_RESOURCE_FLAGS (g_resource_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_resource_lookup_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_RESOURCE_LOOKUP_FLAGS</NAME>
#define G_TYPE_RESOURCE_LOOKUP_FLAGS (g_resource_lookup_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_socket_family_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SOCKET_FAMILY</NAME>
#define G_TYPE_SOCKET_FAMILY (g_socket_family_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_socket_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SOCKET_TYPE</NAME>
#define G_TYPE_SOCKET_TYPE (g_socket_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_socket_msg_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SOCKET_MSG_FLAGS</NAME>
#define G_TYPE_SOCKET_MSG_FLAGS (g_socket_msg_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_socket_protocol_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SOCKET_PROTOCOL</NAME>
#define G_TYPE_SOCKET_PROTOCOL (g_socket_protocol_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_zlib_compressor_format_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_ZLIB_COMPRESSOR_FORMAT</NAME>
#define G_TYPE_ZLIB_COMPRESSOR_FORMAT (g_zlib_compressor_format_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_unix_socket_address_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_UNIX_SOCKET_ADDRESS_TYPE</NAME>
#define G_TYPE_UNIX_SOCKET_ADDRESS_TYPE (g_unix_socket_address_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_bus_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_BUS_TYPE</NAME>
#define G_TYPE_BUS_TYPE (g_bus_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_bus_name_owner_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_BUS_NAME_OWNER_FLAGS</NAME>
#define G_TYPE_BUS_NAME_OWNER_FLAGS (g_bus_name_owner_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_bus_name_watcher_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_BUS_NAME_WATCHER_FLAGS</NAME>
#define G_TYPE_BUS_NAME_WATCHER_FLAGS (g_bus_name_watcher_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_proxy_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_PROXY_FLAGS</NAME>
#define G_TYPE_DBUS_PROXY_FLAGS (g_dbus_proxy_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_error_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_ERROR</NAME>
#define G_TYPE_DBUS_ERROR (g_dbus_error_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_connection_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_CONNECTION_FLAGS</NAME>
#define G_TYPE_DBUS_CONNECTION_FLAGS (g_dbus_connection_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_capability_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_CAPABILITY_FLAGS</NAME>
#define G_TYPE_DBUS_CAPABILITY_FLAGS (g_dbus_capability_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_call_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_CALL_FLAGS</NAME>
#define G_TYPE_DBUS_CALL_FLAGS (g_dbus_call_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_message_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_MESSAGE_TYPE</NAME>
#define G_TYPE_DBUS_MESSAGE_TYPE (g_dbus_message_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_message_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_MESSAGE_FLAGS</NAME>
#define G_TYPE_DBUS_MESSAGE_FLAGS (g_dbus_message_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_message_header_field_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_MESSAGE_HEADER_FIELD</NAME>
#define G_TYPE_DBUS_MESSAGE_HEADER_FIELD (g_dbus_message_header_field_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_property_info_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_PROPERTY_INFO_FLAGS</NAME>
#define G_TYPE_DBUS_PROPERTY_INFO_FLAGS (g_dbus_property_info_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_subtree_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_SUBTREE_FLAGS</NAME>
#define G_TYPE_DBUS_SUBTREE_FLAGS (g_dbus_subtree_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_server_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_SERVER_FLAGS</NAME>
#define G_TYPE_DBUS_SERVER_FLAGS (g_dbus_server_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_signal_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_SIGNAL_FLAGS</NAME>
#define G_TYPE_DBUS_SIGNAL_FLAGS (g_dbus_signal_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_send_message_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_SEND_MESSAGE_FLAGS</NAME>
#define G_TYPE_DBUS_SEND_MESSAGE_FLAGS (g_dbus_send_message_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_credentials_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_CREDENTIALS_TYPE</NAME>
#define G_TYPE_CREDENTIALS_TYPE (g_credentials_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_message_byte_order_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_MESSAGE_BYTE_ORDER</NAME>
#define G_TYPE_DBUS_MESSAGE_BYTE_ORDER (g_dbus_message_byte_order_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_application_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_APPLICATION_FLAGS</NAME>
#define G_TYPE_APPLICATION_FLAGS (g_application_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_tls_error_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_TLS_ERROR</NAME>
#define G_TYPE_TLS_ERROR (g_tls_error_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_tls_certificate_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_TLS_CERTIFICATE_FLAGS</NAME>
#define G_TYPE_TLS_CERTIFICATE_FLAGS (g_tls_certificate_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_tls_authentication_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_TLS_AUTHENTICATION_MODE</NAME>
#define G_TYPE_TLS_AUTHENTICATION_MODE (g_tls_authentication_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_tls_rehandshake_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_TLS_REHANDSHAKE_MODE</NAME>
#define G_TYPE_TLS_REHANDSHAKE_MODE (g_tls_rehandshake_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_tls_password_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_TLS_PASSWORD_FLAGS</NAME>
#define G_TYPE_TLS_PASSWORD_FLAGS (g_tls_password_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_tls_interaction_result_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_TLS_INTERACTION_RESULT</NAME>
#define G_TYPE_TLS_INTERACTION_RESULT (g_tls_interaction_result_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_interface_skeleton_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_INTERFACE_SKELETON_FLAGS</NAME>
#define G_TYPE_DBUS_INTERFACE_SKELETON_FLAGS (g_dbus_interface_skeleton_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_dbus_object_manager_client_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_DBUS_OBJECT_MANAGER_CLIENT_FLAGS</NAME>
#define G_TYPE_DBUS_OBJECT_MANAGER_CLIENT_FLAGS (g_dbus_object_manager_client_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_tls_database_verify_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_TLS_DATABASE_VERIFY_FLAGS</NAME>
#define G_TYPE_TLS_DATABASE_VERIFY_FLAGS (g_tls_database_verify_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_tls_database_lookup_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_TLS_DATABASE_LOOKUP_FLAGS</NAME>
#define G_TYPE_TLS_DATABASE_LOOKUP_FLAGS (g_tls_database_lookup_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_tls_certificate_request_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_TLS_CERTIFICATE_REQUEST_FLAGS</NAME>
#define G_TYPE_TLS_CERTIFICATE_REQUEST_FLAGS (g_tls_certificate_request_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_io_module_scope_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_IO_MODULE_SCOPE_FLAGS</NAME>
#define G_TYPE_IO_MODULE_SCOPE_FLAGS (g_io_module_scope_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_socket_client_event_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SOCKET_CLIENT_EVENT</NAME>
#define G_TYPE_SOCKET_CLIENT_EVENT (g_socket_client_event_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_socket_listener_event_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SOCKET_LISTENER_EVENT</NAME>
#define G_TYPE_SOCKET_LISTENER_EVENT (g_socket_listener_event_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_test_dbus_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_TEST_DBUS_FLAGS</NAME>
#define G_TYPE_TEST_DBUS_FLAGS (g_test_dbus_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_subprocess_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SUBPROCESS_FLAGS</NAME>
#define G_TYPE_SUBPROCESS_FLAGS (g_subprocess_flags_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_notification_priority_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_NOTIFICATION_PRIORITY</NAME>
#define G_TYPE_NOTIFICATION_PRIORITY (g_notification_priority_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_network_connectivity_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_NETWORK_CONNECTIVITY</NAME>
#define G_TYPE_NETWORK_CONNECTIVITY (g_network_connectivity_get_type ())
</MACRO>
<FUNCTION>
<NAME>g_settings_bind_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_SETTINGS_BIND_FLAGS</NAME>
#define G_TYPE_SETTINGS_BIND_FLAGS (g_settings_bind_flags_get_type ())
</MACRO>
<MACRO>
<NAME>T_SRV</NAME>
#define T_SRV 33
</MACRO>
<MACRO>
<NAME>CMSG_LEN</NAME>
#define CMSG_LEN(len) ((size_t)CMSG_DATA((struct cmsghdr *)NULL) + (len))
</MACRO>
<MACRO>
<NAME>GLIB_ALIGN_TO_SIZEOF</NAME>
#define GLIB_ALIGN_TO_SIZEOF(len, obj) (((len) + sizeof (obj) - 1) & ~(sizeof (obj) - 1))
</MACRO>
<MACRO>
<NAME>CMSG_SPACE</NAME>
#define CMSG_SPACE(len) GLIB_ALIGN_TO_SIZEOF (CMSG_LEN (len), struct cmsghdr)
</MACRO>
<FUNCTION>
<NAME>g_networking_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
